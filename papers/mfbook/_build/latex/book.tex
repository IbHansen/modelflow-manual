%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Foreword}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{MFMod models in Python with ModelFlow}
\date{Mar 27, 2023}
\release{}
\author{Andrew Burns and Ib Hansen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{content/introduction::doc}}




\sphinxAtStartPar
Andrew Burns and Ib hansen



\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\sphinxstepscope


\part{Foreword}

\sphinxstepscope


\chapter{Foreword}
\label{\detokenize{content/00_Foreword/Foreword:foreword}}\label{\detokenize{content/00_Foreword/Foreword::doc}}
\sphinxAtStartPar
Lorem Ipsum
“Neque porro quisquam est qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit…”
“There is no one who loves pain itself, who seeks after it and wants to have it, simply because it is pain…”

\sphinxAtStartPar
freestar

\sphinxAtStartPar
freestar
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum aliquam varius mi. Suspendisse pharetra egestas viverra. Aenean viverra hendrerit sagittis. Curabitur vel lectus at arcu mattis blandit. Quisque aliquet erat nunc, vitae consequat eros venenatis eu. Vivamus ut arcu eget ipsum mollis iaculis. Aliquam rhoncus bibendum orci. Donec lacinia, mauris placerat auctor vehicula, odio eros efficitur leo, et porttitor est urna vitae erat. Cras tempor nec purus at tincidunt. Maecenas viverra massa diam, sit amet tristique mi scelerisque non. Etiam scelerisque, risus ac mollis hendrerit, ex velit vehicula tortor, quis accumsan leo enim sed leo. Suspendisse potenti. Nulla libero diam, eleifend nec sollicitudin ut, varius non eros.

\sphinxAtStartPar
Ut sit amet mollis ipsum. Donec tempor magna ac blandit gravida. Phasellus viverra, arcu at euismod auctor, lectus justo vehicula eros, sit amet posuere felis mi ac purus. Nullam gravida lacinia bibendum. Vivamus ultrices justo sed aliquam feugiat. Mauris vulputate sapien in tempus posuere. Morbi nec purus eget ipsum fermentum congue. Vivamus auctor, mi sit amet lacinia suscipit, ipsum lectus pulvinar risus, non condimentum eros felis sed quam. Pellentesque consectetur leo sit amet condimentum commodo. Orci varius natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Duis risus mi, elementum ac leo ut, ultrices scelerisque dui.

\sphinxAtStartPar
Sed quis arcu et dui viverra interdum vitae id enim. In euismod diam quis eleifend viverra. Nullam sodales dictum turpis, vestibulum sodales erat. Morbi quis orci dictum mauris volutpat porttitor at at sapien. Maecenas nec metus ut felis malesuada dapibus. Duis semper lacus eget hendrerit congue. Aenean condimentum, ligula ac sagittis rutrum, turpis elit pulvinar libero, eget tristique sapien sem eget lacus. Curabitur egestas velit quis eros volutpat rhoncus. Nunc quam nibh, commodo ac egestas non, tristique sit amet nisl. Ut vitae lacinia justo.

\sphinxAtStartPar
Indermit Gil
World Bank Chief Economist

\sphinxstepscope


\part{Introduction}

\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{content/01_Introduction/Introduction:introduction}}\label{\detokenize{content/01_Introduction/Introduction::doc}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This Jupyter Book is work in progress.
\end{sphinxadmonition}

\sphinxAtStartPar
This paper describes the implementation of the World Bank’s MacroFiscalModel (MFMod) {\color{red}\bfseries{}:cite:p:`burns\_world\_2019`} in the open source solution program ModelFlow (\sphinxhref{https://ibhansen.github.io/doc/index}{Hansen, 2023}).


\section{Background}
\label{\detokenize{content/01_Introduction/Introduction:background}}
\sphinxAtStartPar
The impetus for this paper and the work that it summarizes was to make available to a wider constituency the work that the Bank has done over the past several decades to disseminate Macro\sphinxhyphen{}structural or models%
\begin{footnote}[1]\sphinxAtStartFootnote
Economic modelling has a long tradition at the World Bank.  The Bank has had a long\sphinxhyphen{}standing involvement in CGE modeling is the World Bank {\color{red}\bfseries{}:cite:p:`dixon\_handbook\_2013`}, indeed the popular mathematics package GAMS, which is widely used to solve CGE and Linear Programming models, \sphinxhref{https://www.gams.com/about/company/}{started out} as a project begun at the World Bank in the 1970s.
%
\end{footnote}: My footnote text. – notably those that form part of its MFMod (MacroFiscalModel) framework.

\sphinxAtStartPar
MFMod is the World Bank’s work\sphinxhyphen{}horse macro\sphinxhyphen{}structural economic modelling framework. It exists as a linked system of 184 country specific models that can be solved either independently or as a larger system. The MFMod system evolved from earlier models developed by the Bank during the 2000s to strengthen the basis for the forecasts produced by the World Bank.

\sphinxAtStartPar
Beginning in 2015, this core model was developed and extended substantially into the main MFMod (MacroFiscalModel) model that is used for the World Bank’s twice annual forecasting exercise \sphinxhref{https://www.worldbank.org/en/publication/macro-poverty-outlook}{The Macro Poverty Outlook}.  This model continues to evolve and be used as the workhorse forecasting and policy simulation model of the World Bank.


\subsection{Climate change and the MFMod system}
\label{\detokenize{content/01_Introduction/Introduction:climate-change-and-the-mfmod-system}}
\sphinxAtStartPar
Most recently, the Bank has extended the standard MFMod framework to incorporate the main features of climate change ({\color{red}\bfseries{}:cite:p:`burns\_climate\_2021`})– both in terms of the impact of the economy on climate (principally through green\sphinxhyphen{}house gas emissions, like \(CO_2, N_{2}O, CH_4, ...\)) and the impact of the changing climate on the economy (higher temperatures, changes in rainfall quantity and variability, increased incidence of extreme weather) and their impacts on the economy (agricultural output, labor productivity, physical damages due to extreme weather events, sea\sphinxhyphen{}level rises etc.).

\sphinxAtStartPar
These climate enhanced versions of MFMod serve as one of the two main modelling systems (along with the Bank’s MANAGE CGE system) in the World Bank’s {[}Country Climate Development Reports(https://www.worldbank.org/en/publication/country\sphinxhyphen{}climate\sphinxhyphen{}development\sphinxhyphen{}reports)


\section{Early steps to bring the MFMod system to the broader economics community}
\label{\detokenize{content/01_Introduction/Introduction:early-steps-to-bring-the-mfmod-system-to-the-broader-economics-community}}
\sphinxAtStartPar
Bank staff were quick to recognize that the models built for its own needs could be of use to the broader economics community. An initial project \sphinxcode{\sphinxupquote{isimulate}} in 2007 made several versions of this earlier model available for simulation on the \sphinxhref{https://isimulate.worldbank.org}{isimulate platform}, and these models continue to be available there.  The isimulate platform housed (and continues to house) public access to earlier versions of the MFMod system, and allows simulation of these and other models – but does not give researchers access to the code or the ability to construct complex simulations.

\sphinxAtStartPar
In another effort to make models widely available a large number (more than 60 as of June 2023) customized stand\sphinxhyphen{}alone models (collectively known as called MFModSA \sphinxhyphen{} MacroFiscalModel StandAlones)  have been developed from the main model. Typically developed for a country\sphinxhyphen{}client (Ministry of Finance, Economy or Planning or Central Bank), these Stand Alones extend the standard model by incorporating additional details not in the standard model that are of specific import to different economies and the country\sphinxhyphen{}clients for whom they were built, including: a more detailed breakdown of the sectoral make up of an economy, more detailed fiscal and monetary accounts, and other economically important features of the economy that may exist only inside the aggregates of the standard model.

\sphinxAtStartPar
Training and dissemination around these customized versions of MFMod have been ongoing since 2013. In addition to making customized models available to client governments, Bank teams have run technical assistance program designed to train government officials in the use of these models and their maintenance, modification and revision.


\section{Moving the framework to an open\sphinxhyphen{}source footing}
\label{\detokenize{content/01_Introduction/Introduction:moving-the-framework-to-an-open-source-footing}}
\sphinxAtStartPar
Models in the MFMod family are normally built using the proprietary \DUrole{xref,myst}{EViews} econometric and modelling package. While offering many advantages for model development and maintenance, its cost may be a barrier to clients in developing countries.  As a result, the World Bank joined with Ib Hansen, a Danish economist formerly with the European Central Bank and the Danish Central Bank, who over the years has developed \sphinxcode{\sphinxupquote{modelflow}} a generalized solution engine written in Python for economic models. Together with World Bank, Hansen has worked to extend \sphinxcode{\sphinxupquote{modelflow}} so that MFMod models can be ported and run in the framework.

\sphinxAtStartPar
This paper reports on the results of these efforts. In particular, it provides step by step instructions on how to install the \sphinxcode{\sphinxupquote{modelflow}} framework, import a World Bank macrostructural model,  perform simulations with that model and report results using the many analytical and reporting tools that have been built into \sphinxcode{\sphinxupquote{modelflow}}.  It is not a manual for \sphinxcode{\sphinxupquote{modelflow}}, such a manual can be found \sphinxhref{https://ibhansen.github.io/doc/index}{here} nor is it documentation for the MFMod system ({\color{red}\bfseries{}:cite:author:`burns\_world\_2019`},{\color{red}\bfseries{}:cite:p:`burns\_macroeconomic\_2021`}, {\color{red}\bfseries{}:cite:p:`burns\_climate\_2021`}) or the specific models described and worked with below.


\bigskip\hrule\bigskip


\sphinxstepscope


\part{Macrostructural Models}

\sphinxstepscope


\chapter{Macrostructural models}
\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels:macrostructural-models}}\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels::doc}}
\sphinxAtStartPar
The economics profession uses a wide range of models for different purposes.  Macro\sphinxhyphen{}structural models (also known as semi\sphinxhyphen{}structural or Macro\sphinxhyphen{}econometric models) are a class of models that seek to summarize the most important interconnections and determinants of an economy. Computable General Equilibrium (CGE), and Dynamic Stochastic General Equilibrium (DSGE) models are other classes of models that also seek, using somewhat different methodologies, to capture the main economic channels by which the actions of agents (firms, households, governments) interact and help determine the structure, level and rate of growth of economic activity in an economy. Olivier Blanchard, former Chief Economist at the International Monetary Fund, in a series of articles published between 2016 and 2018 that were summarized in {\color{red}\bfseries{}:cite:author:`blanchard\_future\_2018`}. In these articles he lays out his views on the relative strengths and weaknesses of each of these systems, concluding that each has a role to play in helping economists analyze the macro\sphinxhyphen{}economy.

\sphinxAtStartPar
Typically organizations, including the World Bank, use all of these tools, privileging one or the other for specific purposes. Macrostructural models like the MFMod framework are widely used by Central Banks, Ministries of Finance; and professional forecasters both for the purposes of generating forecasts and policy analysis.


\section{A system of equations}
\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels:a-system-of-equations}}
\sphinxAtStartPar
Macro\sphinxhyphen{}structural models are a system of equations comprised of two kinds of equations and three kinds of variables.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Identities}} are variables that are determined by a well defined accounting rule that always holds. The famous GDP Identity Y=C+I+G+(X\sphinxhyphen{}M) is one such identity, that indicates that GDP at market prices is definitionally equal to Consumption plus Investment plus Government spending plus Exports less Imports.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Behavioural}} variables are determined by equations that typically attempt to summarize an economic (vs accounting relationship). Thus the equation that says real C = f(Disposable Income,the price level, and animal spirits) is a behavioural equation – where the relationship is drawn from economic theory. Because these equations do not fully explain the variation in the dependent variable and typically estimated econometrically and are subject to error.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Exogenous}} variables are not determined by the model. Typically there are set either by assumption or from data external to the model.  For an individual country model, would often be set as an exogenous variable because the level of activity of the economy itself is unlikely to affect the world price of oil.

\end{itemize}

\sphinxAtStartPar
In a fully general form it can be written as:
\begin{align*}
y_t^1  &=  f^1(y_{t+u}^1...,y_{t+u}^n...,y_t^2...,y_{t}^n...y_{t-r}^1...,y_{t-r}^n,x_t^1...x_{t}^k,...x_{t-s}^1...,x_{t-s}^k) \\
y_t^2  &=  f^2(y_{t+u}^1...,y_{t+u}^n...,y_t^1...,y_{t}^n...y_{t-r}^1...,y_{t-r}^n,x_t^1...x_{t}^k,...x_{t-s}^1...,x_{t-s}^k) \\
\vdots \\
y_t^n  &=  f^n(y_{t+u}^1...,y_{t+u}^n...,y_t^1...,y_{t}^{n-1}...y_{t-r}^1...,y_{t-r}^n,x_t^1...x_{t}^r,x..._{t-s}^1...,x_{t-s}^k)
\end{align*}
\sphinxAtStartPar
where \( y_t^1 \) is one of n endogenous variables and \(x_t^1\) is an exogenous variable and there are as many equations as there are unknown (endogenous variables).

\sphinxAtStartPar
Rewritten for our GDP identity and substituting the variable mnemonics Y,C,I,G,X,M we could write a simple model as a system of 6 equations in 6 unknowns:
\begin{align*}
Y_t  &=  C_t+I_t+G+t+ (X_t-M_t) \\
C_t &= c_t(C_{t-1},C_{t-2},I_t,G_t,X_t,M_t,P_t)\\
I_t &= c_t(I_{t-1},I_{t-2},C_t,G_t,X_t,M_t,P_t)\\
G_t &= c_t(G_{t-1},G_{t-2},C_t,I_t,X_t,M_t,P_t)\\
X_t &= c_t(X_{t-1},X_{t-2},C_t,I_t,G_t,M_t,P_t,P^f_t)\\
M_t &= c_t(M_{t-1},M_{t-2},C_t,I_t,G_t,X_t,P_t,P^f_t)
\end{align*}
\sphinxAtStartPar
and where \(P_t, P^f_t\) domestic and foreign prices respectively are exogenous in this simple model.


\section{Behavioural equations}
\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels:behavioural-equations}}
\sphinxAtStartPar
Behavioural equations in a macrostructural equation are typically estimated. In MFMod they are often expressed in Error Correction form. In this approach the behaviour of the dependent variable (say Consumption) is assumed to be the joint product of a long\sphinxhyphen{}term economic relationship – usually drawn from economic theory, and various short\sphinxhyphen{}run influences which can be more ad hoc in nature. The ECM formulation has the advantage of tieing down the long run behavior of the economy to economic theory, while allowing its short\sphinxhyphen{}run dynamics (where short\sphinxhyphen{}run can in some cases be 5 or more years) to reflect the way the economy actually operates (not how textbooks say it should behave).

\sphinxAtStartPar
For the consumption equation, utility maximization subject to a budget constraint might lead us to define a long run relationship like this economic theory might lead us to something like this:
\begin{equation*}
\begin{split} C_t = \alpha + \beta{{rK_t + WB_{t} + GTR_{t}}\over {PC_t}}-\tau(r_t-\dot{p}_t) +\eta_t\end{split}
\end{equation*}
\sphinxAtStartPar
Where in the long run consumption (\(C_t\)) for a given interest rate is a stable share of real disposable income, implying a constant savings rate.  If interest rates rise then consumption as a share of disposable income declines (the savings rate rises).

\sphinxAtStartPar
Replacing the expression following \(\beta\) with \(Y^{disp}_t\), the above simplifies and can be rewritten as:
\begin{equation*}
\begin{split} C_t= (\alpha + \beta{Y^{disp}_t}-\tau(r_t-\dot{p}_t))\end{split}
\end{equation*}
\sphinxAtStartPar
and dividing both sides by \(Y^{disp}_t\) gives:
\begin{equation*}
\begin{split}\frac{C_t}{Y^{disp}_t} = \beta -\tau\frac{r_t-\dot{p}_t}{Y^{disp}_t}\end{split}
\end{equation*}
\sphinxAtStartPar
or in logarithms
\begin{equation*}
\begin{split}{c_{t-1}}-{y^{disp}_{t-1}} - ln(\beta) +\tau ln(r_{t-1}-\dot{p}_{t-1} -{y^{disp}_{t-1}})=0\end{split}
\end{equation*}
\sphinxAtStartPar
we can then write our ECM equation as
\begin{equation*}
\begin{split} \Delta c_t = -\lambda(\eta_{t-1})+ SR_t \end{split}
\end{equation*}
\sphinxAtStartPar
Substituting the LR expression for the error term in t\sphinxhyphen{}1 we get
\begin{equation*}
\begin{split} \Delta c_t = -\lambda({c_{t-1}}-{y^{disp}_{t-1}} - ln(\beta) +\tau ln(r_{t-1}-\dot{p}_{t-1} -{y^{disp}_{t-1}}))+ \beta_{SR1}{y^{disp}_{t}} - \beta_{SR2}ln(r_{t}-\dot{p}_{t} -{y^{disp}_{t}})  \end{split}
\end{equation*}
\sphinxAtStartPar
where \(\beta_{SR1}\) is the short run elasticity of consumption to disposable income; \(\beta_{SR2}\) is the short run real interest rate elasticity of consumption and \(\lambda\) is the speed of adjustment (the rate at which past errors are corrected in each period).

\sphinxAtStartPar
{\color{red}\bfseries{}:cite:author:`burns\_world\_2019`} provides more complete derivations of the functional forms for most of the behavioural equations in MFmod.

\sphinxstepscope


\chapter{Modelflow and the MFMod models of the World Bank}
\label{\detokenize{content/02_MacrostructuralModels/MFModAndModelFlow:modelflow-and-the-mfmod-models-of-the-world-bank}}\label{\detokenize{content/02_MacrostructuralModels/MFModAndModelFlow::doc}}
\sphinxAtStartPar
At the World Bank models built using the MFMod framework are developed in \DUrole{xref,myst}{EViews} and when disseminated to clients are operated in a World Bank customized EViews environment. But as a systems of equations and associated data the models can be solved and operated under any system capable of solving a system of simultaneous equations, as long as the equations and data can be transferred from EViews to the secondary system. \sphinxcode{\sphinxupquote{Modelflow}} facilitates this process and offers a wide range of features that permit not only solving the model, but also provides a rich and powerful suite of tools for analyzing the model and reporting results.


\section{A brief history of ModelFlow}
\label{\detokenize{content/02_MacrostructuralModels/MFModAndModelFlow:a-brief-history-of-modelflow}}
\sphinxAtStartPar
Modelflow is a python library that was developed by Ib Hansen over several years while working at the Danish Central Bank and the European Central Bank. The framework has been used both to port the U.S. Federal Reserve’s macro\sphinxhyphen{}structural  model to python, but also been used to bring several stress\sphinxhyphen{}testing models developed by European Central Banks and the European Central Bank into a the python environment.

\sphinxAtStartPar
Beginning in 2019 Ib has worked with the World Bank to develop additional features that facilitate working with models built using the Bank’s MFMod Framework, with the objective of creating an open source platform through which the Bank’s models can be made available to the public.  This paper and the models that accompany are the initial product of this collaboration.

\sphinxstepscope


\part{Installation of modelflow}

\sphinxstepscope


\chapter{Installation of Modelflow}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-modelflow}}\label{\detokenize{content/03_Installation/InstallingPython::doc}}
\sphinxAtStartPar
Modelflow is a python package that defines the \sphinxcode{\sphinxupquote{model}} class, its methods and a number of other functions that extend and combine pre\sphinxhyphen{}existing python functions to allow the easy solution of complex systems of equations including macro\sphinxhyphen{}structural models like MFMod.  To tale advantage of the function, a user needs to first install python, or preferably the Anaconda variant, several supporting packages, and the \sphinxcode{\sphinxupquote{modelflow}} package.  While \sphinxcode{\sphinxupquote{modelflow}} can be run directly from the python command\sphinxhyphen{}line or IDEs (Interactive Development Environments) like Spyder or Microsoft’s Visual Code, it is suggested that users also install the Jupyter notebook system, which facilitates and interactive approach to building python programs, annotating them and ultimately doing simulations using MFMod under \sphinxcode{\sphinxupquote{modelflow}}.


\section{Installation of Python}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-python}}
\sphinxAtStartPar
Python is an extremely powerful and versatile and extensible open\sphinxhyphen{}source language. It is widely used for artificial intelligence application, interactive web sites, and scientific processing. As of 14 November 2022, the Python Package Index (PyPI), the official repository for third\sphinxhyphen{}party Python software, contained over 415,000 packages that extend its functionality (1). Modelflow is one of these packages.

\sphinxAtStartPar
Python comes in many flavors and \sphinxcode{\sphinxupquote{modelflow}} will work with any of them.  However, it is strongly suggested that you use the Anaconda version of Python.  The remainder of this section points to instructions on how to install the Anaconda version of python (under Windows, MacOS and under Linux). Modelflow works equally well under all three.

\sphinxAtStartPar
The following section describes the steps necessary to create an anaconda environment with all the necessary packages to run \sphinxcode{\sphinxupquote{modelflow}}.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
\sphinxhref{https://en.wikipedia.org/wiki/Python\_(programming\_language)}{Wikipedia article on python}.

\end{enumerate}


\subsection{Installation of Anaconda under Windows}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-anaconda-under-windows}}
\sphinxAtStartPar
The definitive source for installing Anaconda under windows can be found \sphinxhref{https://docs.anaconda.com/anaconda/install/windows/}{here}.

\sphinxAtStartPar
\sphinxstylestrong{It is strongly advised that Anaconda be installed for a single user (Just Me)}  This is much easier to maintain over time.  Installing “For all users on this computer” will substabitally increase the complexity of maintaining python on your computer.


\subsection{Installation of Python under macOS}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-python-under-macos}}
\sphinxAtStartPar
The definitive source for installing Anaconda under macOS can be found \sphinxhref{https://docs.anaconda.com/anaconda/install/mac-os/}{here}.


\subsection{Installation of Python under Linux}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-python-under-linux}}
\sphinxAtStartPar
The definitive source for installing Anaconda under Linux can be found \sphinxhref{https://docs.anaconda.com/anaconda/install/linux/}{here}.

\sphinxAtStartPar
Once Anaconda is fully installed, you can then go to the installation of modelflow instructions.

\sphinxstepscope


\chapter{Installation of Modelflow}
\label{\detokenize{content/03_Installation/InstallingModelFlow:installation-of-modelflow}}\label{\detokenize{content/03_Installation/InstallingModelFlow::doc}}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The following instructions concern the installation of \sphinxcode{\sphinxupquote{modelflow}} within an Anaconda installation of python.  Different flavors of Python may require slight changes to this recipe, but are not covered here.
\end{sphinxadmonition}

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} is built and tested using the anaconda python environment.  It is strongly recommended to use Anaconda with ````modelflow```.

\sphinxAtStartPar
If you have not already installed Anaconda following the instructions in the preceding chapter, please do so \sphinxstylestrong{Now}.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} is a python package that defines the modelflow class \sphinxcode{\sphinxupquote{model}} among other things.  \sphinxcode{\sphinxupquote{Modelflow1}} has many dependencies. Installing the class the first time can take some time depending on your internet connection and computer speed.  It is essential that you follow all of the steps outlined below to ensure that your version of \sphinxcode{\sphinxupquote{modelflow}} operates as expected.


\section{Installation of \sphinxstyleliteralintitle{\sphinxupquote{modelflow}} under Anaconda}
\label{\detokenize{content/03_Installation/InstallingModelFlow:installation-of-modelflow-under-anaconda}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Open the anaconda command prompt

\item {} 
\sphinxAtStartPar
Execute the following commands by copying and pasting them – either line by line or as a single mult\sphinxhyphen{}line step

\item {} 
\sphinxAtStartPar
Press enter

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{ModelFlow} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{ibh} \PYG{o}{\PYGZhy{}}\PYG{n}{c}  \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{n}{modelflow\PYGZus{}pinned\PYGZus{}developement\PYGZus{}test} \PYG{o}{\PYGZhy{}}\PYG{n}{y}
\PYG{n}{conda} \PYG{n}{activate} \PYG{n}{ModelFlow}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{dash\PYGZus{}interactive\PYGZus{}graphviz}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{pyeviews} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{o}{\PYGZhy{}}\PYG{n}{y}
\PYG{n}{jupyter} \PYG{n}{contrib} \PYG{n}{nbextension} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user}
\PYG{n}{jupyter} \PYG{n}{nbextension} \PYG{n}{enable} \PYG{n}{hide\PYGZus{}input\PYGZus{}all}\PYG{o}{/}\PYG{n}{main}
\PYG{n}{jupyter} \PYG{n}{nbextension} \PYG{n}{enable} \PYG{n}{splitcell}\PYG{o}{/}\PYG{n}{splitcellcd}
\PYG{n}{jupyter} \PYG{n}{nbextension} \PYG{n}{enable} \PYG{n}{toc2}\PYG{o}{/}\PYG{n}{main}

\end{sphinxVerbatim}

\sphinxAtStartPar
Depending on the speed of your computer and of your internet connection installation could take as little as 10 minutes or more than 1/2 of an hour.

\sphinxAtStartPar
At the end of the process you will have a new conda environment ModelFlow, and this will have been activated.

\sphinxAtStartPar
Once modelflow is installed you are ready to work with it.  The following sections give a brief introduction to Jupyter notebook, which is a flexible tool that allows us to execute python code, interact with the modelflow class and World Bank Models and annotate what we have done for future replication.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
NB: The next time you want to work with modelflow, you will need to activate the \sphinxcode{\sphinxupquote{modelflow}} environment by
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Opening the Anaconda command prompt window

\item {} 
\sphinxAtStartPar
Activate the ModelFlow environment we just created by executing the folling command

\end{enumerate}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{conda activate modelflow}}
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
If you are already familiar with python and jupyter notebooks you can probably skip to chapter {[}xx{]}.
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Testing your installation of modelflow}
\label{\detokenize{content/03_Installation/TestingModelFlow:testing-your-installation-of-modelflow}}\label{\detokenize{content/03_Installation/TestingModelFlow::doc}}
\sphinxAtStartPar
To test that the installation of modelflow has worked properly, we will build a model using the modelflow framework and then simulate it.  A simple model that illustrates many of the functions of modelflow is the Solow growth model.

\sphinxAtStartPar
The code below first sets up the python environment by importing the modelflow  and pandas classes.  The initial two lines of code and the final two lines just set up the environment for optimal display and are not required.

\sphinxAtStartPar
To test the installation on your system you can copy this code into a Jupyter notebook and execute it.


\section{Specifying the model}
\label{\detokenize{content/03_Installation/TestingModelFlow:specifying-the-model}}
\sphinxAtStartPar
Having loaded the model class from the modelflow library, we can start constructing the model.

\sphinxAtStartPar
The first step is to define the equations of the model, using \sphinxcode{\sphinxupquote{modelflow}}’s Business Logic Language.

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{\sphinxstylestrong{Business Logic Language}}

\sphinxAtStartPar
More on how to specify models \DUrole{xref,myst}{here}
\end{sphinxShadowBox}

\sphinxAtStartPar
The below code segment defines a string fsolow that contains the equations for the solow model, where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
GDP is defined as a simple Cobb\sphinxhyphen{}Douglas production function as the product of TFP, Capital (raised to the share of capital in total income) and Labour (raised to the share of labor in total income)

\item {} 
\sphinxAtStartPar
Investment is equal to GDP less consumption

\item {} 
\sphinxAtStartPar
The change in capital is equal to investment this period less the depreciation of the capital stock from the previous period

\item {} 
\sphinxAtStartPar
Labor grows at the rate of growth of the variable \sphinxcode{\sphinxupquote{Labor\_growth}}

\item {} 
\sphinxAtStartPar
a pure reporting identity Capital\_intensity the ratio of the Capital Stock to the Labor input

\end{itemize}

\sphinxAtStartPar
We thus have a system of 6 equations with 6 unknowns (GDP, Consumption, Investment, Change in the Capital stock, and change in Labor supply, and the capital\_intensity) and exogenous variables (TFP, alfa,savings\_rate,Depreciation\_rate and Labor\_growth).

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The equations for Labor and Capital have been entered as difference equations. The \sphinxcode{\sphinxupquote{modelflow}} object will automatically normalize them, generating an internal representation of \sphinxcode{\sphinxupquote{Labour=Labour(t\sphinxhyphen{}1)*(1+Labor\_growth)}} and \sphinxcode{\sphinxupquote{Capital=Capital(t\sphinxhyphen{}1)*(1\sphinxhyphen{}Depreciation\_rate)+Investment}}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fsolow} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{GDP          = TFP  * Capital**alfa * Labor **(1\PYGZhy{}alfa) }
\PYG{l+s+s1}{Consumption     = (1\PYGZhy{}saving\PYGZus{}rate)  * GDP }
\PYG{l+s+s1}{Investment      = GDP \PYGZhy{} Consumption   }
\PYG{l+s+s1}{diff(Capital)   = Investment\PYGZhy{}Depreciation\PYGZus{}rate * Capital(\PYGZhy{}1)}
\PYG{l+s+s1}{diff(Labor)     = Labor\PYGZus{}growth * Labor(\PYGZhy{}1)  }
\PYG{l+s+s1}{Capital\PYGZus{}intensity = Capital/Labor }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
To create the model we instantiate (create) a variable \sphinxcode{\sphinxupquote{msolow}} (which will ultimately contain both the equations and data for the model) using the \sphinxcode{\sphinxupquote{.from\_eq()}} method of the \sphinxcode{\sphinxupquote{modelflow}} class – submitting to it the equations in string form, and giving it the name “Solow model”.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{from\PYGZus{}eq}\PYG{p}{(}\PYG{n}{fsolow}\PYG{p}{,}\PYG{n}{modelname}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Solow model}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The internal representation of the normalized equations can be displayed in normalized business language with the \sphinxcode{\sphinxupquote{modelflow}} method \sphinxcode{\sphinxupquote{.print\_model}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{o}{.}\PYG{n}{print\PYGZus{}model}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
FRML \PYGZlt{}\PYGZgt{} GDP          = TFP  * CAPITAL**ALFA * LABOR **(1\PYGZhy{}ALFA)  \PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} CONSUMPTION     = (1\PYGZhy{}SAVING\PYGZus{}RATE)  * GDP  \PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} INVESTMENT      = GDP \PYGZhy{} CONSUMPTION    \PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} CAPITAL=CAPITAL(\PYGZhy{}1)+(INVESTMENT\PYGZhy{}DEPRECIATION\PYGZus{}RATE * CAPITAL(\PYGZhy{}1))\PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} LABOR=LABOR(\PYGZhy{}1)+(LABOR\PYGZus{}GROWTH * LABOR(\PYGZhy{}1))\PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} CAPITAL\PYGZus{}INTENSITY = CAPITAL/LABOR  \PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Create some data}
\label{\detokenize{content/03_Installation/TestingModelFlow:create-some-data}}
\sphinxAtStartPar
For the moment \sphinxcode{\sphinxupquote{msolow}} has a mathematical representation of a system of equations but no data.

\sphinxAtStartPar
To add data we  create a pandas dataframe with initial values for our exogenous variables. Technically capital and labor are endogenous in the Solow model, but because they are specified as change equations their initial values are exogenous and need to be initialized.

\sphinxAtStartPar
The code below  instantiates (creates) a panda dataframe \sphinxcode{\sphinxupquote{df}} and fills it with the variables for our model, initializing these with a series of values over 300 datapoints.  The final command displays the first ten rows of the dataframe.

\begin{sphinxadmonition}{note}{Note:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Pandas data frames is a foundational class of python.  There are thousands of web sites dedicated to understanding pandas.  Some notable ones include:
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{300}  
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LABOR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,}
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CAPITAL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ALFA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TFP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DEPRECIATION\PYGZus{}RATE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LABOR\PYGZus{}GROWTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SAVING\PYGZus{}RATE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2000}\PYG{p}{,}\PYG{l+m+mi}{2300}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}this prints out the first 5 rows of the dataframe}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      LABOR  CAPITAL  ALFA  TFP  DEPRECIATION\PYGZus{}RATE  LABOR\PYGZus{}GROWTH  SAVING\PYGZus{}RATE
2000    100      100   0.5    1               0.05          0.01         0.05
2001    100      100   0.5    1               0.05          0.01         0.05
2002    100      100   0.5    1               0.05          0.01         0.05
2003    100      100   0.5    1               0.05          0.01         0.05
2004    100      100   0.5    1               0.05          0.01         0.05
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Putting it together}
\label{\detokenize{content/03_Installation/TestingModelFlow:putting-it-together}}
\sphinxAtStartPar
Having defined an initial data set for all the exogenous variables, we can combine these with the equations and solve the model.

\sphinxAtStartPar
The command below solves the model \sphinxcode{\sphinxupquote{msolow}} on the data contained in the dataframe \sphinxcode{\sphinxupquote{df}} and stores the output in a new dataframe called \sphinxcode{\sphinxupquote{result}}.

\sphinxAtStartPar
The last line displays the values of the simulated model, which now includes results for the endogenous variables, and different values for the Labor and Capital variables reflecting their endogeneity for periods 2 through 300.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result} \PYG{o}{=} \PYG{n}{msolow}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} The model is simulated for all years possible }

\PYG{n}{result}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           LABOR     CAPITAL  ALFA  TFP  DEPRECIATION\PYGZus{}RATE  LABOR\PYGZus{}GROWTH  \PYGZbs{}
2000  100.000000  100.000000   0.5  1.0               0.05          0.01   
2001  101.000000  100.025580   0.5  1.0               0.05          0.01   
2002  102.010000  100.076226   0.5  1.0               0.05          0.01   
2003  103.030100  100.151443   0.5  1.0               0.05          0.01   
2004  104.060401  100.250762   0.5  1.0               0.05          0.01   
2005  105.101005  100.373733   0.5  1.0               0.05          0.01   
2006  106.152015  100.519926   0.5  1.0               0.05          0.01   
2007  107.213535  100.688931   0.5  1.0               0.05          0.01   
2008  108.285671  100.880357   0.5  1.0               0.05          0.01   
2009  109.368527  101.093830   0.5  1.0               0.05          0.01   

      SAVING\PYGZus{}RATE  CAPITAL\PYGZus{}INTENSITY         GDP  CONSUMPTION  INVESTMENT  
2000         0.05           0.000000    0.000000     0.000000    0.000000  
2001         0.05           0.990352  100.511609    95.486029    5.025580  
2002         0.05           0.981043  101.038487    95.986562    5.051924  
2003         0.05           0.972060  101.580575    96.501546    5.079029  
2004         0.05           0.963390  102.137821    97.030930    5.106891  
2005         0.05           0.955022  102.710176    97.574667    5.135509  
2006         0.05           0.946943  103.297593    98.132713    5.164880  
2007         0.05           0.939144  103.900030    98.705029    5.195002  
2008         0.05           0.931613  104.517449    99.291576    5.225872  
2009         0.05           0.924341  105.149813    99.892323    5.257491  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Create a scenario and run again}
\label{\detokenize{content/03_Installation/TestingModelFlow:create-a-scenario-and-run-again}}
\begin{sphinxShadowBox}
\sphinxstylesidebartitle{\sphinxstylestrong{dataframe.upd}}

\sphinxAtStartPar
When importing modelclass all pandas dataframes are enriched with a a handy way to create a new pandas dataframe as a copy of an existing one but with one or more series updated.

\sphinxAtStartPar
In this case df.upd will create a a new dataframe \sphinxcode{\sphinxupquote{dfscenaario}} with updated LABOR\_GROWTH

\sphinxAtStartPar
For more detail on the \sphinxcode{\sphinxupquote{.upd}} method look here \DUrole{xref,myst}{here}
\end{sphinxShadowBox}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dfscenario} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}2023 2200\PYGZgt{} LABOR\PYGZus{}GROWTH = LABOR\PYGZus{}GROWTH + 0.002}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a new dataframe, increase LABOR\PYGZus{}GROWTH by 0.002}
\PYG{n}{scenario}   \PYG{o}{=} \PYG{n}{msolow}\PYG{p}{(}\PYG{n}{dfscenario}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Higher labor growth }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulate the model }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Inspect results}
\label{\detokenize{content/03_Installation/TestingModelFlow:inspect-results}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} includes a range of methods to view data and results, either as graphs or as tables.  Some of these are part of standard python, others are additional features that \sphinxcode{\sphinxupquote{modelflow}} makes available.

\sphinxAtStartPar
Scenario results can be inspected either by referring to the scenario name given in the (optional) \sphinxcode{\sphinxupquote{keep}} statement when the model was solved, by referring to the \sphinxcode{\sphinxupquote{basedf}} and the \sphinxcode{\sphinxupquote{lastdf}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{basedf}} is a dataframe that is automatically generated when the model is solved and contains a copy of the initial conditions of the model prior to the shock.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lastdf}}is a dataframe that is automatically generated when the model is solved and contains a copy of the results from the simulation. Several built in display functions use these functions to display results.

\end{itemize}

\sphinxAtStartPar
Finally one could also look at the dataframe to which the results of the simulation were assigned \sphinxcode{\sphinxupquote{scenario}} in the example above.

\sphinxAtStartPar
Below is a small sub\sphinxhyphen{}set of the visualization options available.


\subsection{Graphical representations of results}
\label{\detokenize{content/03_Installation/TestingModelFlow:graphical-representations-of-results}}

\subsubsection{The .dif.plot() method}
\label{\detokenize{content/03_Installation/TestingModelFlow:the-dif-plot-method}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif.plot}} method will plot the change in the level of requested variables.  Requested variables can be selected either directly by name or using wildcards.

\sphinxAtStartPar
In this example, a wild card specification is used, requesting the display of all variables that begin with the text ‘labor’.  Note that the selector is not case sensitive.

\sphinxAtStartPar
In this case we are displaying changes into the labor and labor growth variables due to the shock when we increased the growth rate of labor by .0002

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labor*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{TestingModelFlow_19_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this example, instead of using a wild card selector we requested a variable explicitly by name.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP LABOR\PYGZus{}GROWTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pct}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{TestingModelFlow_21_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Using the kept solutions}
\label{\detokenize{content/03_Installation/TestingModelFlow:using-the-kept-solutions}}
\sphinxAtStartPar
Because the keyword \sphinxcode{\sphinxupquote{keep}} was used when running the simulations, we can refer to the scenarios by their names – or produce graphs from multiple scenarios – not just the first and last.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{o}{.}\PYG{n}{keep\PYGZus{}plot}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}GDP\PYGZsq{}: \PYGZlt{}Figure size 720x432 with 1 Axes\PYGZgt{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Textual and tabular display of results}
\label{\detokenize{content/03_Installation/TestingModelFlow:textual-and-tabular-display-of-results}}
\sphinxAtStartPar
Standard pandas syntax can be used to display data in the results dataframes.

\sphinxAtStartPar
Here we use the standard pandas \sphinxcode{\sphinxupquote{.loc}} method to display every 10th data point for consumption from the results dataframe, beginning from observation 50 through 100.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{:}\PYG{l+m+mi}{100}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Series([], Name: CONSUMPTION, dtype: float64)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{The \sphinxstyleliteralintitle{\sphinxupquote{.dif.df}} method}
\label{\detokenize{content/03_Installation/TestingModelFlow:the-dif-df-method}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif.df}} method prints out the changes in variables, i.e. eh difference between the level of specified  variables in the \sphinxcode{\sphinxupquote{lastdf}} dataframe vs the \sphinxcode{\sphinxupquote{basedf}} dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
             GDP  CONSUMPTION
2001    0.000000     0.000000
2002    0.000000     0.000000
2003    0.000000     0.000000
2004    0.000000     0.000000
2005    0.000000     0.000000
...          ...          ...
2295  665.334581   632.067852
2296  672.097592   638.492713
2297  678.925939   644.979642
2298  685.820324   651.529308
2299  692.781453   658.142380

[299 rows x 2 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{The \sphinxstyleliteralintitle{\sphinxupquote{.difpct.df}} method}
\label{\detokenize{content/03_Installation/TestingModelFlow:the-difpct-df-method}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif.pct.df}} method express the changes between the last simulation and base simulation results as a percent differences in the level (\({\Delta X_t \over X^{basedf}_{t-1}} \) ).  In the example below the mul100 method multiplies the result by 100.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           GDP  CONSUMPTION
2001       NaN          NaN
2002  0.000000     0.000000
2003  0.000000     0.000000
2004  0.000000     0.000000
2005  0.000000     0.000000
...        ...          ...
2295  0.005047     0.005047
2296  0.004892     0.004892
2297  0.004742     0.004742
2298  0.004596     0.004596
2299  0.004456     0.004456

[299 rows x 2 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Interactive display of impacts}
\label{\detokenize{content/03_Installation/TestingModelFlow:interactive-display-of-impacts}}
\sphinxAtStartPar
When working within Jupyter notebook the dif command will produce (without the .df termination) will generate a widget with the results expressed as level differences, percent differences, differences in the growth rate – both graphically and in table form.

\sphinxAtStartPar
Please consult \DUrole{xref,myst}{here} for a fuller presentation of the display routines built into \sphinxcode{\sphinxupquote{modelflfow}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tab(children=(Tab(children=(HTML(value=\PYGZsq{}\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}utf\PYGZhy{}8\PYGZdq{} standalone=\PYGZdq{}no\PYGZdq{}?\PYGZgt{}\PYGZbs{}n\PYGZlt{}!DOCTYPE svg …
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Some Jupyter, Python and pandas essentials}

\sphinxstepscope


\chapter{Introduction to  Jupyter Notebook}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:introduction-to-jupyter-notebook}}\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook::doc}}
\sphinxAtStartPar
Jupyter Notebook is a web application for creating, annotating, experimenting and working with computational documents.  Originally developed for python, the latest versions of EViews also support jupyter Notebooks. Junpyter Notebook (JN) offers a simple, streamlined, document\sphinxhyphen{}centric experience and can be a great environment for documenting the work you are doing, and trying alternative methods of achieving desirable results.  Many of the methods in \sphinxcode{\sphinxupquote{modelflow}} have been developed to work well with Jupyter notebook and indeed this documentation was written as a series of Jupyter Notebooks bound together with Jupyter Book.

\sphinxAtStartPar
Jupyter Notebook is not the only way to work with modelflow or Python.  Indeed, as users become more advanced they are likely to migrate to a more program\sphinxhyphen{}centric IDE (Interactive Development Environment) like Spyder or Microsoft Visual Code.

\sphinxAtStartPar
However, to start Jupyter Notebooks are a great way to learn, follow work done by others and tweak them to fit your own needs.

\sphinxAtStartPar
There are many fine tutorials on Jupyter Notebook on the web, and \sphinxhref{https://docs.jupyter.org/en/latest/}{The official Jupyter site} is a good starting point. The following aims to provide enough information to get a user started.


\section{The idea of the notebook}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:the-idea-of-the-notebook}}
\sphinxAtStartPar
The idea behind jupyter notebook {[}JN{]} was to create an interactive version of the notebooks that scientists use(d) to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
record what they have done

\item {} 
\sphinxAtStartPar
perhaps explain why

\item {} 
\sphinxAtStartPar
document how data was generated, and

\item {} 
\sphinxAtStartPar
record the results of their experiments

\end{itemize}

\sphinxAtStartPar
The motivation for these notebooks and Jupyter notebook is to encourage practices that will ensure that if followed exactly by others, that they will be able to generate the same results.


\section{Jupter Notebook cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:jupter-notebook-cells}}
\sphinxAtStartPar
A JN does all of that (and perhaps a bit more).  It is divided into ‘cells’.

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{JN Cells can contain:}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{computer code} (typically python code, but as noted other kernels – like Eviews – can be used with jupyter).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{markdown text}: plain text that can include special characters that make some text appear as bold, or indicate the text is headers, or instruct JN to render the text as a mathematical formula.  All of the text in this document was entered using JN’s markdown language

\item {} 
\sphinxAtStartPar
Results (in the form of tables or graphs) from the execution of computer code specified in a code cell

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Every cell has two modes:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Edit mode – indicated by a green vertical bar. In edit mode the user can change the code, or the markdown.

\item {} 
\sphinxAtStartPar
Select/Copy mode – indicated by a blue vertical bar.  This will be teh state of the cell when its content has been executed.  For markdown cells this means that the text and special characters have been rendered into formatted text.  For code cells, this means the code has been executed and its output (if any) displayed in an output cell.

\end{enumerate}

\sphinxAtStartPar
The notebook has associated with it a “Kernel”, which is an instance of the computing environment in which code will be executed. For JN taht work with modelflow this will be a Python Kernel.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Jupyter Notebooks were designed to facilitate \sphinxstyleemphasis{replicability}: the idea that a scientific analysis should contain \sphinxhyphen{} in addition to the final output (text, graphs, tables) \sphinxhyphen{} all the computational steps needed to get from raw input data to the results.
\end{sphinxadmonition}


\section{Execution of cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:execution-of-cells}}
\sphinxAtStartPar
Every cell in a JN can be executed, either by using the Run button on the JN menu, or by using one of \sphinxstylestrong{two keyboard shortcuts}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ctrl + Enter}: Executes the code in the cell or formats the markdown of a cell.  The current cell retains the focus – cursor stays on cell executed.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{shift + enter}: Executes the code in the cell or formats the markdown of a cell. Focus (cursor) jump to the next cell

\end{itemize}

\sphinxAtStartPar
Useful shortcuts: (see also “Help” => “Keyboard Shortcuts” or simply press keyboard icon in the toolbar)


\subsection{Execution of code cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:execution-of-code-cells}}
\sphinxAtStartPar
Below is a code with some standard python that declares a variable “x” and assigns it the value 10, and declares a second variable “y” and assigns it the value 45.  The final line of y alone, instructs python to display the value of the variable y.  The results of the operation appear in the KN in an output cell.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{n}{y}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
45
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{the semi\sphinxhyphen{}colon “;” supresses output in JN}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:the-semi-colon-supresses-output-in-jn}}
\sphinxAtStartPar
In the example below, a semi\sphinxhyphen{}colon “;” has been appended to the final line.  This supresses the display of the value contained by y;  As a result there is no output cell.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{n}{y}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Another way to display results is to use the print function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Variables in a JN session are persistent, as a result in the subsequent cell, we can declare a variable ‘z’ equal to 2*y and it will have the value 90.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z}\PYG{o}{=}\PYG{n}{y}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{z}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
90
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Auto\sphinxhyphen{}complete and context\sphinxhyphen{}sensitive help}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:auto-complete-and-context-sensitive-help}}
\sphinxAtStartPar
When editing a code cell, you can use these short\sphinxhyphen{}cuts to autocomplete and or call up documentation for a command.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{tab}: autocomplete and  method selection

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{double tab}: documention (double tab for full doc)

\end{itemize}


\section{The markdown scripting language in JN}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:the-markdown-scripting-language-in-jn}}
\sphinxAtStartPar
Markdown is a lightweight markup language for creating formatted text using a plain\sphinxhyphen{}text editor.  Used in a markdown cell of RN it can be used to produce nicely formatted text that mixes text, code and outputs from executed python code.

\sphinxAtStartPar
Rather than the relatively complex commands of html <h1></h1>, markdown uses a simplified set of commands to control how text elements should be rendered.


\subsection{Common markdown commands}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:common-markdown-commands}}
\sphinxAtStartPar
Some of the most common of these include:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
symbol
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Effect
\\
\hline
\sphinxAtStartPar
\#
&
\sphinxAtStartPar
Header
\\
\hline
\sphinxAtStartPar
\#\#
&
\sphinxAtStartPar
second level
\\
\hline
\sphinxAtStartPar
**Bold text**
&
\sphinxAtStartPar
\sphinxstylestrong{Bold text}
\\
\hline
\sphinxAtStartPar
*Italics text*
&
\sphinxAtStartPar
\sphinxstyleemphasis{Italics text}
\\
\hline
\sphinxAtStartPar
* text
&
\sphinxAtStartPar
Bulleted text or dot notes
\\
\hline
\sphinxAtStartPar
1. text
&
\sphinxAtStartPar
1. Numbered bullets
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Tables in markdown}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:tables-in-markdown}}
\sphinxAtStartPar
Tables like the one above can be constructed using | as separators.  To display a (an unexecutable)  block of code within a markdown cell it can be commented by encapsulating it in  three ` at the beginning and end ``` text to be rendered as code ```.

\sphinxAtStartPar
Below is the markdown code that generated the above table:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{|} \PYG{n}{symbol}           \PYG{o}{|} \PYG{n}{Effect}          \PYG{o}{|}
\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}
\PYG{o}{|} \PYGZbs{}\PYG{c+c1}{\PYGZsh{}               | Header        |}
\PYG{o}{|} \PYGZbs{}\PYG{c+c1}{\PYGZsh{}\PYGZbs{}\PYGZsh{}             | second level |}
\PYG{o}{|} \PYGZbs{}\PYG{o}{*}\PYGZbs{}\PYG{o}{*}\PYG{n}{Bold} \PYG{n}{text}\PYGZbs{}\PYG{o}{*}\PYGZbs{}\PYG{o}{*} \PYG{o}{|} \PYG{o}{*}\PYG{o}{*}\PYG{n}{Bold} \PYG{n}{text}\PYG{o}{*}\PYG{o}{*}   \PYG{o}{|}
\PYG{o}{|} \PYGZbs{}\PYG{o}{*}\PYG{n}{Italics} \PYG{n}{text}\PYGZbs{}\PYG{o}{*} \PYG{o}{|} \PYG{o}{*}\PYG{n}{Italics} \PYG{n}{text}\PYG{o}{*}   \PYG{o}{|}
\PYG{o}{|} 
\PYG{o}{|} \PYG{l+m+mi}{1}\PYGZbs{}\PYG{o}{.} \PYG{n}{text}  \PYG{o}{|} \PYG{l+m+mf}{1.} \PYG{n}{Numbered} \PYG{n}{bullets}   \PYG{o}{|}

\end{sphinxVerbatim}


\subsection{links to mire info on markdown}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:links-to-mire-info-on-markdown}}
\sphinxAtStartPar
There are several very good markdown cheatsheets on the internet, one of these is \sphinxhref{https://www.markdownguide.org/cheat-sheet/}{here}


\section{Rendering mathematics in markdown}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:rendering-mathematics-in-markdown}}
\sphinxAtStartPar
JN Markdown mode supports LaTeX mathematical notation.

\sphinxAtStartPar
Inline enclose the latex in \sphinxcode{\sphinxupquote{\$}}:

\sphinxAtStartPar
An Equation: \sphinxcode{\sphinxupquote{\$y\_t = \textbackslash{}beta\_0 + \textbackslash{}beta\_1 x\_t + u\_t\textbackslash{}\$}} will renders as: \(y_t = \beta_0 + \beta_1 x_t + u_t\)

\sphinxAtStartPar
if enclosed in \sphinxcode{\sphinxupquote{\$\$}} \sphinxcode{\sphinxupquote{\$\$}} it will be centered on its on line.
\begin{equation*}
\begin{split}y_t = \beta_0 + \beta_1 x_t + u_t\end{split}
\end{equation*}
\sphinxAtStartPar
If you want the math to stand alone (not be in\sphinxhyphen{}line, then use two \sphinxcode{\sphinxupquote{\$}} signs)

\sphinxAtStartPar
The below block renders as below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{align}\PYG{o}{*}\PYG{p}{\PYGZcb{}}
\PYG{n}{Y\PYGZus{}t}  \PYG{o}{\PYGZam{}}\PYG{o}{=}  \PYG{n}{C\PYGZus{}t}\PYG{o}{+}\PYG{n}{I\PYGZus{}t}\PYG{o}{+}\PYG{n}{G}\PYG{o}{+}\PYG{n}{t}\PYG{o}{+} \PYG{p}{(}\PYG{n}{X\PYGZus{}t}\PYG{o}{\PYGZhy{}}\PYG{n}{M\PYGZus{}t}\PYG{p}{)} \PYGZbs{}\PYGZbs{}
\PYG{n}{C\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{C\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{I\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{I\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{I\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{G\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{G\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{G\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{X\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{X\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{X\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{,}\PYG{n}{P}\PYG{o}{\PYGZca{}}\PYG{n}{f\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{M\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{M\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{M\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{,}\PYG{n}{P}\PYG{o}{\PYGZca{}}\PYG{n}{f\PYGZus{}t}\PYG{p}{)}
\PYGZbs{}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{align}\PYG{o}{*}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{align*}
Y_t  &=  C_t+I_t+G+t+ (X_t-M_t) \\
C_t &= c_t(C_{t-1},C_{t-2},I_t,G_t,X_t,M_t,P_t)\\
I_t &= c_t(I_{t-1},I_{t-2},C_t,G_t,X_t,M_t,P_t)\\
G_t &= c_t(G_{t-1},G_{t-2},C_t,I_t,X_t,M_t,P_t)\\
X_t &= c_t(X_{t-1},X_{t-2},C_t,I_t,G_t,M_t,P_t,P^f_t)\\
M_t &= c_t(M_{t-1},M_{t-2},C_t,I_t,G_t,X_t,P_t,P^f_t)
\end{align*}

\section{How to add, delete and move cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:how-to-add-delete-and-move-cells}}
\sphinxAtStartPar
JN cells can be added, deleted and moved.

\sphinxAtStartPar
\sphinxstylestrong{Using the Toolbar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{+ button}: add a cell below the current cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scissors}: cut  current cell (can be undone from “Edit” tab)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{clipboard}: paste a previously cut cell to the current location

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{up\sphinxhyphen{} and down arrows}: move cells

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hold shift + click cells in left margin}: select multiple cells (vertical bar must be blue)

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Using keyboard short cuts}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + a}: add a cell above the current cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + b}: add a cell below the current cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + d+d}: delete the current cell

\end{itemize}


\section{Change the type of a cell}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:change-the-type-of-a-cell}}
\sphinxAtStartPar
You can also change the type of a cell. New cells are by default “code” cells.

\sphinxAtStartPar
\sphinxstylestrong{Using the Toolbar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Select the desired type from the drop down.  options include
\begin{itemize}
\item {} 
\sphinxAtStartPar
Markdown

\item {} 
\sphinxAtStartPar
Code

\item {} 
\sphinxAtStartPar
Raw NBConvert

\item {} 
\sphinxAtStartPar
Heading

\end{itemize}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Using keyboard short cuts}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + m}: make the current cell a markdown cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + y}: make the current cell a code  cell

\end{itemize}

\sphinxstepscope


\chapter{Some Python basics}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:some-python-basics}}\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc::doc}}
\sphinxAtStartPar
Before using \sphinxcode{\sphinxupquote{modelflow}} with the World Bank’s MFMod models, users  will have to understand at least some basic elements of python syntax and usage.  Notably they will need to understand about packages, libraries and classes, how to access them.


\section{Python  packages, libraries and classes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:python-packages-libraries-and-classes}}
\sphinxAtStartPar
Some features of python are built\sphinxhyphen{}in out of the box.  Others build up on these basic features.

\sphinxAtStartPar
A \sphinxstylestrong{python class} is a code template that defines an python object. Classes can have member variables (data) associated with them and methods (behaviours or functions)associated with them. In python a class is created by the keyword class. An object of type class is created (instantiated) using the classes “constructor”.

\sphinxAtStartPar
A \sphinxstylestrong{module} is a Python object consisting of Python code. A module can define functions, classes and variables. A module can also include runnable code.

\sphinxAtStartPar
A \sphinxstylestrong{python package} is a collection of modules that are related to each other. When a module from an external package is required in a program, that package (or module in the package) must  be \sphinxstylestrong{imported} into the current session for its modules can be put to use.

\sphinxAtStartPar
A \sphinxstylestrong{python library} is a collection of related modules or packages.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In modelflow the model is a class and we can create an instance of a model (an object filled with the characteristics of the class) by executing the code \sphinxcode{\sphinxupquote{mymodel = model(myformulas)}} see below for a working example.
\end{sphinxadmonition}


\section{Importing packages, libraries, modules and classes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:importing-packages-libraries-modules-and-classes}}
\sphinxAtStartPar
Some libraries, packages, modules are part of the core python package and will be available from the get go.  Others are not and need to be installed on your system and imported into your sessions.

\sphinxAtStartPar
If you followed the modelflow installation instructions you have already downloaded and installed on your computer all the packages necessary for running World Bank models under modelflow.  But to work with them in a given JN session or in a program context, you will also need to \sphinxcode{\sphinxupquote{import}} them into your session before you call them.

\sphinxAtStartPar
Typically a python program will start with the importation of the libraries, classes and modules that will be used.  Because a Jupyter Notebook is essentially a heavily annotated program, it also requires that packages used be imported.

\sphinxAtStartPar
Below some insight into the structure and content of packages and different ways to import them into a program or JN.

\sphinxAtStartPar
As described above packages, libraries and modules are containers that can include other elements.  Take for example the package Math.

\sphinxAtStartPar
To import the Math Package we execute the command \sphinxcode{\sphinxupquote{ import math}}.  Having done that we can can call the functions and data that are defined in it.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} the \PYGZdq{}\PYGZsh{}\PYGZdq{}\PYGZdq{} in a code cell indicates a comment, test after the \PYGZsh{} will not be executed}
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} Now that we have imported math we can access some of the elements identified in the package, }
\PYG{c+c1}{\PYGZsh{} For example math contains a definition for pi, we can access that by executing the pi method }
\PYG{c+c1}{\PYGZsh{} of the library math}
\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.141592653589793
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{import specific elements or classes from a module or library}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:import-specific-elements-or-classes-from-a-module-or-library}}
\sphinxAtStartPar
The python package \sphinxcode{\sphinxupquote{math}} contains several functions and classes.

\sphinxAtStartPar
If I want I can import them directly. Then when I call them I will not have to precede them with the name of their libary. to do this I use the \sphinxstylestrong{from} syntax.  \sphinxcode{\sphinxupquote{from math import pi,cos,sin}} will import the pi constant and the two functions cos and sin and allow me to call them directly.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}\PYG{p}{,}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{sin}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.141592653589793
\PYGZhy{}0.9899924966004454
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{import a class but give it an alias}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:import-a-class-but-give-it-an-alias}}
\sphinxAtStartPar
If I want I can import a class and instead of using its full name I can give it an alias, that is hopefully shorter but still obvious enough that I know in my programs what I am referring to.

\sphinxAtStartPar
For example I can say \sphinxcode{\sphinxupquote{import math as m}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k}{as} \PYG{n+nn}{m}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.141592653589793
\PYGZhy{}0.9899924966004454
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Standard aliases}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:standard-aliases}}
\sphinxAtStartPar
Some packages are so frequently used that by convention they have been “assigned” specific aliases.

\sphinxAtStartPar
For example:

\sphinxAtStartPar
the pandas class (used for data manipulation) is often aliased as pd \sphinxcode{\sphinxupquote{import pandas as pd}}
the numpy class (used for numerical analysis) is often aliased as np \sphinxcode{\sphinxupquote{import numpy as np}}

\sphinxAtStartPar
You don’t have to use those conventions but it will make your code easier to read by others who are familiar with it.


\chapter{Introduction to Pandas dataframes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:introduction-to-pandas-dataframes}}
\sphinxAtStartPar
Modelflow is built on top of the Pandas library. Pandas is the Swiss knife of data science and can perform an impressing array of date oriented tasks.

\sphinxAtStartPar
This tutorial is a very short introduction to how pandas dataframes are used with Modelflow. For a more complete discussion see any of the many tutorials on the internet, notably:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/}{Pandas homepage}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/pandas-docs/stable/getting\_started/tutorials.html}{Pandas community tutorials}

\end{itemize}


\chapter{Import the pandas library}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:import-the-pandas-library}}
\sphinxAtStartPar
Before we begin, we have to import the pandas libary.  As noted above, by  convention pandas is imported as pd

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Pandas like any libarary contains many classes and methods.  Here we are going to focus on a \sphinxstylestrong{Series} and \sphinxstylestrong{DataFrames}, each of which are very useful for time\sphinxhyphen{}series data.

\sphinxAtStartPar
Unlike other statistical packages neither \sphinxcode{\sphinxupquote{series}} nor \sphinxcode{\sphinxupquote{dataframes}} are inherently or exclusively time\sphinxhyphen{}series in nature.  In \sphinxcode{\sphinxupquote{modelflow}} and macroeconomists use them in this way, but the classes themselves are not dated in anyway out of the box.


\section{Pandas series}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:pandas-series}}
\sphinxAtStartPar
A pandas series is an object that holds a two dimensional array comprised of values and index.

\sphinxAtStartPar
The constructor for a pandas.Series is \sphinxcode{\sphinxupquote{pandas.Series()}}.  The content inside the parentheses will determine the nature of the series.  As an object\sphinxhyphen{}oriented language Python supports overrides (which is to say a method can have more than one way in which it can be called. Specifically there can be different constructors defined for a class, depending on how the data that is to be used to initialize it is organized.


\subsection{Series declared from a list}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:series-declared-from-a-list}}
\sphinxAtStartPar
The simplest way to create a Series is to pass an array of values as a Python list to the Series constructor.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A list in python is a comma delimited collection of items.  It could be text, numbers or even more complex objects.  Typically the list is enclosed in  square brackets.

\sphinxAtStartPar
mylist={[}2,7,8,9{]}
mylist2={[}“Some text”,”Some more Text”,2,3{]}
\end{sphinxadmonition}

\sphinxAtStartPar
In the examples below Simplest, Simple and simple3 are series – although series3 which is derived from a list mixing text and numeric values would be hard to interpret as an economic series.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{values}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}
\PYG{n}{weird}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Some text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Some more Text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Here the constructor is passed a numeric list}
\PYG{n}{Simplest}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Simplest}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0     2
1     3
2     4
3     5
4   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} In this case the constructor is passed a string variable that contains a list}
\PYG{n}{simple2}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}
\PYG{n}{simple2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0     2
1     3
2     4
3     5
4   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Here the constructor is passed a string containing a list that is a mix of }
\PYG{c+c1}{\PYGZsh{} alphanumerics and numerical values}
\PYG{n}{simple3}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{weird}\PYG{p}{)}
\PYG{n}{simple3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0         Some text
1    Some more Text
2                 2
3                 3
dtype: object
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Constructed in this way each of these Series are automatically assigned a zero\sphinxhyphen{}based index.


\subsection{Series declared using a specific index}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:series-declared-using-a-specific-index}}
\sphinxAtStartPar
In this example we re\sphinxhyphen{}create Simple and simple2, but this time specify a specific values for the index.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} In this example the constructor is given both the values }
\PYG{c+c1}{\PYGZsh{} and specific values for the index}
\PYG{n}{Simplest}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1966}\PYG{p}{,}\PYG{l+m+mi}{1967}\PYG{p}{,}\PYG{l+m+mi}{1996}\PYG{p}{,}\PYG{l+m+mi}{1999}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Simplest}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1966     2
1967     3
1996     4
1999     5
2000   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simple2}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{values}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1966}\PYG{p}{,}\PYG{l+m+mi}{1967}\PYG{p}{,}\PYG{l+m+mi}{1996}\PYG{p}{,}\PYG{l+m+mi}{1999}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{simple2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1966     2
1967     3
1996     4
1999     5
2000   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now the Series look more like time series data!


\subsection{Create Series from a dictionary}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:create-series-from-a-dictionary}}
\sphinxAtStartPar
In python a dictionary is a data structure that is more generally known in computer science as an associative array. A dictionary consists of a collection of key\sphinxhyphen{}value pairs, where each key\sphinxhyphen{}value pair \sphinxstyleemphasis{maps} or \sphinxstyleemphasis{links} the key to its associated value.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A dictionary is enclosed in curly brackets \{\}, versus a list which is enclosed in square brackets{[}{]}.
\end{sphinxadmonition}

\sphinxAtStartPar
Thus mydict=\{“1966”:2,”1967”:3,”1968”:4,”1969”:5,”2000”:\sphinxhyphen{}15\} creates an object called mydict.   \sphinxcode{\sphinxupquote{mydict}}maps (or links) the key “1966” to the value 2.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In this example the Key was a string but we could just as easily made it a numerical value:
\end{sphinxadmonition}

\sphinxAtStartPar
mydict2=\{1966:2,1967:3,1968:4,1969:5,2000:\sphinxhyphen{}15\} creates an object called mydict2 that links (maps) the key “1966” to the value 2.

\sphinxAtStartPar
In this way we can recreate our series simple2 by initiating it with a dictionary.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mydict2}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1966}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1967}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1968}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1969}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}
\PYG{n}{simple2}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{mydict2}\PYG{p}{)}
\PYG{n}{simple2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1966     2
1967     3
1968     4
1969     5
2000   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Properties and methods of dataframes in modelflow}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:properties-and-methods-of-dataframes-in-modelflow}}
\sphinxAtStartPar
Any class can have both properties (data) and methods (functions that operate on the data of the particular instance of the class). With object\sphinxhyphen{}oriented programming languages like python, classes can be built as supersets of existing classes. The Modelflow class \sphinxcode{\sphinxupquote{model}} inherits or encapsulates all of the features of the pandas dataframe and extends it in many important ways.  Some of the methods below are standard pandas methods, others have been added to it by \sphinxcode{\sphinxupquote{modelflow}} features

\sphinxAtStartPar
Much more detail on standard pandas dataframes can be found on the \sphinxhref{https://pandas.pydata.org/docs/reference/frame.html}{official pandas website}.


\subsection{The pandas dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:the-pandas-dataframe}}
\sphinxAtStartPar
The dataframe is the primary structure of pandas and is a two\sphinxhyphen{}dimensional data structure with named rows and columns.  Each columns can have different data types (numeric, string, etc).

\sphinxAtStartPar
By convention, a dataframe if often called df or some other modifier followed by df, to assist in reading the code.


\subsection{Creating or instantiating a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:creating-or-instantiating-a-dataframe}}
\sphinxAtStartPar
Like any object we an create a dataframe by calling the dataframe constructor of the pandas class.  Each class has many constructors, so there are very many ways to create a dataframe.

\sphinxAtStartPar
The code example below creates a dataframe of three columns A,B,C and  indexed between 2019 and 2021.  We may interpret the index as dates, but for pandas they are just numbers.  The .DataFrame() is called a constructor often takes several forms (i.e. as with series) it can be filled indifferent ways.

\sphinxAtStartPar
In the example below we create a Dataframe from a dictionary and assigning a specific index by passing a list of years as the index.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{,}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2021}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E
2018  1  1  4
2019  1  2  4
2020  1  3  4
2021  1  6  4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the dataframes that are used in macrostructural models like MFMod, each  column is a  time series for an economic variable. So in this dataframe, we would normally interpret A, B and C as economic time series.

\sphinxAtStartPar
However, \sphinxcode{\sphinxupquote{modelflow}} and pandas can also treat timeseries of matrices or vectors.
\end{sphinxadmonition}


\subsection{Adding a column to a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:adding-a-column-to-a-dataframe}}
\sphinxAtStartPar
If we assign a value to a column that does not exist, then pandas will add a column with that name and the values of the calculation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NEW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E  NEW
2018  1  1  4   10
2019  1  2  4   12
2020  1  3  4   10
2021  1  6  4   13
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Revising values}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:revising-values}}
\sphinxAtStartPar
If the column exists than the = method will revise the values of the rows with the values assigned in the statement.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The dimensions of the list assigned via the \sphinxcode{\sphinxupquote{=}} method must be the same as the dataframe (i.e. you must provide exactly as many values as there are rows.  Alternatively if you provide just one, then that value will replace all of the values in the specified column.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NEW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{14}\PYG{p}{]}

\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E  NEW
2018  1  1  4   11
2019  1  2  4   12
2020  1  3  4   10
2021  1  6  4   14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} replace all of the rows of column B with the same value}
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{17}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW
2018  17  1  4   11
2019  17  2  4   12
2020  17  3  4   10
2021  17  6  4   14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Column names in  Modelflow}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:column-names-in-modelflow}}
\begin{sphinxShadowBox}
\sphinxstylesidebartitle{Modelflow variable names}

\sphinxAtStartPar
Modelflow places more restrictions on columnnames than do pandas per se.
\end{sphinxShadowBox}

\sphinxAtStartPar
While pandas dataframes are very liberal in what names can be given to columns, \sphinxcode{\sphinxupquote{modelflow}} is more restrictive.

\sphinxAtStartPar
Specifically, in modelflow a variable name must:
\begin{itemize}
\item {} 
\sphinxAtStartPar
start with a letter

\item {} 
\sphinxAtStartPar
be upper case

\end{itemize}

\sphinxAtStartPar
Thus while all these are legal column names in pandas, some are illegal in modelflow.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Legal in modelfow?
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Reason
\\
\hline
\sphinxAtStartPar
IB
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
Starts with a letter and is uppercase
\\
\hline
\sphinxAtStartPar
ib
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
 lowercase letters are not allowed
\\
\hline
\sphinxAtStartPar
42ANSWER
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
 does not start with a letter 
\\
\hline
\sphinxAtStartPar
\_HORSE1
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
does not start with a letter 
\\
\hline
\sphinxAtStartPar
A\_VERY\_LONG\_NAME\_THAT\_IS\_LEGAL
&
\sphinxAtStartPar
Yes
&
\sphinxAtStartPar
 Starts with a letter and is uppercase 
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{.index and time dimensions in Modelflow}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:index-and-time-dimensions-in-modelflow}}
\sphinxAtStartPar
As we saw above, series have indices.  Dataframes also have indices, which are the row names of the dataframe.

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{modelflow}} we ascribe meaning to the index series as a date.

\sphinxAtStartPar
For yearly models a list of integers like in the above example works fine.

\sphinxAtStartPar
For higher frequency models the index can be one of pandas datatypes.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Be aware that not all datetypes work well with the graphics routines of modelflow.  Users are advised to use …
 Andrew comment: What are the recommended date types?
\end{sphinxadmonition}


\subsection{Leads and lags}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:leads-and-lags}}
\sphinxAtStartPar
In modelflow leads and lags can be indicated by following the variable with a parenthesis and either \sphinxhyphen{}1 or \sphinxhyphen{}2 two for one or two period lags (where the number following the negative sign indicates the number of time periods that are lagged), and positive numbers for forward leads (no +sign required).

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{modelflow}} encounters something like \sphinxcode{\sphinxupquote{A(\sphinxhyphen{}1)}}, it will take the value from the row above the current row. No matter if the index is an integer, a year, quarter or a millisecond. The same goes for leads \sphinxcode{\sphinxupquote{A(+1)}}  That will be the value in the next row.


\subsection{.columns lists the column names of a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:columns-lists-the-column-names-of-a-dataframe}}
\sphinxAtStartPar
The method \sphinxcode{\sphinxupquote{.columns}} returns the names of the columns in the dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{columns}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Index([\PYGZsq{}B\PYGZsq{}, \PYGZsq{}C\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}NEW\PYGZsq{}], dtype=\PYGZsq{}object\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.size indicates the dimension of a list}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:size-indicates-the-dimension-of-a-list}}
\sphinxAtStartPar
so \sphinxcode{\sphinxupquote{df.columns.size}} returns the number of columns in a dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The dataframe df has 4 columns.


\subsection{.eval() evaluates calculates an expression on the data of a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:eval-evaluates-calculates-an-expression-on-the-data-of-a-dataframe}}
\sphinxAtStartPar
.eval is a native dataframe method, which allows us to do calculations on a dataframe. With this method expressions can be evaluated and new columns created.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{X = B*C}
\PYG{l+s+s1}{           THE\PYGZus{}ANSWER = 42}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW    X  THE\PYGZus{}ANSWER
2018  17  1  4   11   17          42
2019  17  2  4   12   34          42
2020  17  3  4   10   51          42
2021  17  6  4   14  102          42
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW
2018  17  1  4   11
2019  17  2  4   12
2020  17  3  4   10
2021  17  6  4   14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the above example the resulting dataframe is displayed but is not stored.

\sphinxAtStartPar
To store it we must  assign the results of the calculation to a variable.  We can just overwrite the pre\sphinxhyphen{}existing dataframe by assigning it the result of the eval statement.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{X = B*C}
\PYG{l+s+s1}{           THE\PYGZus{}ANSWER = 42}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW    X  THE\PYGZus{}ANSWER
2018  17  1  4   11   17          42
2019  17  2  4   12   34          42
2020  17  3  4   10   51          42
2021  17  6  4   14  102          42
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
With this operation the new columns, x and THE\_ANSWER have been appended to the dataframe df.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.eval()}} method is a native pandas method.  As such it cannot handle lagged variables (because pandas do not support the idea of a lagged variable.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.mfcalc()}} and the \sphinxcode{\sphinxupquote{upd()}} methods discussed below are modelflow features appended to dataframe that allows such calculations to be performed.
\end{sphinxadmonition}


\subsection{.loc{[}{]} selects a portion (slice) of a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-selects-a-portion-slice-of-a-dataframe}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.loc{[}{]}}} method allows you to display and/or revise specific sub\sphinxhyphen{}sections of a column or row in a dataframe.


\subsubsection{.loc{[}row,column{]} A single element}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-row-column-a-single-element}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.loc{[}row,column{]}}} operates on a single cell in the dataframe.  Thus the below displays the value of the cell with index=2019 observation from the  column C.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}:,column{]} A single column}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-column-a-single-column}}
\sphinxAtStartPar
The lone colon in a loc statement indicates all the rows or columns.  Here all of the rows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2018    1
2019    2
2020    3
2021    6
Name: C, dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}row,:{]} A single row}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-row-a-single-row}}
\sphinxAtStartPar
Here all of the columns, for the selected row.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
B             17
C              2
E              4
NEW           12
X             34
THE\PYGZus{}ANSWER    42
Name: 2019, dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}:,{[}names…{]}{]} Several columns}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-names-several-columns}}
\sphinxAtStartPar
Passing a list in either the rows or columns portion of the loc statement will allow multiple rows or columns to be displayed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{,}\PYG{l+m+mi}{2021}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C
2018  17  1
2021  17  6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc using the colon to select a range}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-using-the-colon-to-select-a-range}}
\sphinxAtStartPar
with the colon operator we can also select a range of results.

\sphinxAtStartPar
Here from 2018 to 2019.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{:}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C
2018  17  1
2019  17  2
2020  17  3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}{]} can also be used on the left hand side to assign values to specific cells}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-can-also-be-used-on-the-left-hand-side-to-assign-values-to-specific-cells}}
\sphinxAtStartPar
This can be very handy when updating scenarios.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{:}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{17}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B   C  E  NEW    X  THE\PYGZus{}ANSWER
2018  17   1  4   11   17          42
2019  17  17  4   12   34          42
2020  17  17  4   10   51          42
2021  17   6  4   14  102          42
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The dimensions on the right hand side of = and the left hand side should match. That is: either the dimensions should be the same, or the right hand side should be \sphinxcode{\sphinxupquote{broadcasted}} into the left hand slice.
A link \sphinxhref{https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html}{here}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{For more info on the .loc{[}{]} method}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html}{Description}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=pandas+dataframe+loc\&newwindow=1}{Search}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{For more info on pandas:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/}{Pandas homepage}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/pandas-docs/stable/getting\_started/tutorials.html}{Pandas community tutorials}

\end{itemize}

\sphinxstepscope


\chapter{\sphinxstyleliteralintitle{\sphinxupquote{.mfcalc()}} an extension of standard Pandas}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-an-extension-of-standard-pandas}}\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames::doc}}

\section{.mfcalc usage}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-usage}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.mfcalc()}} method extends dataframe and the method \sphinxcode{\sphinxupquote{.upd()}}.  It can be particularly useful when creating scenarios.

\sphinxAtStartPar
But it can also be used to perform quick and dirty  calculations or even to see how modelflow would normalize an equation.


\section{workspace initialization}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:workspace-initialization}}
\sphinxAtStartPar
Setting up our python session to use pandas and modelflow by importing their packages.  \sphinxcode{\sphinxupquote{modelmf}} is an extension of dataframes that is part of the modelflow installation package (and also used by modelflow itself).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}  \PYG{c+c1}{\PYGZsh{} Python data science library}
\PYG{k+kn}{import} \PYG{n+nn}{modelmf}       \PYG{c+c1}{\PYGZsh{} Add useful features to pandas dataframes }
                     \PYG{c+c1}{\PYGZsh{} using utlities initially developed for modelflow}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Create a  simple dataframe}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:create-a-simple-dataframe}}
\sphinxAtStartPar
Create a Pandas dataframe with one column with the name A and 6 rows.

\sphinxAtStartPar
Set set the index to 2020 through 2026 and set the values of all the cells to 100.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pd.DataFrame}} creates a dataframe  \sphinxhref{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html\#pandas.DataFrame}{Description}

\item {} 
\sphinxAtStartPar
The expression \sphinxcode{\sphinxupquote{{[}v for v in range(2020,2026){]}}} dynamically creates a  python list, and fills it with  integers beginning with 2020 and ending 2025

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}                                 \PYG{c+c1}{\PYGZsh{} call the dataframe constructure }
    \PYG{l+m+mf}{100.000}\PYG{p}{,}                                           \PYG{c+c1}{\PYGZsh{} the values }
    \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2026}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}           \PYG{c+c1}{\PYGZsh{}index}
    \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}                                  \PYG{c+c1}{\PYGZsh{} the column name }
                 \PYG{p}{)}
\PYG{n}{df}   \PYG{c+c1}{\PYGZsh{} the result of the last statement is displayed in the output cell }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A
2020  100.0
2021  100.0
2022  100.0
2023  100.0
2024  100.0
2025  100.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{\sphinxstyleliteralintitle{\sphinxupquote{.mfcalc()}} in action}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-in-action}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.mfcalc()}} example to calculate a new series}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-example-to-calculate-a-new-series}}
\sphinxAtStartPar
Use  mfcalc to calculate a new column (series) as a function of the existing A column series

\sphinxAtStartPar
The below call creates a new column x.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x = x(\PYGZhy{}1) + a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  100.0  100.0
2022  100.0  200.0
2023  100.0  300.0
2024  100.0  400.0
2025  100.0  500.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{NOTE:}

\sphinxAtStartPar
By default \sphinxcode{\sphinxupquote{.mfcalc}} will initialize a new variable with zeroes.
Moreover, if a formula passed to \sphinxcode{\sphinxupquote{.mfcalc}} contains a lag a value will be calculated for the first row only if there is data in the series for the preceding row.

\sphinxAtStartPar
Combining these two behaviours generates the result where the command \sphinxcode{\sphinxupquote{df.mfcalc('x = x(\sphinxhyphen{}1) + a')}} results in a zero in 2020 for X (because there was no X variable defined for 2019 (indeed no such row exists), but then the subsequent rows add the contempraenous value of A to the preceding value of x.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the above example a  dataframe with the result is created and displayed, but the df dataframe did not change.  To have it change we would have had to assign it the result of the initial operation, as below.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A
2020  100.0
2021  100.0
2022  100.0
2023  100.0
2024  100.0
2025  100.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df2}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x = x(\PYGZhy{}1) + a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Assign the result to df2}
\PYG{n}{df2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  100.0  100.0
2022  100.0  200.0
2023  100.0  300.0
2024  100.0  400.0
2025  100.0  500.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Recalculate A so  it grows by 2 percent}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:recalculate-a-so-it-grows-by-2-percent}}
\sphinxAtStartPar
mfcalcs knows that it can not start to calculate in 2020 as there is no lagged variable. So it will start calculating in 2021 and leave the pre\sphinxhyphen{}existing value unchanged.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a =  1.02 *  a(\PYGZhy{}1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               A
2020  100.000000
2021  102.000000
2022  104.040000
2023  106.120800
2024  108.243216
2025  110.408080
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100} \PYG{c+c1}{\PYGZsh{} to display the percent changes}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A
2020  NaN
2021  2.0
2022  2.0
2023  2.0
2024  2.0
2025  2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{mfcalc(), the showeq option}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-the-showeq-option}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{showeq}} option is by default \sphinxcode{\sphinxupquote{= False}}.

\sphinxAtStartPar
By setting equal to \sphinxcode{\sphinxupquote{True}}, mfcalc can be used to express the normalization of an entered equation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dlog( a) =  0.02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{showeq}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
FRML \PYGZlt{}\PYGZgt{} A=EXP(LOG(A(\PYGZhy{}1))+0.02)\PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{modelflow}} the expression \sphinxcode{\sphinxupquote{dlog(a)}} refers to the difference in the natural logarithm \(dlog(x_t) \equiv ln(x_t)-ln(x_{t-1})\) and is equal to the growth rate for the variable.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.mfcalc()}} normalizes the equation such that the systems solves for a as follows:
\begin{equation*}
\begin{split}dlog(a)  = 0.02$$ <br>
$$log(a)-log(a_{t-1}) = .02$$<br>
$$log(a)=log(a_{t-1})+.02$$ <br>
$$a = e^{log(a_{t-1})+0.02}$$ <br>
$$a =a_{t-1}*e^{0.02}\end{split}
\end{equation*}
\sphinxAtStartPar
which expressed in the business logic language of \sphinxcode{\sphinxupquote{modelflow}} is:

\sphinxAtStartPar
A=EXP(LOG(A(\sphinxhyphen{}1))+0.02)


\subsection{Using .diff (\protect\(\Delta\protect\)) with mfcalc}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:using-diff-delta-with-mfcalc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diff(a) =  2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Set delta to 2 }
\PYG{n}{res}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{p}{)}                      \PYG{c+c1}{\PYGZsh{} Display the delta }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A
2020  NaN
2021  2.0
2022  2.0
2023  2.0
2024  2.0
2025  2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{mfcalc with several equations and arguments}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-with-several-equations-and-arguments}}
\sphinxAtStartPar
In addition to a single equation multiple commands can be executed with one command.

\sphinxAtStartPar
However, \sphinxstylestrong{be careful} because the equation commands are executed simultaneously, which, combined with the treatments of lags, means that results may differ from what would be expected if you ran the two commands sequentially.

\sphinxAtStartPar
For example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{diff(a) =  2}
\PYG{l+s+s1}{x = a + 42 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}

\PYG{n}{res}

\PYG{c+c1}{\PYGZsh{} use res.diff() to see the difference}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  102.0  144.0
2022  104.0  146.0
2023  106.0  148.0
2024  108.0  150.0
2025  110.0  152.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here the diff(a) is not defined for 2020 because there is no value for a in 2019.

\sphinxAtStartPar
As a result \sphinxcode{\sphinxupquote{modelflow}} generates a result only for the periodf 2021 through 2025 and it is this result that is passed to the second equation, which adds 42 to this number. Thus X in 2020 is not 142 as one might have expected but zero, the value to which the newly created variable defaults.

\sphinxAtStartPar
Compare the results above with the results (below) when the two steps are not undertaken in the same mfcalc command.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res1} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{diff(a) =  2}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}

\PYG{n}{res2} \PYG{o}{=} \PYG{n}{res1}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{x = a + 42 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0  142.0
2021  102.0  144.0
2022  104.0  146.0
2023  106.0  148.0
2024  108.0  150.0
2025  110.0  152.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{danger}{Danger:}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{.mfcalc()}}, when there are multiple equation commands is single call, they are executed simultaneously. This, combined with \sphinxcode{\sphinxupquote{mfcalc}}’s  treatments of lags, means only the results of the lagged calculation will be passed to other commands equations defined in the \sphinxcode{\sphinxupquote{.mfcalc}} command. As a consequence, results may differ from what would be expected and what you would see if you ran the two commands sequentially.
\end{sphinxadmonition}


\subsection{Setting a time frame with mfcalc.}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:setting-a-time-frame-with-mfcalc}}
\sphinxAtStartPar
It can useful in some circumstances to limit the time frame for which the calculations are performed. By specifying a start date and end date enclosed in <> in a  line we can restrict the time period over which calculation is performed.

\sphinxAtStartPar
Below, as in the example above we have zeroes for x prior to 2023 when the expressions are executed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2023 2025\PYGZgt{}}
\PYG{l+s+s1}{diff(a) =  2}
\PYG{l+s+s1}{x = a + 42 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}

\PYG{n}{res}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  100.0    0.0
2022  100.0    0.0
2023  102.0  144.0
2024  104.0  146.0
2025  106.0  148.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{A simple MFMod\sphinxhyphen{}Style Model in modelflow}

\sphinxstepscope


\chapter{A simple macrostructural model in Modelflow}
\label{\detokenize{content/05_SimpleModel/SimpleModel:a-simple-macrostructural-model-in-modelflow}}\label{\detokenize{content/05_SimpleModel/SimpleModel::doc}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} is a sophisticated tool that can deal with extremely large and complicated models, including the Federal Reserve’s \sphinxhref{https://www.federalreserve.gov/econres/us-models-about.htm}{FRB/US} model and the World Bank’s climate\sphinxhyphen{}aware macrostructural models.  In this chapter we illustrate some of the main features of \sphinxcode{\sphinxupquote{modelflow}} using a very simple macrostructural model.

\sphinxAtStartPar
In the following chapter we use \sphinxcode{\sphinxupquote{modelflow}} with a full\sphinxhyphen{}blown macro\sphinxhyphen{}structural model, and examine some of the more advanced features of the \sphinxcode{\sphinxupquote{modelflow}} class.


\section{Setting up the environment}
\label{\detokenize{content/05_SimpleModel/SimpleModel:setting-up-the-environment}}
\sphinxAtStartPar
As always, the python environment needs to be set up by importing the classes and modules upon which the following program(s) will depend.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} Notebook
\PYG{k+kn}{from} \PYG{n+nn}{modelclass} \PYG{k+kn}{import} \PYG{n}{model} 
\PYG{k+kn}{from} \PYG{n+nn}{modelgrabwf2} \PYG{k+kn}{import} \PYG{n}{GrabWfModel}
\PYG{k+kn}{import} \PYG{n+nn}{modelpattern} \PYG{k}{as} \PYG{n+nn}{pt} \PYG{c+c1}{\PYGZsh{}Allows pattern a selections from model structures}
\PYG{k+kn}{import} \PYG{n+nn}{re}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{widescreen}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{scroll\PYGZus{}off}\PYG{p}{(}\PYG{p}{)}
\PYG{o}{\PYGZpc{}}\PYG{k}{load\PYGZus{}ext} autoreload
\PYG{o}{\PYGZpc{}}\PYG{k}{autoreload} 2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Load a pre\sphinxhyphen{}existing Eviews model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:load-a-pre-existing-eviews-model}}
\sphinxAtStartPar
In this simple example we will load a simple real\sphinxhyphen{}side only macroeconomic model that was created in EViews.  The model structure is simple.  Its i comprised of two  identities:
\begin{equation*}
\begin{split} Y_t=CPV_t + I_t + G_t + (X_t - M_t) + Y^{statdisc}_t \end{split}
\end{equation*}\begin{equation*}
\begin{split} GDE_t=CPV_t + I_t + G_t + X_t\end{split}
\end{equation*}
\sphinxAtStartPar
and four behavioural equations variables for private consumption (\(CPV\)), Investment (\(I\)), for Government spending (\(G\)) and Imports (\(M\)).
\begin{equation*}
\begin{split} CPV_t = C'( \chi _t) + \eta^C_t \end{split}
\end{equation*}\begin{equation*}
\begin{split} I_t = I'( \chi _t) + \eta^I_t \end{split}
\end{equation*}\begin{equation*}
\begin{split} G_t = G'( \chi _t) + \eta^G_t \end{split}
\end{equation*}\begin{equation*}
\begin{split} M_t = X'( \chi _t) + \eta^M_t \end{split}
\end{equation*}
\sphinxAtStartPar
and two exogenous variables (\(X\) for exports and \(Y^{statdisc}\) for the statistical discrepancy.

\sphinxAtStartPar
Each of the behaviourals is a simple error correction equation written as :
\begin{equation*}
\begin{split} \Delta var_t = - \gamma *(var_{t-1}- base_{t-1} - \beta_2 ) 2 ) + \Delta base_t \end{split}
\end{equation*}
\sphinxAtStartPar
where for each \(var \in (CPV,I,G)\) the base is \(Y\), while for M it is GDE.


\subsection{Load a model – the method \sphinxstyleliteralintitle{\sphinxupquote{.modelload()}}}
\label{\detokenize{content/05_SimpleModel/SimpleModel:load-a-model-the-method-modelload}}
\sphinxAtStartPar
The modelflow method \sphinxcode{\sphinxupquote{.modellow}} opens a pre\sphinxhyphen{}existing modelflow model, and assigns the variable \sphinxcode{\sphinxupquote{msimple}} with the model object created by model.load. The variable \sphinxcode{\sphinxupquote{init}} is assigned the value of the \sphinxcode{\sphinxupquote{dataframe}} associated with the

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The variable names \sphinxcode{\sphinxupquote{msimple}} and \sphinxcode{\sphinxupquote{init}} are completely arbitrary and could be any legal python name.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{,}\PYG{n}{init} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{modelload}\PYG{p}{(}\PYG{l+s+sa}{r}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../models/simple.pcim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{run}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{silent}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
file read:  C:\PYGZbs{}Users\PYGZbs{}wb268970\PYGZbs{}OneDrive \PYGZhy{} WBG\PYGZbs{}Ldrive\PYGZbs{}MFM\PYGZbs{}modelflow\PYGZbs{}modelflow\PYGZhy{}manual\PYGZbs{}papers\PYGZbs{}mfbook\PYGZbs{}content\PYGZbs{}models\PYGZbs{}simple.pcim
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below, we solve the model over the period 2016 to 2030, initializing it with the initial data loaded above.

\sphinxAtStartPar
The options:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{silent=1} limits reporting as the model is solved, which ensures faster operation;

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{alfa= .5} influences the step\sphinxhyphen{}size when the model is solved. alfa= 1 implies larger step sizes and faster solution, but may prevent the model from finding a solution, smaller step sizes are more computationally expensive but increase the likelihood that solutions will be found.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ldumpvars} controls whether the model should store intermediate results as it iterates towards the final solution.  ldumpvar=1 retains these intermeidate results, which may be useful in determining which equation if any is causing trouble in model solution.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{msim}\PYG{p}{(}\PYG{n}{init}\PYG{p}{,}\PYG{l+m+mi}{2016}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{,}\PYG{n}{silent}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{alfa}\PYG{o}{=}\PYG{l+m+mf}{.5}\PYG{p}{,}\PYG{n}{ldumpvar}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{}ldumpvar saves iterations 0 =\PYGZgt{} don\PYGZsq{}t; }
                                                          \PYG{c+c1}{\PYGZsh{}alfa \PYGZlt{}1 reduces step size when iterating}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Extract information about the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:extract-information-about-the-model}}
\sphinxAtStartPar
A macrostructural model is a system of equations comprised of identities (accounting rules that are always true), estimated behavioural equations and exogenous variables.

\sphinxAtStartPar
For our simple model, the identities are Y=C+I+G+X\sphinxhyphen{}M+STatDisc, and the behavioural equations (or stochastic equations) are CPV,I, G, M, with X and StatDisc being exogenous variables.

\sphinxAtStartPar
We can use the msim.identity(); msim.stoch() and msim.exogenous() functiosn to extract lists of the variables of each of these types in the model.

\sphinxAtStartPar
As a class \sphinxcode{\sphinxupquote{model}} has methods and properties. Methods perform actions on the data of the class, and properties are effectively the data associated with an instance of a class (msim in our case).

\sphinxAtStartPar
When we created the model we included in it both identities, behavioural equations and implicitly exogenous variables.

\sphinxAtStartPar
Both identities and behaviourals are endogenous variables (model determined), while exogenous variables are provided by the modeller and condition the model forecast.

\sphinxAtStartPar
The following methods returns lists of variable mnemonics from the \sphinxstyleemphasis{economic} model based on their economic role in the model as: identities, behavoural equations or exogenous variables.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{model}} property
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.model\_identity}}
&
\sphinxAtStartPar
Returns a python list of the mnemonics of all identities in the model
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.model\_stochastic}}
&
\sphinxAtStartPar
Returns a python list of the mnemonics of all behavioural (or stochastic) equations in the model
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.model\_endogene}}
&
\sphinxAtStartPar
Returns a python list of the mnemonics of all endogenous variables in the model  (Identities and Behavioral)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.model\_exogene}}
&
\sphinxAtStartPar
Returns a python list of the mnemonics of all exogenous variables in the model
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
The mathematical model includes some additional “helper” variables that are mathematically either endogenous or exogenous in the model. Mathematically there is no real difference between an identity equation and a behavioural equation. The “helper” variables allow us to treat behavioral equations differently than identities in a way that make sense economically. The following methods return lists that include both the “economic” variables listed above and these helper variables that form part of the mathematical model.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{model}} property
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.endogene}}
&
\sphinxAtStartPar
Lists all endogenous variables in the model (Identities and behaviourals)
\\
\hline
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.exogene()}}
&
\sphinxAtStartPar
Lists all exogenous variables in the model
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
These will have to be updated with the embodied calls when available


\subsection{List all identities in the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:list-all-identities-in-the-model}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ident} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{msim}\PYG{o}{.}\PYG{n}{endogene} \PYG{k}{if} \PYG{n}{pt}\PYG{o}{.}\PYG{n}{kw\PYGZus{}frml\PYGZus{}name}\PYG{p}{(}\PYG{n}{msim}\PYG{o}{.}\PYG{n}{allvar}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{frmlname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}ident=msim.model\PYGZus{}identity()}
\PYG{n}{ident}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}GDE\PYGZsq{}, \PYGZsq{}Y\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{List all behavioural equations in the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:list-all-behavioural-equations-in-the-model}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{stoc} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{msim}\PYG{o}{.}\PYG{n}{endogene} \PYG{k}{if} \PYG{n}{pt}\PYG{o}{.}\PYG{n}{kw\PYGZus{}frml\PYGZus{}name}\PYG{p}{(}\PYG{n}{msim}\PYG{o}{.}\PYG{n}{allvar}\PYG{p}{[}\PYG{n}{v}\PYG{p}{]}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{frmlname}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Z}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{p}{\PYGZcb{}}
\PYG{c+c1}{\PYGZsh{}stoch=msim.model\PYGZus{}stochastic()}
\PYG{n}{stoc}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}CPV\PYGZsq{}, \PYGZsq{}G\PYGZsq{}, \PYGZsq{}I\PYGZsq{}, \PYGZsq{}M\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{List all exogenous variables in the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:list-all-exogenous-variables-in-the-model}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}exog=msim.model\PYGZus{}exogene()}
\PYG{n}{exog} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n}{msim}\PYG{o}{.}\PYG{n}{exogene} \PYG{k}{if} \PYG{o+ow}{not} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}} \PYG{o+ow}{in} \PYG{n}{v}  \PYG{p}{\PYGZcb{}}
\PYG{n}{exog}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}X\PYGZsq{}, \PYGZsq{}YDISC\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Equations in a \sphinxstyleliteralintitle{\sphinxupquote{modelflow}} model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:equations-in-a-modelflow-model}}
\sphinxAtStartPar
As noted earlier, a macrostructural model is comprised of identities, behavioural equations and exogenous variables.


\subsection{Identities}
\label{\detokenize{content/05_SimpleModel/SimpleModel:identities}}
\sphinxAtStartPar
Identities are accounting rules that are always true.  GDP is an identity because GDP is identically equal to C+I+G+(X\sphinxhyphen{}M)+ YDISC.  The Fiscal balance (Deficit when negative) is an identity \(Fisc^{Balance}_t=Fisc^{Revenues}_t-Fisc^{Expenditure}_t\) etc.


\subsection{Behavioural equations: Fitted Values and Add Factors}
\label{\detokenize{content/05_SimpleModel/SimpleModel:behavioural-equations-fitted-values-and-add-factors}}
\sphinxAtStartPar
In World Bank models, behavioural equations are split into two parts. The fitted value of the equation and an add factor. This split derives naturally from the econometrics of behavioural equations.

\sphinxAtStartPar
Below is a standard regression equation for a linear equation.
\begin{equation*}
\begin{split}y_t = \alpha + \beta X_t +\eta_t\end{split}
\end{equation*}
\sphinxAtStartPar
Let \(\hat{\alpha}\) and \(\hat{\beta}\) represent the econometrically estimated values of \(\alpha\) and \(\beta\) above, then we can define the fitted value for \(y_t\) (\(\hat{y_t}\)) as:
\begin{equation*}
\begin{split} \hat{y_t} \equiv  \hat{\alpha} + \hat{\beta} X_t  \end{split}
\end{equation*}
\sphinxAtStartPar
We can then define the add factor for the behavioural variable y as (\(y^{AF}_t\))  as
\begin{equation*}
\begin{split} y^{AF}_t \equiv  \hat{y_t} -( \hat{\alpha} + \hat{\beta} X_t)  \end{split}
\end{equation*}
\sphinxAtStartPar
Over the historical period, \sphinxstyleemphasis{Add Factors} are assigned values that ensure that the sum of the  fitted value and its add\sphinxhyphen{}factor exactly equals the observed historical value. \sphinxstylestrong{In the historical period the Add Factor Equals the regression error term.}

\sphinxAtStartPar
Over the forecast period, the regression error term \(\eta_t\) does not exist (as there is no data with which to calculate it). By retaining the \sphinxstyleemphasis{Add Factor}, the model has a mechanism that allows the modeller to cause the forecast to deviate from the pathway that would be dictated by the fitted values of the equation.

\sphinxAtStartPar
In World Bank models add\sphinxhyphen{}factors for behavioural equations (they are only defined for behavioural equations) are indicated by adding \_A to the variable name.

\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
Reproducibility

\sphinxAtStartPar
\sphinxstylestrong{Over the historical period}, the Add\sphinxhyphen{}Factor ensures that the model \sphinxstyleemphasis{reproduces} history.

\sphinxAtStartPar
\sphinxstylestrong{Reproducibility} is an essential quality for a macro model.

\sphinxAtStartPar
\sphinxstylestrong{In forecast mode}, the Add\sphinxhyphen{}Factor allows the forecast to deviate from the fitted value of the behavioral equations of the model – reflecting the judgment of the analyst.

\sphinxAtStartPar
\sphinxstylestrong{In simulations}, the Add\sphinxhyphen{}Factor allows for the path of endogenous behavioural variables to be shocked by specific amounts and over specific time periods. Shocked in this way the equation for the model remains active and can react endogenously through the simulation period to the influence of the shock.
\end{sphinxadmonition}


\subsection{Using Add factors when forecasting}
\label{\detokenize{content/05_SimpleModel/SimpleModel:using-add-factors-when-forecasting}}
\sphinxAtStartPar
When building a baseline forecast, a modeller can use the \sphinxstylestrong{Add Factor} to add his own judgment to the forecast value for a variable.

\sphinxAtStartPar
For example, suppose the fitted value for Consumption was 100 in 2023.  Effectively this says the conditional forecast of the model for Consumption (CPV) given (conditioned upon) the level of all the other variables is 100.
\begin{equation*}
\begin{split} CPV\_FITTED_{2023} \equiv \hat{CPV}_{2023} = \hat{\alpha} + \hat{\beta} X_2023  \end{split}
\end{equation*}
\sphinxAtStartPar
If a forecaster had information that the model did not, say the onset of Covid earlier that year (or of a major storm), s/he good add to this conditional forecast their judgement that consumption is expected to be to be 20 units lower than the 100 expected by the model.

\sphinxAtStartPar
The fully formed equation then becomes
\begin{equation*}
\begin{split}CPV_{2023} =  CPV\_FITTED_{2023} + CPV\_A_{2023}\end{split}
\end{equation*}
\sphinxAtStartPar
or
\$\(CPV_{2023} =  80= 100 + (-20) \)\$

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In addition to the \_A (Add Factor) variable, modelflow also generates an \_FITTED variable that holds the conditional forecast of the model for that variable at any given time.  The forecast is conditional because it is conditioned on the state of the other variables (the \(X_t\) in the regression equation).

\sphinxAtStartPar
NB: The \_FITTED variable is calculated by solving the behavioural equation with all add factors set to zero. :::
\end{sphinxadmonition}


\subsection{Extracting information about equations}
\label{\detokenize{content/05_SimpleModel/SimpleModel:extracting-information-about-equations}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} contains two methods to display equations from the model.  The first \sphinxcode{\sphinxupquote{.frml}} displays the formula for selected variables as it has been translated into the business logic language of \sphinxcode{\sphinxupquote{modelflow}}.

\sphinxAtStartPar
The second is  Ib isn’t there a way to display the original equation that was submitted ie. dlog(x)= a + b dlog(y)? 


\subsubsection{The \sphinxstyleliteralintitle{\sphinxupquote{.frml}} method}
\label{\detokenize{content/05_SimpleModel/SimpleModel:the-frml-method}}
\sphinxAtStartPar
When equations are displayed using the \sphinxcode{\sphinxupquote{.frml}} method in the Business logic language of \sphinxcode{\sphinxupquote{modelflow}}. in \sphinxcode{\sphinxupquote{business logic}}, all equations are normalized, such that the normalized equation solves for the level of the dependent variable.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{.frml}} output of a simple  identity}
\label{\detokenize{content/05_SimpleModel/SimpleModel:frml-output-of-a-simple-identity}}
\sphinxAtStartPar
For simple identities like GDP, the Y variable in the simple model \sphinxcode{\sphinxupquote{msim}}, the normalized version of the model equation is the same as the input equation because it was originally normalized.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{frml}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Y : FRML \PYGZlt{}\PYGZgt{} Y = CPV+I+G+X\PYGZhy{}M+YDISC \PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the output, the initial field (before the :) shows  the dependent variable that the equation determines, the part following that is the actual FRML equation with the text between <> indicating the features of the particular equation, in this case the blank space indicates it is an Identity.


\subsubsection{\sphinxstyleliteralintitle{\sphinxupquote{.frml}} output of a behavioural}
\label{\detokenize{content/05_SimpleModel/SimpleModel:frml-output-of-a-behavioural}}
\sphinxAtStartPar
For a more complex equation, such as say the ECM equation of our simple consumption equation, the normalized output will differ from the original specification.

\sphinxAtStartPar
Thus for an original (simple) ECM style equation that might have looked like this:
\begin{equation*}
\begin{split}\Delta ln(C_t) = \beta_2 (ln(C_{t-1})-ln(Y_{t-1}) + \beta_1) + \beta_{10}\Delta ln(Y_t)\end{split}
\end{equation*}
\sphinxAtStartPar
The normalized version would look like
\begin{equation*}
\begin{split} ln(C_t) =ln(C_{t-1})+\beta_2 (ln(C_{t-1})-ln(Y_{t-1}) + \beta_1) + \beta_{10}\Delta ln(Y_t) +AF_t\end{split}
\end{equation*}\begin{equation*}
\begin{split} C_t= C_{t-1} * e^{(\beta_2 (ln(C_{t-1})-ln(Y_{t-1}) + \beta_1) + \beta_{10}\Delta ln(Y_t) +AF_t)}\end{split}
\end{equation*}
\sphinxAtStartPar
The normalized version of the consumption equation in \sphinxcode{\sphinxupquote{msim}} is given below:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CPV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{frml}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
CPV : FRML \PYGZlt{}Z,EXO\PYGZgt{} CPV = (CPV(\PYGZhy{}1)*EXP(CPV\PYGZus{}A+ (\PYGZhy{}.3*(LOG(CPV(\PYGZhy{}1))\PYGZhy{}LOG(Y(\PYGZhy{}1))\PYGZhy{}LOG(0.866239851149167))+0.0237316411085375*((LOG(Y))\PYGZhy{}(LOG(Y(\PYGZhy{}1))))) )) * (1\PYGZhy{}CPV\PYGZus{}D)+ CPV\PYGZus{}X*CPV\PYGZus{}D \PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
As before, the first part of the \sphinxcode{\sphinxupquote{.frml}} output indicates the mnemonic of the behavioural variable that the formula determines (in this case CPV).  This is followed by a \sphinxcode{\sphinxupquote{FRML}} statement (the actual Business Logic formulation generated by \sphinxcode{\sphinxupquote{modelflow}}). The \sphinxcode{\sphinxupquote{FRML}} is the normalized version of the actual equation submitted – in this case a logarithmic growth equation, normalized to solve for the level of the dependent variable.).

\sphinxAtStartPar
The above \sphinxcode{\sphinxupquote{FRML}} statement indicates that this is a behavioural equation (the Z between the <>, that can be exogenized (EXO).  Where exogenized means that the equation can be turned off and the value of the behavioural equation set to a specific value determined by the modeller.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Behavioural equations can be exogenized. Ecogenizing, effectively de\sphinxhyphen{}activates the equation, allowing the modeller to impose a value on the dependent variable of the equation that is different from that which the equation would return.

\sphinxAtStartPar
Equations can be exogenized either to impose the judgement of the analyst in forecasting mode, or to perform what if scenarios.
\end{sphinxadmonition}


\paragraph{Automatically generated variables associated with behavioural equations}
\label{\detokenize{content/05_SimpleModel/SimpleModel:automatically-generated-variables-associated-with-behavioural-equations}}
\sphinxAtStartPar
Behavioural equations like CPV above include three automatically generated variables that form part of the mathematical model that is actually solved by \sphinxcode{\sphinxupquote{modelflow}}, but are not part of the “economic model”. These three variables are formed by by adding \_A \_X \_D to the dependent variables of the dependent variable for each behavioural equation in the model.

\sphinxAtStartPar
The first of these \_A is the add factor discussed above.  The second (\_D) is a dummy variable which when it has the value zero indicates that the estimated equation will be used to determine the value of the dependent variable in a behaviorual equation. When the (\_D) variable has the value of 1, then the equation is said to be exogenized or de\sphinxhyphen{}activated and the dependent variable will be set equal to the \_X variable.

\sphinxAtStartPar
In addition, \sphinxcode{\sphinxupquote{modelflow}} also generates one reporting variable \_FITTED (discussed above) which contains the value of teh conditional forecast of the behavioural equation for the dependent variable.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Suffix
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Role
\\
\hline
\sphinxAtStartPar
\_A
&
\sphinxAtStartPar
Add Factor
&
\sphinxAtStartPar
Used to impose (add)  judgement to the fitted value of a behavioural equation  (see following section)
\\
\hline
\sphinxAtStartPar
\_D
&
\sphinxAtStartPar
Exog Switch
&
\sphinxAtStartPar
A special dummy variable that determines whether a behavioural equation is turned
\\
\hline
\sphinxAtStartPar
\_X
&
\sphinxAtStartPar
Exog Value
&
\sphinxAtStartPar
Value taken by an exogenized variable (if \_D=1)
\\
\hline
\sphinxAtStartPar
\_FITTED
&
\sphinxAtStartPar
Fitted Value
&
\sphinxAtStartPar
The result of the behavioural equation when solved for \(X_t\) but with add factors equal to zero.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\paragraph{Function of the  \_X \_D variables in the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:function-of-the-x-d-variables-in-the-model}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.frml}} method returns the normalized version of the initial equation – \sphinxstylestrong{multiplied by the (1\sphinxhyphen{}varame\_D)} + plus varname\_X*varname\_D).

\sphinxAtStartPar
This expression effectively defines two equations for the dependent variable.  In the first instance (when varname\_D=0) the varname will follow the normalized equation.  But when varame\_D=1. The first expression resolved to zero, and the second expression varname\_D*varname\_X determines the level of the dependent variable setting it to the value of varname\_X.

\sphinxAtStartPar
\sphinxstylestrong{Setting varname\_D=1 effectively turns the equation off and makes the equation a simple identity where varname=varname\_X.}

\sphinxAtStartPar
The normalized equation with the extra variables that allow it to be exogenized.
\begin{equation*}
\begin{split} C_t= \bigg( C_{t-1} * e^{\beta_2 (ln(C_{t-1})-ln(Y_{t-1}) + \beta_1) + \beta_{10}\Delta ln(Y_t) +AF_t}\bigg) *(1-CPV\_D_t) + CPV\_D_t*CPV\_X_t\end{split}
\end{equation*}
\sphinxAtStartPar
When \(CPV\_D_t=0\) this simplifies to
\begin{equation*}
\begin{split} C_t= \bigg( C_{t-1} * e^{\beta_2 (ln(C_{t-1})-ln(Y_{t-1}) + \beta_1) + \beta_{10}\Delta ln(Y_t) +AF_t}\bigg) \end{split}
\end{equation*}
\sphinxAtStartPar
When \(CPV\_D_t=1\) this simplifies to:
\begin{equation*}
\begin{split} C_t= CPV\_X_t\end{split}
\end{equation*}
\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
Setting the \_D variable equal to one effectively turns the equation off. It \sphinxstylestrong{exogenizes} the  endogenous variable, setting its value to the value of the \_X variable.  This can be done for the whole period or just a sub period.
\end{sphinxadmonition}


\subsubsection{Passing multiple variables to \sphinxstyleliteralintitle{\sphinxupquote{.frml}}}
\label{\detokenize{content/05_SimpleModel/SimpleModel:passing-multiple-variables-to-frml}}
\sphinxAtStartPar
In addition to extracting only one variable you can extract the formulae of many variables by just widening the selection criteria.

\sphinxAtStartPar
Thus \sphinxcode{\sphinxupquote{msim{[}'Y CPV'{]}}} returns the formulae for both GDP and consumption.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y CPV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{frml}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Y   : FRML \PYGZlt{}\PYGZgt{} Y = CPV+I+G+X\PYGZhy{}M+YDISC \PYGZdl{}
CPV : FRML \PYGZlt{}Z,EXO\PYGZgt{} CPV = (CPV(\PYGZhy{}1)*EXP(CPV\PYGZus{}A+ (\PYGZhy{}.3*(LOG(CPV(\PYGZhy{}1))\PYGZhy{}LOG(Y(\PYGZhy{}1))\PYGZhy{}LOG(0.866239851149167))+0.0237316411085375*((LOG(Y))\PYGZhy{}(LOG(Y(\PYGZhy{}1))))) )) * (1\PYGZhy{}CPV\PYGZus{}D)+ CPV\PYGZus{}X*CPV\PYGZus{}D \PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Note that the formula for Y is an identity, as such there is no \_A \_X \_D (or \_FITTED) variables. Moreover, the <> expression contains  nothing \sphinxstylestrong{This will have to be changed when new version of modelflow released.} because it cannot because identities cannot be exogenized.


\subsection{The mathemetically endogenous and exogenous variables of the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:the-mathemetically-endogenous-and-exogenous-variables-of-the-model}}
\sphinxAtStartPar
Because in \sphinxcode{\sphinxupquote{modelflow}} the \sphinxstyleemphasis{economic} model is augmented with the above variables \_A, \_D, \_X, \_FITTED the set of mathematically exogenous and endogenous variables is larger.  These sets can be retrieved with the methods: \sphinxcode{\sphinxupquote{.endogene}} and \sphinxcode{\sphinxupquote{exogene}}.

\sphinxAtStartPar
\#\#\#\#\#The mathematically exogenous variables of our simple model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{o}{.}\PYG{n}{exogene}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}CPV\PYGZus{}A\PYGZsq{},
 \PYGZsq{}CPV\PYGZus{}D\PYGZsq{},
 \PYGZsq{}CPV\PYGZus{}X\PYGZsq{},
 \PYGZsq{}G\PYGZus{}A\PYGZsq{},
 \PYGZsq{}G\PYGZus{}D\PYGZsq{},
 \PYGZsq{}G\PYGZus{}X\PYGZsq{},
 \PYGZsq{}I\PYGZus{}A\PYGZsq{},
 \PYGZsq{}I\PYGZus{}D\PYGZsq{},
 \PYGZsq{}I\PYGZus{}X\PYGZsq{},
 \PYGZsq{}M\PYGZus{}A\PYGZsq{},
 \PYGZsq{}M\PYGZus{}D\PYGZsq{},
 \PYGZsq{}M\PYGZus{}X\PYGZsq{},
 \PYGZsq{}X\PYGZsq{},
 \PYGZsq{}YDISC\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{The mathematically endogenous variables in our model.}
\label{\detokenize{content/05_SimpleModel/SimpleModel:the-mathematically-endogenous-variables-in-our-model}}
\sphinxAtStartPar
Note this includes both identities and behavioural equations, because mathematically each is an endogenous equation – the distinction identity vs behavioural is important economically but has no meaning mathematically.  Each equation determines the value of a variable in the system of equations that constitute the model.

\sphinxAtStartPar
Note the reporting variables \_FITTED are mathematically endogenous. They form part of the model even if they do not interact with any other variables in the model.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{o}{.}\PYG{n}{endogene}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}CPV\PYGZsq{},
 \PYGZsq{}CPV\PYGZus{}FITTED\PYGZsq{},
 \PYGZsq{}G\PYGZsq{},
 \PYGZsq{}GDE\PYGZsq{},
 \PYGZsq{}G\PYGZus{}FITTED\PYGZsq{},
 \PYGZsq{}I\PYGZsq{},
 \PYGZsq{}I\PYGZus{}FITTED\PYGZsq{},
 \PYGZsq{}M\PYGZsq{},
 \PYGZsq{}M\PYGZus{}FITTED\PYGZsq{},
 \PYGZsq{}Y\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Data storage in modelflow}
\label{\detokenize{content/05_SimpleModel/SimpleModel:data-storage-in-modelflow}}
\sphinxAtStartPar
Modelflow uses the pandas dataframe system to store data.  Every model instance will have at least two dataframes \sphinxcode{\sphinxupquote{.lastdf}} and \sphinxcode{\sphinxupquote{.basedf}}.  The first contains the results of the most recent simulation, and the second contains the initial or baseline values of the data prior to the running of any simulations.

\sphinxAtStartPar
Following our load and test solving of our simple model, we can inspect the values for each of these dataframes.

\sphinxAtStartPar
Below we are using standard pandas functions and python constructs to
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
set the display format we want to use the \sphinxcode{\sphinxupquote{with pd.option\_context('display.float\_format', '\{:,.6f\}'.format):}} line

\item {} 
\sphinxAtStartPar
Indicate what we want to display – here the results of a manipulation of the data, which in this case calculates the difference between the value for GDP (Y) in the two dataframes, expressed as a percent of the \sphinxcode{\sphinxupquote{basedf}} dataframe. The formula used is equivalent to  \(\bigg({{y^{lastdf}-y^{basedf}} \over {y^{basedf}}} \bigg)*100\)

\end{enumerate}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{option\PYGZus{}context}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display.float\PYGZus{}format}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:,.8f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{display}\PYG{p}{(}\PYG{p}{(}\PYG{n}{msim}\PYG{o}{.}\PYG{n}{lastdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{msim}\PYG{o}{.}\PYG{n}{basedf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2000   0.00000000
2001   0.00000000
2002   0.00000000
2003   0.00000000
2004   0.00000000
2005   0.00000000
2006   0.00000000
2007   0.00000000
2008   0.00000000
2009   0.00000000
2010   0.00000000
2011   0.00000000
2012   0.00000000
2013   0.00000000
2014   0.00000000
2015   0.00000000
2016   0.00000000
2017   0.00000000
2018   0.00000000
2019   0.00000000
2020   0.00000000
2021   0.00000000
2022   0.00000000
2023   0.00000000
2024   0.00000000
2025   0.00000000
2026   0.00000000
2027   0.00000000
2028   0.00000000
2029   0.00000000
2030   0.00000000
Name: Y, dtype: float64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{important}{Important:}
\sphinxAtStartPar
The model has returned the same values as we input. This is very important because it implies the model passed the test that it reproduces history and in this case the forecast result when no changes are made to the model.
\end{sphinxadmonition}

\sphinxAtStartPar
As we run more meaningful simulations below we can explore some of the data visualizations built into modelflow, which includes the mathplotlib and pandas  functions as well as \sphinxcode{\sphinxupquote{modelflow}} specific extensions to them.


\section{Simulating the model}
\label{\detokenize{content/05_SimpleModel/SimpleModel:simulating-the-model}}
\sphinxAtStartPar
To perform a simulation we must change one of the variables in the model.  As seen above, and in compliance with basic mathematics, if we change none of the model inputs and solve its system of equations it will always return the same result.

\sphinxAtStartPar
There are several ways that a model can be shocked.
\begin{itemize}
\item {} 
\sphinxAtStartPar
Shock an exogenous variable

\item {} 
\sphinxAtStartPar
Exogenize a behavioural equation and shock it

\item {} 
\sphinxAtStartPar
Shock the Add\sphinxhyphen{}factor of a behavioural equation

\end{itemize}

\sphinxAtStartPar
Below we will do each in turn, using the simple model.  The objective here is to understand the mechanisms at play, and the steps necessary to perform each kind of simulation.


\subsection{Shock an exogenous variable}
\label{\detokenize{content/05_SimpleModel/SimpleModel:shock-an-exogenous-variable}}
\sphinxAtStartPar
In the model we have only two exogenous variables X (Exports) and YDISC (the statistical discrepancy).

\sphinxAtStartPar
To illustrate how to perform a simulation, lets assume that Demand for our countries exports increase by 10\% between 2024 and 2026 and the return to their earlier level.

\sphinxAtStartPar
To do this we will need to change the values of exports and solve the model with the new values.

\sphinxAtStartPar
A simple way to do this would be to revise the value of X for the years 2024, 2025, 2026 by 10 percent.  Pandas offers many ways to change the values of cells in a dataframe, we will do it in a \sphinxcode{\sphinxupquote{modelflow}} way using the method \sphinxcode{\sphinxupquote{.mfcalc()}} which allows us among other things to revise a the value of a variable. In this case we  multiply the existing value of X in the initial dataframe by 1.1 or increasing it by 10\%.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{XShockdf}\PYG{o}{=}\PYG{n}{init}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2024 2026\PYGZgt{} X = X*1.1}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{p}{(}\PYG{n}{XShockdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{init}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{X}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2000     0.0
2001     0.0
2002     0.0
2003     0.0
2004     0.0
2005     0.0
2006     0.0
2007     0.0
2008     0.0
2009     0.0
2010     0.0
2011     0.0
2012     0.0
2013     0.0
2014     0.0
2015     0.0
2016     0.0
2017     0.0
2018     0.0
2019     0.0
2020     0.0
2021     0.0
2022     0.0
2023     0.0
2024    10.0
2025    10.0
2026    10.0
2027     0.0
2028     0.0
2029     0.0
2030     0.0
Name: X, dtype: float64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To simulate the model using this new input, we can just submit this new revised dataframe in the same way we did the initial simulation.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The results of a simulation are stored in the variable to the left of the call to the simulation, but are also automatically stored in an internal variable \sphinxcode{\sphinxupquote{.lastdf}}, along with \sphinxcode{\sphinxupquote{.basedf}} which contains the initial pre\sphinxhyphen{}shock dataframe.

\sphinxAtStartPar
Each time a simulation is run the value of \sphinxcode{\sphinxupquote{lastdf}} gets overwritten with the results of the new simulation.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{XShock\PYGZus{}result} \PYG{o}{=} \PYG{n}{msim}\PYG{p}{(}\PYG{n}{XShockdf}\PYG{p}{,}\PYG{l+m+mi}{2016}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{,}\PYG{n}{silent}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{alfa}\PYG{o}{=}\PYG{l+m+mf}{.5}\PYG{p}{,}\PYG{n}{ldumpvar}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{c+c1}{\PYGZsh{}ldumpvar saves iterations 0 =\PYGZgt{} don\PYGZsq{}t; }
                                                          \PYG{c+c1}{\PYGZsh{}alfa \PYGZlt{}1 reduces step size when iterating}

\PYG{c+c1}{\PYGZsh{} Use straight up pandas to display the results     }
\PYG{k}{with} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{option\PYGZus{}context}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{display.float\PYGZus{}format}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:,.2f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{display}\PYG{p}{(}\PYG{p}{(}\PYG{n}{msim}\PYG{o}{.}\PYG{n}{lastdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{msim}\PYG{o}{.}\PYG{n}{basedf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2000   0.00
2001   0.00
2002   0.00
2003   0.00
2004   0.00
2005   0.00
2006   0.00
2007   0.00
2008   0.00
2009   0.00
2010   0.00
2011   0.00
2012   0.00
2013   0.00
2014   0.00
2015   0.00
2016   0.00
2017   0.00
2018   0.00
2019   0.00
2020   0.00
2021   0.00
2022   0.00
2023   0.00
2024   0.96
2025   1.05
2026   1.14
2027   0.29
2028   0.33
2029   0.36
2030   0.37
Name: Y, dtype: float64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In addition to the standard pandas features we have used to visualize data and simulation results, \sphinxcode{\sphinxupquote{modeflflow}} also has some built in methods for displaying results.


\section{Text\sphinxhyphen{}based modelflow methods for displaying simulation results}
\label{\detokenize{content/05_SimpleModel/SimpleModel:text-based-modelflow-methods-for-displaying-simulation-results}}
\sphinxAtStartPar
Below are some \sphinxcode{\sphinxupquote{modelflow}} specific methods for displaying results.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Method
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Example
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Short Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
\\
\hline
\sphinxAtStartPar
.dif
&
\sphinxAtStartPar
msim{[}‘Y’{]}.dif.df
&
\sphinxAtStartPar
Shock\sphinxhyphen{}control (level)
&
\sphinxAtStartPar
The difference in the levels between \sphinxcode{\sphinxupquote{.lastdf}} and \sphinxcode{\sphinxupquote{.basedf}}  \(X^{lastdf}-X^{basedf}\)
\\
\hline
\sphinxAtStartPar
.difpct
&
\sphinxAtStartPar
msim{[}‘Y’{]}.difpct.df
&
\sphinxAtStartPar
Change in growth rates
&
\sphinxAtStartPar
Difference between the growth rate of selected variables in the  \sphinxcode{\sphinxupquote{.lastdf}} dataframe vs the \sphinxcode{\sphinxupquote{.basedf}} dataframe  \((\dot{X}^{lastdf}-\dot{X}^{basedf})\)
\\
\hline
\sphinxAtStartPar
.mul100
&
\sphinxAtStartPar
msim{[}‘Y’{]}.difpct.df
&
\sphinxAtStartPar
Multiplies result by 100
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
.difpct.mull100
&
\sphinxAtStartPar
msim{[}‘Y’{]}.difpct.mul100.df
&
\sphinxAtStartPar
Change in growth rates * 100
&
\sphinxAtStartPar
Difference between the growth rate (multiplied by 100) of selected variables in the  \sphinxcode{\sphinxupquote{.lastdf}} dataframe vs the \sphinxcode{\sphinxupquote{.basedf}} dataframe  \((\dot{X}^{lastdf}-\dot{X}^{basedf})*100\)
\\
\hline
\sphinxAtStartPar
.pctdiflevel
&
\sphinxAtStartPar
msim{[}‘Y’{]}.pctdiflevel.mul100.df
&
\sphinxAtStartPar
Shock\sphinxhyphen{}control (\% of baseline)
&
\sphinxAtStartPar
The change in the level of the variable divided by the level in the \sphinxcode{\sphinxupquote{.basedf}} multiplied by 100  \(\bigg( {{X^{lastdf}-X^{basedf}} \over {X^{basedf}}} \bigg) * 100\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{msim.smpl(2020,2030)}} restricts the period over which following modelflow commands operate.  Here it limits the display of data to the period 2020 through 2030.
\end{sphinxadmonition}


\subsection{.dif  The difference in levels between solutions}
\label{\detokenize{content/05_SimpleModel/SimpleModel:dif-the-difference-in-levels-between-solutions}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif}} method shows the difference in the levels between two simulations  \(X^{lastdf}-X^{basedf}\).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{)}
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y CPV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{df}

\PYG{c+c1}{\PYGZsh{}\PYGZsh{}This is equivalent to standard pandas (except here we have restricted the display period to 2020 2030)}
\PYG{c+c1}{\PYGZsh{}print((msim.lastdf[\PYGZsq{}Y\PYGZsq{}]\PYGZhy{}msim.basedf[\PYGZsq{}Y\PYGZsq{}])*100)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
                  Y            CPV
2020       0.000181       0.000060
2021       0.000197       0.000084
2022       0.000246       0.000106
2023       0.000297       0.000131
2024  318402.160251    5025.431813
2025  365062.261995   71302.371920
2026  419555.064658  130418.333366
2027  113193.218871  180026.429613
2028  134016.502259  157209.057757
2029  153479.554069  144823.692626
2030  168433.334917  139800.653296
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.difpct the difference between the growth rates from the pre\sphinxhyphen{}shock and post\sphinxhyphen{}shock database}
\label{\detokenize{content/05_SimpleModel/SimpleModel:difpct-the-difference-between-the-growth-rates-from-the-pre-shock-and-post-shock-database}}
\sphinxAtStartPar
In this case \sphinxcode{\sphinxupquote{msim{[}'Y'{]}.difpct.df}} prints the growth rate from the lastdf dataframe less the growth rate from the basedf dataframe.
\begin{equation*}
\begin{split}(\dot{X}^{lastdf}-\dot{X}^{basedf})\end{split}
\end{equation*}
\sphinxAtStartPar
Adding the function \sphinxcode{\sphinxupquote{.mul100}} multiplies the result by 100.

\sphinxAtStartPar
Thus \sphinxcode{\sphinxupquote{msim{[}'Y'{]}.difpct.mul100.df}} returns
\begin{equation*}
\begin{split}(\dot{X}^{lastdf}-\dot{X}^{basedf})*100\end{split}
\end{equation*}
\sphinxAtStartPar
This is precisely equivalent to the this pure pandas command \sphinxcode{\sphinxupquote{print((msim.lastdf{[}'Y'{]}.pct\_change()\sphinxhyphen{}msim.basedf{[}'Y'{]}.pct\_change())*100)}}.

\sphinxAtStartPar
Because \sphinxcode{\sphinxupquote{msim{[}'Y'{]}.difpct.mul100.df}} is a \sphinxcode{\sphinxupquote{modelflow}} extension to pandas it will respect the sample period set by any earlier \sphinxcode{\sphinxupquote{.smpl(Begin,Year)}} statement, whereas teh pure pandas version would display all of the data.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
                 Y
2020  1.245448e\PYGZhy{}10
2021  1.230127e\PYGZhy{}11
2022  1.350253e\PYGZhy{}10
2023  1.272538e\PYGZhy{}10
2024  1.013413e+00
2025  8.912041e\PYGZhy{}02
2026  9.972999e\PYGZhy{}02
2027 \PYGZhy{}8.856609e\PYGZhy{}01
2028  3.820072e\PYGZhy{}02
2029  3.020152e\PYGZhy{}02
2030  1.576184e\PYGZhy{}02
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.difpctlevel \sphinxhyphen{} the percent change in the level of the variable.}
\label{\detokenize{content/05_SimpleModel/SimpleModel:difpctlevel-the-percent-change-in-the-level-of-the-variable}}
\sphinxAtStartPar
In this case \sphinxcode{\sphinxupquote{msim{[}'Y'{]}.difpct.mul100.df}} returns the percent change in the level of the variable Y.

\sphinxAtStartPar
Mathematically it is \(\bigg( {X^{lastdf}\over X^{basedf}}-1 \bigg)*100\)

\sphinxAtStartPar
Or as modelers often call it the impulse response function following a shock.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y CPBV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{df}

\PYG{c+c1}{\PYGZsh{}print((msim.lastdf[\PYGZsq{}Y\PYGZsq{}]/msim.basedf[\PYGZsq{}Y\PYGZsq{}]\PYGZhy{}1)*100)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
                 Y
2020  6.834967e\PYGZhy{}10
2021  6.950156e\PYGZhy{}10
2022  8.232579e\PYGZhy{}10
2023  9.441284e\PYGZhy{}10
2024  9.624021e\PYGZhy{}01
2025  1.047847e+00
2026  1.143541e+00
2027  2.929525e\PYGZhy{}01
2028  3.293305e\PYGZhy{}01
2029  3.581004e\PYGZhy{}01
2030  3.731188e\PYGZhy{}01
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Graphics\sphinxhyphen{}based modelflow visualization methods}
\label{\detokenize{content/05_SimpleModel/SimpleModel:graphics-based-modelflow-visualization-methods}}
\sphinxAtStartPar
Instead of adding .df at the end of a comparison command, one can add plot to send the results to a graph.  The results of the calculation and the impact of the sample period commands are the same.

\sphinxAtStartPar
Thus to view a graph of the level difference

\sphinxAtStartPar
 IB Why are these not rendering in the book?

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{pd}\PYG{o}{.}\PYG{n}{options}\PYG{o}{.}\PYG{n}{display}\PYG{o}{.}\PYG{n}{float\PYGZus{}format} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}:.1f\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{format} \PYG{c+c1}{\PYGZsh{} set the decimal points of the axis}


\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Real GDP \PYGZhy{}10 }\PYG{l+s+si}{\PYGZpc{}  hi}\PYG{l+s+s1}{ke in exports}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{colrow}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.5}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Change in the growth rates}
\label{\detokenize{content/05_SimpleModel/SimpleModel:change-in-the-growth-rates}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Real GDP \PYGZhy{} pct change in growth rate}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{colrow}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Real GDP (Pct change from baseline)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{colrow}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This time with multiple charts drawn from a single command

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y CPV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{line}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP and Consumption (pct deviation from baseline)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{colrow}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.Javascript object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Interactive comparisons of results}
\label{\detokenize{content/05_SimpleModel/SimpleModel:interactive-comparisons-of-results}}
\sphinxAtStartPar
When working in jupyter books any of the above commands absent the .df or .plot will generate a widget that displays all of these results both as tables and graphs in different tabs.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msim}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Y CPV}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tab(children=(Tab(children=(HTML(value=\PYGZsq{}\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}utf\PYGZhy{}8\PYGZdq{} standalone=\PYGZdq{}no\PYGZdq{}?\PYGZgt{}\PYGZbs{}n\PYGZlt{}!DOCTYPE svg …
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Using modelflow with World Bank models}

\sphinxstepscope


\chapter{Using \sphinxstyleliteralintitle{\sphinxupquote{modelflow}} with World Bank models}
\label{\detokenize{content/06_WBModels/LoadingWBModel:using-modelflow-with-world-bank-models}}\label{\detokenize{content/06_WBModels/LoadingWBModel::doc}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{Modelflow}} python package has been developed to solve a wide range of models, see the modelflow \DUrole{xref,myst}{gibhub} web site for working examples of the Solow Model, the FR/USB model and others.

\sphinxAtStartPar
The package has been substantially expanded to include special features that enable it to work with World Bank models originally developed in EViews and designed to use EViews Model Object for simuation.

\sphinxAtStartPar
This chapter illustrates how to access these models, how to load them into a \sphinxcode{\sphinxupquote{modelflow}} anaconda environment on your computer and how to perform a variety of simulations


\chapter{Accessing a world bank model}
\label{\detokenize{content/06_WBModels/LoadingWBModel:accessing-a-world-bank-model}}
\sphinxAtStartPar
At this time several World bank macrostructural models are available to download and use with \sphinxcode{\sphinxupquote{modelflow}}.  These include a macrostructural model for:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Indonesia

\item {} 
\sphinxAtStartPar
Nepal

\item {} 
\sphinxAtStartPar
Croatia

\item {} 
\sphinxAtStartPar
Iraq

\item {} 
\sphinxAtStartPar
Kenya

\item {} 
\sphinxAtStartPar
Bolivia

\end{itemize}

\sphinxAtStartPar
Each of these models has been developed as part of the outreach work of the World Bank.  The basic modelling framework of each of these models is outlined in \{cite:p :\sphinxcode{\sphinxupquote{burns\_World\_2019}}\} with specific extensions reflecting features of the individual country modelled.

\sphinxAtStartPar
This book uses as an example a climate aware model for Pakistan developed in 2020 and described in \{cite:p :\sphinxcode{\sphinxupquote{burns\_climate\_2021}} \}.

\sphinxAtStartPar
The World Bank models are distributed in the \sphinxcode{\sphinxupquote{pcim}} file format of the \sphinxcode{\sphinxupquote{modelflow}} and can be downloaded by right clicking on the links above.  The Pakistan model can be downloaded \DUrole{xref,myst}{here} by right clicking on the above link and selecting Save Link as and placing the file on a directory accessible by your \sphinxcode{\sphinxupquote{modelflow}} installation.


\chapter{Preparing your python environment}
\label{\detokenize{content/06_WBModels/LoadingWBModel:preparing-your-python-environment}}
\sphinxAtStartPar
As always, the \sphinxcode{\sphinxupquote{modelflow}} and other python packages that will be used need to be imported into your python session.  The examples here and this book were written and solved in a \sphinxstyleemphasis{Jupyter Notebook}. There are some Jupyter specific commands included in these examples and these are annotated. However, the bulk of the content of the programs can be run in other environments, including Interactive Development Environments (IDE) like \sphinxcode{\sphinxupquote{Spyder}}or \sphinxcode{\sphinxupquote{MS Visual Code}}.  All the programs have been tested under \sphinxcode{\sphinxupquote{spyder}} as well as Jupyter Notebook.

\sphinxAtStartPar
It is assumed that:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
you have already installed \sphinxcode{\sphinxupquote{modelflow}} and its various support packages following the instructions in Chapter xx

\item {} 
\sphinxAtStartPar
you are using Anaconda, and that

\item {} 
\sphinxAtStartPar
you have activated your \sphinxcode{\sphinxupquote{modelflow}} environment by executing the following command from your python command line:

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{activate} \PYG{n}{modelflow}
\end{sphinxVerbatim}

\sphinxAtStartPar
where \sphinxcode{\sphinxupquote{modelflow}} is the name you have given to the \sphinxcode{\sphinxupquote{conda}} environment into which you installed \sphinxcode{\sphinxupquote{modelflow}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} import the model class from modelflow package}
\PYG{k+kn}{from} \PYG{n+nn}{modelclass} \PYG{k+kn}{import} \PYG{n}{model} 
\PYG{k+kn}{import} \PYG{n+nn}{modelmf}       \PYG{c+c1}{\PYGZsh{} Add useful features to pandas dataframes }
                     \PYG{c+c1}{\PYGZsh{} using utlities initially developed for modelflow}

\PYG{n}{model}\PYG{o}{.}\PYG{n}{widescreen}\PYG{p}{(}\PYG{p}{)}   \PYG{c+c1}{\PYGZsh{} These modelflow commands ensure that outputs from modelflow play well with Jupyter Notebook}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{scroll\PYGZus{}off}\PYG{p}{(}\PYG{p}{)}

\PYG{o}{\PYGZpc{}}\PYG{k}{load\PYGZus{}ext} autoreload   
\PYG{o}{\PYGZpc{}}\PYG{k}{autoreload} 2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\chapter{Working with PakMod under modelflow}
\label{\detokenize{content/06_WBModels/LoadingWBModel:working-with-pakmod-under-modelflow}}
\sphinxAtStartPar
The basic method for working with any model is the same. Indeed the initial steps followed here are the same as were followed during the simple model discussion.

\sphinxAtStartPar
Process:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Prepare the workspace

\item {} 
\sphinxAtStartPar
Load the model Modelflow

\item {} 
\sphinxAtStartPar
Design some scenarios

\item {} 
\sphinxAtStartPar
Simulate the model

\item {} 
\sphinxAtStartPar
Visualize the results

\end{enumerate}


\section{Load a pre\sphinxhyphen{}existing model, data and descriptions}
\label{\detokenize{content/06_WBModels/LoadingWBModel:load-a-pre-existing-model-data-and-descriptions}}
\sphinxAtStartPar
To load a model use the \sphinxcode{\sphinxupquote{model.modelload()}} method of \sphinxcode{\sphinxupquote{modelflow}}.

\sphinxAtStartPar
The command below

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{,}\PYG{n}{bline} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{modelload}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M:}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{modelflow}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{modelflow\PYGZhy{}manual}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{papers}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mfbook}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{content}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{models}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pak.pcim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYG{n}{alfa}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{n}{run}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\sphinxAtStartPar
instantiates (creates an instance of) a model object and assigns it to the variable name mpak.  The \sphinxcode{\sphinxupquote{run=1}} option executes the model and assigns the result of the model execution to the dataframe \sphinxcode{\sphinxupquote{baseline}}.  The model is solved with the parameter alfa set to 0.7.  The \(alfa \in (0,1)\) parameter determines the step size of the solution engine. The larger alfa the larger the step size. Larger step sizes solve faster, but may have trouble finding a unique solution.  Smaller step sizes take longer to solve but are more likely to find a unique solution.  Values of alfa=.7 work well for World Bank models.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Replace the path below with the location of the pak.pcim file on your computer}
\PYG{n}{mpak}\PYG{p}{,}\PYG{n}{baseline} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{modelload}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{M:}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{modelflow}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{modelflow\PYGZhy{}manual}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{papers}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{mfbook}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{content}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{models}\PYG{l+s+s1}{\PYGZbs{}}\PYG{l+s+s1}{pak.pcim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,} \PYGZbs{}
                                \PYG{n}{alfa}\PYG{o}{=}\PYG{l+m+mf}{0.7}\PYG{p}{,}\PYG{n}{run}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
file read:  C:\PYGZbs{}Users\PYGZbs{}wb268970\PYGZbs{}OneDrive \PYGZhy{} WBG\PYGZbs{}Ldrive\PYGZbs{}MFM\PYGZbs{}modelflow\PYGZbs{}modelflow\PYGZhy{}manual\PYGZbs{}papers\PYGZbs{}mfbook\PYGZbs{}content\PYGZbs{}models\PYGZbs{}pak.pcim
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{keep}} option instructs \sphinxcode{\sphinxupquote{modelflow}} to maintain in the model object (\sphinxcode{\sphinxupquote{mpak}}) the results of the intitial scenario, assigning it the text name \sphinxcode{\sphinxupquote{Baseline}}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
the variable \sphinxcode{\sphinxupquote{bline}} contains the dataframe with the results of the simulation.  This is distinct from the data that is stored by the \sphinxcode{\sphinxupquote{kept=}} command. That said, the data associated with each, while stored separately, have the same numerical values.
\end{sphinxadmonition}


\section{Variables in World Bank models}
\label{\detokenize{content/06_WBModels/LoadingWBModel:variables-in-world-bank-models}}
\sphinxAtStartPar
A typical World Bank model will have in excess of 300 variables.  Each has a mnemonic that is structured in a specific way, The root for almost all are 14 characters long (some special variables have additional characters appended to this root) (see discussion in section).



\sphinxAtStartPar
where:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Letters
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\hline
\sphinxAtStartPar
CCC
&
\sphinxAtStartPar
The three\sphinxhyphen{}leter ISO code for a country – i.e. IDN for Indonesia, RUS for Russia
\\
\hline
\sphinxAtStartPar
AA
&
\sphinxAtStartPar
The two\sphinxhyphen{}letter major accounting system to which the variable attaches, i.e. NY means National Income Accounts (see below for others)
\\
\hline
\sphinxAtStartPar
MMM
&
\sphinxAtStartPar
The three\sphinxhyphen{}letter major sub\sphinxhyphen{}category of the data \sphinxhyphen{} i.e. GDP, EXP \sphinxhyphen{} expenditure
\\
\hline
\sphinxAtStartPar
NNNN
&
\sphinxAtStartPar
The minor sub\sphinxhyphen{}category \sphinxhyphen{} MKTP for market prices
\\
\hline
\sphinxAtStartPar
U
&
\sphinxAtStartPar
The measure  (K: real variable;C: Current Values; X: Prices)
\\
\hline
\sphinxAtStartPar
C
&
\sphinxAtStartPar
denotes the Currency (N: National currency; D: USD; P: PPP)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Common Accounting systems include


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Code
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\hline
\sphinxAtStartPar
NY
&
\sphinxAtStartPar
National income
\\
\hline
\sphinxAtStartPar
NE
&
\sphinxAtStartPar
National expenditure Accounts
\\
\hline
\sphinxAtStartPar
NV
&
\sphinxAtStartPar
Value added accounts
\\
\hline
\sphinxAtStartPar
GG
&
\sphinxAtStartPar
General Government Accounts
\\
\hline
\sphinxAtStartPar
BX
&
\sphinxAtStartPar
Balance of Payments: Exports
\\
\hline
\sphinxAtStartPar
BM
&
\sphinxAtStartPar
Balance of Payments: Imports
\\
\hline
\sphinxAtStartPar
BN
&
\sphinxAtStartPar
Balance of Payments: Net
\\
\hline
\sphinxAtStartPar
BF
&
\sphinxAtStartPar
Balance of Payments: Financial Account
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Thus


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Mnemonic
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\hline
\sphinxAtStartPar
IDNNYGDPMKTPKN
&
\sphinxAtStartPar
Indonesia GDP at market prices, real in Indonesian Rupiah
\\
\hline
\sphinxAtStartPar
KENNECPNPRVTXN
&
\sphinxAtStartPar
Kenya Private (household) consumption expenditure schillings deflator
\\
\hline
\sphinxAtStartPar
BOLGGEXPGNFSCN
&
\sphinxAtStartPar
Bolivia Government Expenditure on Goods and services (GNFS) in current Bolivars
\\
\hline
\sphinxAtStartPar
HRVGGREVDCITCN
&
\sphinxAtStartPar
Croatia Government Revenues Direct Corporate Income Taxes in current Euros
\\
\hline
\sphinxAtStartPar
NPLBXGSRNFSVCD
&
\sphinxAtStartPar
Nepal BOP Exports of non\sphinxhyphen{}factor services from the  goods and services accounts in current USD
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{Extract a list of variables}
\label{\detokenize{content/06_WBModels/LoadingWBModel:extract-a-list-of-variables}}
\sphinxAtStartPar
To extract a list of all variables matching a pattern, we can use the names function.  Below we ask for a list of all variables for \sphinxstylestrong{PAK}istan \sphinxstylestrong{N}ational \sphinxstylestrong{E}xpenditure accounts \sphinxstylestrong{CON}sumption  \sphinxstylestrong{X}price deflators \sphinxstylestrong{N} in local currency.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstylestrong{Wildcards}
The \sphinxcode{\sphinxupquote{*}} in the command \sphinxcode{\sphinxupquote{mpak{[}'PAKNECON*XN'{]}.names}} is a \sphinxcode{\sphinxupquote{wildcard}} character and the extopression will return all variables that begin PAKNECON and end XN.  the \sphinxcode{\sphinxupquote{?}} is another wildcard expression. It will match only single characters.  Thus \sphinxcode{\sphinxupquote{mpak{[}'PAKNECONPRVT?N'{]}.names}}  would return three variables: \sphinxcode{\sphinxupquote{PAKNECONPRVTKN}}, \sphinxcode{\sphinxupquote{PAKNECONPRVTXN}}, and \sphinxcode{\sphinxupquote{PAKNECONPRVTXN}}.  The real, current value, and deflators for household consumption expenditure.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECON*XN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{names}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}PAKNECONENGYXN\PYGZsq{}, \PYGZsq{}PAKNECONGOVTXN\PYGZsq{}, \PYGZsq{}PAKNECONOTHRXN\PYGZsq{}, \PYGZsq{}PAKNECONPRVTXN\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECONPRVT?N}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{names}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}PAKNECONPRVTCN\PYGZsq{}, \PYGZsq{}PAKNECONPRVTKN\PYGZsq{}, \PYGZsq{}PAKNECONPRVTXN\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\chapter{Behavioural equations in the MFMod framework}
\label{\detokenize{content/06_WBModels/LoadingWBModel:behavioural-equations-in-the-mfmod-framework}}
\sphinxAtStartPar
Recall a behavioural equation determine the value of an endogenous variable. For many of the variables in Wold Bank models, behavioural functions are estimated using an Error Correction Framework that splits the equation into a theoretically determined long run component and a more idiosyncratic short\sphinxhyphen{}run component.


\section{The ECM specification}
\label{\detokenize{content/06_WBModels/LoadingWBModel:the-ecm-specification}}
\sphinxAtStartPar
The ECM approach addresses the above challenge by modelling both the long run relationship and the short run short run behaviour and bringing them together into one equation.

\sphinxAtStartPar
The ECM specification is therefore a single equation comprised of two parts (the long run relationship, and the short\sphinxhyphen{}run relationship).

\sphinxAtStartPar
Consider as an example two variables say consumption and disposable income.  Both have an underlying trend or in the parlance are co\sphinxhyphen{}integrated to degree 1.  For simplicity we call them y an x.


\subsection{The short run relationship}
\label{\detokenize{content/06_WBModels/LoadingWBModel:the-short-run-relationship}}
\sphinxAtStartPar
In its simplest form we might have a short run relationship between the growth rates of our two variables such that:
\begin{equation*}
\begin{split} \Delta log(Y_t) = \alpha + \beta \Delta log(X_t) +\epsilon_t \end{split}
\end{equation*}
\sphinxAtStartPar
or substituting lower case letters for the logged values.
\begin{equation*}
\begin{split} \Delta y_t = \alpha + \beta \Delta x_t +\epsilon_t \end{split}
\end{equation*}

\subsection{The long run equation}
\label{\detokenize{content/06_WBModels/LoadingWBModel:the-long-run-equation}}
\sphinxAtStartPar
The long run relates the level of the two (or more) variables.  We can write a simple version of that equation as:
\begin{equation*}
\begin{split} Y_t=αX_t^β+ \eta_t \end{split}
\end{equation*}
\sphinxAtStartPar
Rewriting this (in logarithms) it can be expressed as:
\begin{equation*}
\begin{split} y_t = ln⁡(α) + βy_t + \eta_t	\end{split}
\end{equation*}

\section{The long run equation in the steady state}
\label{\detokenize{content/06_WBModels/LoadingWBModel:the-long-run-equation-in-the-steady-state}}
\sphinxAtStartPar
First we note that in the steady state the expected value of the error term in the long run equation is zero (\(\eta_t=0 \)) so in those conditions we can simplify the long run relationship to:
\begin{equation*}
\begin{split}y_t=ln⁡(α)+\beta x_t\end{split}
\end{equation*}
\sphinxAtStartPar
or equivalently (substituting A for the log of \(\alpha\)).
\begin{equation*}
\begin{split}y_t-A-βx_t=0\end{split}
\end{equation*}
\sphinxAtStartPar
Moreover if we multiplied this by some arbitrary constant say \(-\lambda\) it would still equal zero.
\begin{equation*}
\begin{split}-\lambda(y_t -A-βx_t)\end{split}
\end{equation*}
\sphinxAtStartPar
and in the steady state this will also be true for the lagged variables
\begin{equation*}
\begin{split}-\lambda(y_{t-1-} A - βx_{t-1})\end{split}
\end{equation*}

\section{Putting it together}
\label{\detokenize{content/06_WBModels/LoadingWBModel:putting-it-together}}
\sphinxAtStartPar
From before we have the short run equation:
\begin{equation*}
\begin{split} \Delta y_t = \alpha + \beta \Delta x_t +\epsilon_t \end{split}
\end{equation*}
\sphinxAtStartPar
Inserting our steady state expression into the short run equation makes no difference (in the long run) because in the long run it is equal to zero.
\begin{equation*}
\begin{split} \Delta y_t = -\lambda(y_{t-1-}A-βx_{t-1})  + \alpha + \beta \Delta x_t +\epsilon_t \end{split}
\end{equation*}
\sphinxAtStartPar
When we are not in the steady state the expression \( y_{t-1}-A-βx_{t-1} \) is of course the error term from the long run equation (a measure of how far we are away from equilibrium).


\subsection{Lamda, the speed of adjustment}
\label{\detokenize{content/06_WBModels/LoadingWBModel:lamda-the-speed-of-adjustment}}
\sphinxAtStartPar
We can then interpret the parameter \$\( \lambda \)\( as the  speed of adjustment.  As long as \)\textbackslash{}lambda\( is greater than zero and less or equal to one if there are no further disturbances ( \)\textbackslash{}epsilon\_t=0\() the expression multiplied by lambda will slowly decline toward zero. How fast depends on how large or small is \)\(\lambda\)\$.

\sphinxAtStartPar
To be convergent \(\lambda\) must be between 0 and 1, if its is negative or greater than one, then the long run portion of the equation will cause the disequilibrium to grow each period (\(\lambda >1) not diminish or oscillate from positive to negative (\)\textbackslash{}lambda <0\$).

\sphinxAtStartPar
Intuitively, the long run error term measures how far we are from equilibrium one period earlier (at t\sphinxhyphen{}1). The ECM term ensures that we will slowly converge to equilibrium – the point at which the long run equation holds exactly. If \$\(\lambda\)\( is greater than zero but less than one (or equal to one) some portion of the previous period year's disequilibrium will be absorbed each year. How much is absorbed depends on the size of estimated speed of the adjustment coefficient \)\textbackslash{}lambda\$. 

\sphinxAtStartPar
Looking at an ECM equation we can then break it up into its component parts.  For the consumption function it will look something like this:
\begin{equation*}
\begin{split} \Delta c_t = -\lambda (\underbrace{
        log(C_{t-1})-log(Wages_{t-1}-Taxes_{t-1}+Transfers_{t-1} + \alpha)}   _\text{Long run}
+\beta \underbrace{\Delta y_t}_\text{short run}\end{split}
\end{equation*}
\sphinxAtStartPar
If we look at the equation for consumption in \sphinxcode{\sphinxupquote{mpak}} we see that it follows something very close to this formulation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{PAKNECONPRVTKN}\PYG{o}{.}\PYG{n}{frml}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Endogeneous: PAKNECONPRVTKN: Household Consumption
Formular: FRML \PYGZlt{}Z,EXO\PYGZgt{} PAKNECONPRVTKN = (PAKNECONPRVTKN(\PYGZhy{}1)*EXP(\PYGZhy{}PAKNECONPRVTKN\PYGZus{}A+ (\PYGZhy{}0.2*(LOG(PAKNECONPRVTKN(\PYGZhy{}1))\PYGZhy{}LOG((PAKNYYWBTOTLCN(\PYGZhy{}1)*(1\PYGZhy{}PAKGGREVDRCTXN(\PYGZhy{}1)/100))/PAKNECONPRVTXN(\PYGZhy{}1)))+1*((LOG((PAKNYYWBTOTLCN*(1\PYGZhy{}PAKGGREVDRCTXN/100))/PAKNECONPRVTXN))\PYGZhy{}(LOG((PAKNYYWBTOTLCN(\PYGZhy{}1)*(1\PYGZhy{}PAKGGREVDRCTXN(\PYGZhy{}1)/100))/PAKNECONPRVTXN(\PYGZhy{}1))))+0.0303228629698929+0.0163839011059956*DURING\PYGZus{}2010\PYGZhy{}0.3*(PAKFMLBLPOLYXN/100\PYGZhy{}((LOG(PAKNECONPRVTXN))\PYGZhy{}(LOG(PAKNECONPRVTXN(\PYGZhy{}1)))))) )) * (1\PYGZhy{}PAKNECONPRVTKN\PYGZus{}D)+ PAKNECONPRVTKN\PYGZus{}X*PAKNECONPRVTKN\PYGZus{}D  \PYGZdl{}

PAKNECONPRVTKN  : Household Consumption
DURING\PYGZus{}2010     : 
PAKFMLBLPOLYXN  : Policy Rate
PAKGGREVDRCTXN  : Effective tax rates
PAKNECONPRVTKN\PYGZus{}A: Add factor:Household Consumption
PAKNECONPRVTKN\PYGZus{}D: Exo dummy:Household Consumption
PAKNECONPRVTKN\PYGZus{}X: Exo value:Household Consumption
PAKNECONPRVTXN  : Household demand
PAKNYYWBTOTLCN  : Economy\PYGZhy{}wide wage bill
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Remember the \sphinxcode{\sphinxupquote{.frml}} method presents the economic equation in a normalized form.

\sphinxAtStartPar
(PAKNECONPRVTKN(\sphinxhyphen{}1)\sphinxstyleemphasis{EXP(\sphinxhyphen{}PAKNECONPRVTKN\_A+ (\sphinxhyphen{}0.2}(LOG(PAKNECONPRVTKN(\sphinxhyphen{}1))\sphinxhyphen{}LOG((PAKNYYWBTOTLCN(\sphinxhyphen{}1)\sphinxstyleemphasis{(1\sphinxhyphen{}PAKGGREVDRCTXN(\sphinxhyphen{}1)/100))/PAKNECONPRVTXN(\sphinxhyphen{}1)))+1}((LOG((PAKNYYWBTOTLCN*(1\sphinxhyphen{}PAKGGREVDRCTXN/100))/PAKNECONPRVTXN))\sphinxhyphen{}(LOG((PAKNYYWBTOTLCN(\sphinxhyphen{}1)\sphinxstyleemphasis{(1\sphinxhyphen{}PAKGGREVDRCTXN(\sphinxhyphen{}1)/100))/PAKNECONPRVTXN(\sphinxhyphen{}1))))+0.0303228629698929+0.0163839011059956}DURING\_2010\sphinxhyphen{}0.3*(PAKFMLBLPOLYXN/100\sphinxhyphen{}((LOG(PAKNECONPRVTXN))\sphinxhyphen{}(LOG(PAKNECONPRVTXN(\sphinxhyphen{}1)))))) )) * (1\sphinxhyphen{}PAKNECONPRVTKN\_D)+ PAKNECONPRVTKN\_X*PAKNECONPRVTKN\_D  \$

\sphinxAtStartPar
Taking logarithms of both sides of the the first expression (excluding the *(1\sphinxhyphen{}PAKNECONPRVTKN\_D) term) and collecting the PAKNECONPRVTKNs onm teh left\sphinxhyphen{}hand side , we can recover the originally estimated ECM expression, where we simplify the mnemonics to ease reading of the equation using:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Model Mnemonic
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Simplified
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
\\
\hline
\sphinxAtStartPar
PAKNECONPRVTKN
&
\sphinxAtStartPar
\(CON^{KN}_t\)
&
\sphinxAtStartPar
Household Consumption
\\
\hline
\sphinxAtStartPar
DURING\_2010
&
\sphinxAtStartPar
\(D^{2010}_t\)
&
\sphinxAtStartPar
A dummy
\\
\hline
\sphinxAtStartPar
PAKFMLBLPOLYXN
&
\sphinxAtStartPar
\(r^{policy}_t\)
&
\sphinxAtStartPar
Policy Rate
\\
\hline
\sphinxAtStartPar
PAKGGREVDRCTXN
&
\sphinxAtStartPar
\(DirectTxR_t\)
&
\sphinxAtStartPar
Direct Taxes: Effective rate
\\
\hline
\sphinxAtStartPar
PAKNECONPRVTKN\_A
&
\sphinxAtStartPar
\(CON^{KN_AF}_t\)
&
\sphinxAtStartPar
Add factor:Household Consumption
\\
\hline
\sphinxAtStartPar
PAKNECONPRVTXN
&
\sphinxAtStartPar
\(CON^{XN}_t\)
&
\sphinxAtStartPar
Household Consumption deflator
\\
\hline
\sphinxAtStartPar
PAKNYYWBTOTLCN
&
\sphinxAtStartPar
\(WAGEBILL^{CN}_t\)
&
\sphinxAtStartPar
Economy\sphinxhyphen{}wide wage bill
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{equation*}
\begin{split}\Delta log(CON^{KN}_t) = -0.2*\bigg[LOG(CON^{KN}_{t-1})-LOG\bigg({{WAGEBILL^{CN}_{t-1}*(1-DirectTxR_{t-1}/100)} \over {CON^{XN}_{t-1}}}\bigg)\bigg] + 1.0*\Delta log \bigg( {{WAGEBILL^{CN}_{t}*(1-DirectTxR_{t}/100)} \over {CON^{XN}_{t}}}\bigg)\end{split}
\end{equation*}\begin{equation*}
\begin{split}+0.030 + 0.016*D^{2010}_t-0.3*\bigg(r^{policy}_t/100-\Delta log(CON^{XN}_{t})\bigg) -CON^{KN_AF}_t \end{split}
\end{equation*}
\sphinxAtStartPar
Where in this instance the short\sphinxhyphen{}run elasticity of consumption to disposable income has been constrained to 1, and teh short run elasticitya of consumption to the real interest rate is 0.3.

\sphinxAtStartPar
 Charl: Something goofy here. It looks like the SR has income elasticity of one imposed – probably why simulations are so jerky. This would be a better example if we has SR elasticity less than one.  Any reason we can’t build this with a less onerous assumption?


\chapter{Scenario analysis}
\label{\detokenize{content/06_WBModels/LoadingWBModel:scenario-analysis}}
\sphinxAtStartPar
An essential feature of a model is that when given a specific set of inputs (the exogenous variables to the model) it will always return the same results. As noted when, as was the case of the load, the model is solved without changing any inputs we would expect that the model will return exactly the same data as before.  To test this for \sphinxcode{\sphinxupquote{mpak}} we can compare the results from the simulation using the \sphinxcode{\sphinxupquote{basedf}} and \sphinxcode{\sphinxupquote{lastdf}} dataframes.

\sphinxAtStartPar
Below we are gratified to see that the percent difference between the variables in the two dataframes following a simulation where the inputs were not changes is zero.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Need statement to change the default format}
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{)}
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      PAKNYGDPMKTPKN  PAKNECONPRVTKN
2020             0.0             0.0
2021             0.0             0.0
2022             0.0             0.0
2023             0.0             0.0
2024             0.0             0.0
2025             0.0             0.0
2026             0.0             0.0
2027             0.0             0.0
2028             0.0             0.0
2029             0.0             0.0
2030             0.0             0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Different kinds of simulations}
\label{\detokenize{content/06_WBModels/LoadingWBModel:different-kinds-of-simulations}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{modelflow}} package allows us to do 4 different kinds of simulations:
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
A shock to an exogenous variable in the model

\item {} 
\sphinxAtStartPar
An exogenous shock of a behavioural variable, executed by exogenizing the variable

\item {} 
\sphinxAtStartPar
An endogenous shock of a behavioural variable, executed by shocking the add factor of the variable.

\item {} 
\sphinxAtStartPar
A mixed shock of a behavioural variable, achieved by temporarily exogenixing the variable.

\end{enumerate}

\sphinxAtStartPar
Although technically modelflow would allow us to shock identities, that would violate their nature as accounting rules so we exclude this possibility.


\subsection{A shock to an exogenous variable}
\label{\detokenize{content/06_WBModels/LoadingWBModel:a-shock-to-an-exogenous-variable}}
\sphinxAtStartPar
A World Bank model will reproduce the same values if inputs (exogenous variables) are not changed.  In the simulation below we change the oil price increasing it by \$25 for the three years between 2025 and 2027 inclusive.

\sphinxAtStartPar
To do this we first create a new input dataframe with the revised data.

\sphinxAtStartPar
Then we use the \sphinxcode{\sphinxupquote{mfcalc}} method to change the value for the three years in question.

\sphinxAtStartPar
Finally we do a but of pandas math to display the initial value, the changed value and the difference between the two, confirming that the mfcalc statement did what we hoped.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}Make a copy of the baseline dataframe}
\PYG{n}{oilshockdf}\PYG{o}{=}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}
\PYG{n}{oilshockdf}\PYG{o}{=}\PYG{n}{oilshockdf}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2025 2027\PYGZgt{} WLDFCRUDE\PYGZus{}PETRO = WLDFCRUDE\PYGZus{}PETRO +25}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{compdf}\PYG{o}{=}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2000}\PYG{p}{:}\PYG{l+m+mi}{2030}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WLDFCRUDE\PYGZus{}PETRO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{compdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LASTDF}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{oilshockdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2000}\PYG{p}{:}\PYG{l+m+mi}{2030}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WLDFCRUDE\PYGZus{}PETRO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\PYG{n}{compdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dif}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{compdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LASTDF}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{compdf}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WLDFCRUDE\PYGZus{}PETRO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{compdf}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      WLDFCRUDE\PYGZus{}PETRO      LASTDF   Dif
2000        28.229719   28.229719   0.0
2001        24.351825   24.351825   0.0
2002        24.927748   24.927748   0.0
2003        28.898903   28.898903   0.0
2004        37.733388   37.733388   0.0
2005        53.391025   53.391025   0.0
2006        64.288259   64.288259   0.0
2007        71.116559   71.116559   0.0
2008        96.990454   96.990454   0.0
2009        61.756922   61.756922   0.0
2010        79.040772   79.040772   0.0
2011       104.009398  104.009398   0.0
2012       105.009629  105.009629   0.0
2013       104.077497  104.077497   0.0
2014        96.235000   96.235000   0.0
2015        50.752778   50.752778   0.0
2016        42.811667   42.811667   0.0
2017        52.805000   52.805000   0.0
2018        56.070279   56.070279   0.0
2019        59.537471   59.537471   0.0
2020        63.219063   63.219063   0.0
2021        67.128311   67.128311   0.0
2022        71.279294   71.279294   0.0
2023        75.686960   75.686960   0.0
2024        80.367180   80.367180   0.0
2025        85.336809  110.336809  25.0
2026        90.613742  115.613742  25.0
2027        96.216983  121.216983  25.0
2028       102.166709  102.166709   0.0
2029       108.484346  108.484346   0.0
2030       115.192643  115.192643   0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Running the simulation}
\label{\detokenize{content/06_WBModels/LoadingWBModel:running-the-simulation}}
\sphinxAtStartPar
Having created a new dataframe comprised of all the old data plus the changed data for the oil price we can execute the simulation.  In the command below, the simulation is run from 2020 to 2040, using the oilshockdf as the input dataframe.  The results of the simulation will be put into a new dataframe \sphinxcode{\sphinxupquote{ExogOilSimul}}.  The \sphinxcode{\sphinxupquote{Keep}} command ensures that the mpak model object stores (keeps) a copy of the results identified by the text name \sphinxstyleemphasis{‘\$25 increase in oil prices 2025\sphinxhyphen{}27’}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{ExogOilSimul} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{oilshockdf}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2040}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZdl{}25 increase in oil prices 2025\PYGZhy{}27}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulates the model }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Using the \sphinxcode{\sphinxupquote{modelflow}} visualization tools we can see the impacts of the shock; as a print out; as charts and within Jupyter notebook as an interactive widget.


\subsubsection{Results}
\label{\detokenize{content/06_WBModels/LoadingWBModel:results}}
\sphinxAtStartPar
Here we confirm that the shock we wanted to introduce was executed. The dif.df method returns the difference between the selected variable(s) as a dataframe, the \sphinxcode{\sphinxupquote{smpl method}} restructs the time period of over which subsequent commands are effectuated.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{)}
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{WLDFCRUDE\PYGZus{}PETRO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      WLDFCRUDE\PYGZus{}PETRO
2020              0.0
2021              0.0
2022              0.0
2023              0.0
2024              0.0
2025             25.0
2026             25.0
2027             25.0
2028              0.0
2029              0.0
2030              0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Below we look at the impact of this change on a few variables, expressed as a percent deviation of the variable from its pre\sphinxhyphen{}shock level.

\sphinxAtStartPar
The first variable \sphinxcode{\sphinxupquote{PAKNYGDPMKTPKN}} is Pakistan’s real GDP, the second \sphinxcode{\sphinxupquote{PAKNECONPRVTKN}} is real consumption and the third is the Consumer price deflator \sphinxcode{\sphinxupquote{PAKNECONPRVTXN}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN PAKNEIMPGNFSKN PAKNECONPRVTXN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{Title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Impact of temporary \PYGZdl{}25 hike in oil prices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{LoadingWBModel_28_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The graphs show the change in the level as a percent of the previous level. The graphs suggest that a temporary \$25 oil price hike would reduce GDP in the first year by about 1.5 percent, that the impact would diminish in the second year to about \sphinxhyphen{}.25 percent and that the impact would turn positive in the fourth year when the price effect was eliminated.The negative impact would on household consumption would be stronger but follow a similar pattern.  The reason that the GDP impact is smaller, is partly because of the impact on imports which decline strongly.  Because imports enter into the GDP identity with a negative sign they reduce the overall impact on GDP.

\sphinxAtStartPar
Finally as could be expected prices rise sharply initially with higher oil prices, but as the slow down in growth is felt, inflationary pressures turn negative and the overall impact on the price level turns negative.  The graph above shows what is happening to the \sphinxstylestrong{price level}. To see the impact on inflation (the rate of growth of prices) we will have to do a separate graph using \sphinxcode{\sphinxupquote{difpct.mul100}}, which shows teh change in the rate of growth of variables where the growth rate is expressed as a per cent.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECONPRVTXN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{Title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Change in inflation from a temporary \PYGZdl{}25 hike in oil prices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{LoadingWBModel_30_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
This view, gives a more nuanced result.  Inflation spikes initially by about 1.2 percent, but falls below as the influence of the slowdown weighs on the lagged effect of higher oil prices. In 2028 when oil prices drop back to their previous level this adds to the dis\sphinxhyphen{}inflationary forces in the economy at first, but the boost to demand fro lower prices soon translates into an acceleration in growth and higher inflation.


\section{An exogenous shock to a Behavioural variable}
\label{\detokenize{content/06_WBModels/LoadingWBModel:an-exogenous-shock-to-a-behavioural-variable}}
\sphinxAtStartPar
Behavioural equations can be de\sphinxhyphen{}activated by exogenizing them, either for the entire simulation period, or for a selected sub period.  In this example we exogenize consumption for the entire simulation period.

\sphinxAtStartPar
To motivate the simulation we assume that a change in weather patterns has increased the number of sunny days by 10 percent which has increased households happiness and therefore causes them to permanently increase their spending by 2.5\% beginning in 2025.

\sphinxAtStartPar
We can do so either by manually or use the method \sphinxcode{\sphinxupquote{.fix()}}. For simplicity we will use \sphinxcode{\sphinxupquote{.fix()}} and we will explain the manual steps that \sphinxcode{\sphinxupquote{.fix()}} does for us.

\sphinxAtStartPar
To exogenize \sphinxcode{\sphinxupquote{PAKNECONPRVTKN}} for the entire simulation period we will first create a new dataframe as a slightly modified version of our basedf.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Cfixed=mpak.fix(mpak.basedf,PAKNECONPRVTKN)}}

\sphinxAtStartPar
This does two things, that we could have done manually.  First it sets the dummy variable \sphinxcode{\sphinxupquote{PAKNECONPRVTKN\_D=1}} for the entire simulation period – effectively transforming the equation to \sphinxcode{\sphinxupquote{PAKNECONPRVTKN=PAKNECONPRVTKN\_X}}.  Then it sets the variable \sphinxcode{\sphinxupquote{PAKNECONPRVTKN\_X}} in the \sphinxcode{\sphinxupquote{Cfixed}} dataframe equal to the value of \sphinxcode{\sphinxupquote{PAKNECONPRVTKN}} in the \sphinxcode{\sphinxupquote{basedf}} dataframe. All the other variables are  just copies of their values in basedf.

\sphinxAtStartPar
With PAKNECONPRVTKN\_D=1 throughout the normal behavioural equation is effctively de\sphinxhyphen{}activated or exogenized.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} reset the active sample period to the full model.}
\PYG{n}{Cfixed}\PYG{o}{=}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{fix}\PYG{p}{(}\PYG{n}{baseline}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Cfixed}\PYG{o}{=}\PYG{n}{Cfixed}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2025 2040\PYGZgt{} PAKNECONPRVTKN\PYGZus{}X = PAKNECONPRVTKN\PYGZus{}X*1.025}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Having made this change we can solve the model, by passing it the new CFixed dataframe.

\sphinxAtStartPar
````CFixedRes = mpak(Cfixed,2020,2040,keep=’2.5\% increase in C 2025\sphinxhyphen{}40’) \# simulates the model ```

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{CFixedRes} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{Cfixed}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2040}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.5}\PYG{l+s+si}{\PYGZpc{} i}\PYG{l+s+s1}{ncrease in C 2025\PYGZhy{}40}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulates the model }
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN PAKNEIMPGNFSKN PAKNECONPRVTXN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{Title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Impact of temporary \PYGZdl{}25 hike in oil prices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{LoadingWBModel_37_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2040}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN PAKNEIMPGNFSKN PAKNECONPRVTXN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{df}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      PAKNYGDPMKTPKN  PAKNECONPRVTKN  PAKNEIMPGNFSKN  PAKNECONPRVTXN
2020    2.019308e\PYGZhy{}08        0.000000    2.808458e\PYGZhy{}08    1.841915e\PYGZhy{}08
2021   \PYGZhy{}3.899954e\PYGZhy{}10        0.000000   \PYGZhy{}7.528570e\PYGZhy{}10    8.995251e\PYGZhy{}09
2022   \PYGZhy{}4.075578e\PYGZhy{}09        0.000000    7.531269e\PYGZhy{}09    1.598160e\PYGZhy{}08
2023    8.030444e\PYGZhy{}09        0.000000    2.254740e\PYGZhy{}08    2.550616e\PYGZhy{}08
2024   \PYGZhy{}3.040945e\PYGZhy{}09        0.000000    3.364358e\PYGZhy{}08    4.579471e\PYGZhy{}08
2025    1.857821e+00        2.500000    2.111848e+00    6.547200e\PYGZhy{}01
2026    1.838869e+00        2.500000    2.294774e+00    1.600744e+00
2027    1.723747e+00        2.500000    2.558362e+00    2.608787e+00
2028    1.557530e+00        2.500000    2.919366e+00    3.608118e+00
2029    1.369944e+00        2.500000    3.367783e+00    4.563919e+00
2030    1.173879e+00        2.500000    3.876162e+00    5.450966e+00
2031    1.801835e\PYGZhy{}01        1.379063    3.474070e+00    5.958611e+00
2032   \PYGZhy{}4.200807e\PYGZhy{}01        0.766517    3.436773e+00    6.078175e+00
2033   \PYGZhy{}6.087119e\PYGZhy{}01        0.634926    3.727205e+00    5.965989e+00
2034   \PYGZhy{}5.874626e\PYGZhy{}01        0.705209    4.098433e+00    5.750784e+00
2035   \PYGZhy{}5.214086e\PYGZhy{}01        0.775985    4.373174e+00    5.490850e+00
2036   \PYGZhy{}4.690272e\PYGZhy{}01        0.789340    4.507495e+00    5.203244e+00
2037   \PYGZhy{}4.311355e\PYGZhy{}01        0.761726    4.524331e+00    4.894436e+00
2038   \PYGZhy{}3.945717e\PYGZhy{}01        0.722178    4.460112e+00    4.573111e+00
2039   \PYGZhy{}3.516112e\PYGZhy{}01        0.687414    4.342588e+00    4.250741e+00
2040   \PYGZhy{}3.019698e\PYGZhy{}01        0.661382    4.189132e+00    3.938522e+00
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The permanent rise in consumption by 2.5 percent causes a temporary increase in GDP of close to 2\% (1.86). Higher imports tend to diminish the effect on GDP, while over time higher prices due to the inflationary pressures caused by the additional demand cause the GDP impact to diminish to close to zero by th end of the sample period.


\section{Temporarily exogenize a behavioural variable}
\label{\detokenize{content/06_WBModels/LoadingWBModel:temporarily-exogenize-a-behavioural-variable}}
\sphinxAtStartPar
The third method of formulating a scenario involves temporarily exogenizing a variable.    The methodology is the same except the period for which the variable is exogenized is different.

\sphinxAtStartPar
To fully explore the differences in the approaches, we will do three scenarios.
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
We exogenize the variable for the whole period, but shock it for three years (2025\sphinxhyphen{}2027).

\item {} 
\sphinxAtStartPar
We exogenize the variable for the whole period, but shock it for three years (2025\sphinxhyphen{}2027)– but use the –kg option to keep the growth rates of the exogenized variable the same in the post\sphinxhyphen{}shock period

\item {} 
\sphinxAtStartPar
We exogenize the variable only for the period during which we shock the dependent variable (2025\sphinxhyphen{}2027)

\end{enumerate}


\subsection{Temporary shock exogenized for the whole period}
\label{\detokenize{content/06_WBModels/LoadingWBModel:temporary-shock-exogenized-for-the-whole-period}}
\sphinxAtStartPar
Here the set up is basically the same as before.

\sphinxAtStartPar
mpak.smpl() \# reset the active sample period to the full model.
Cfixed=mpak.fix(baseline,’PAKNECONPRVTKN’)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} reset the active sample period to the full model.}
\PYG{n}{CTempExogAll}\PYG{o}{=}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{fix}\PYG{p}{(}\PYG{n}{baseline}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{CTempExogAll}\PYG{o}{=}\PYG{n}{CTempExogAll}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2025 2027\PYGZgt{} PAKNECONPRVTKN\PYGZus{}X = PAKNECONPRVTKN*1.025}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Now we solve the model}
\PYG{n}{CTempXAllRes} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{CTempExogAll}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2040}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.5}\PYG{l+s+si}{\PYGZpc{} i}\PYG{l+s+s1}{ncrease in C 2025\PYGZhy{}27 \PYGZhy{}\PYGZhy{} exog whiole period}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulates the model }
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN PAKNEIMPGNFSKN PAKNECONPRVTXN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{Title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Impact of temporary \PYGZdl{}25 hike in oil prices}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{LoadingWBModel_41_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here the results are quite different.  GDP is boosted initially as before but when consumption drops back to its pre\sphinxhyphen{}shock level, GDP and imports decline sharply.

\sphinxAtStartPar
Prices (and inflation) are higher initially but when the economy starts to slow after 2025 prices start to fall (disinflation).


\subsection{Temporary shock exogenized for the whole period}
\label{\detokenize{content/06_WBModels/LoadingWBModel:id1}}
\sphinxAtStartPar
In this scenario we do exactly the same as in the previous but we use the –KG option in the mfcalc to maintain the pre\sphinxhyphen{}shock growth rates of consumption in the post\sphinxhyphen{}shock period.

\sphinxAtStartPar
The set up is identical to the rpeceiding simulation except for the additional –kg optionin the mfcalc call.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} reset the active sample period to the full model.}
\PYG{n}{CTempExogAllKG}\PYG{o}{=}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{fix}\PYG{p}{(}\PYG{n}{baseline}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{CTempExogAllKG}\PYG{o}{=}\PYG{n}{CTempExogAllKG}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2025 2027\PYGZgt{} PAKNECONPRVTKN\PYGZus{}X = PAKNECONPRVTKN\PYGZus{}X*1.025 \PYGZhy{}\PYGZhy{}kg}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{c+c1}{\PYGZsh{}Now we solve the model}
\PYG{n}{CTempXAllResKG} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{CTempExogAllKG}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2040}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2.5}\PYG{l+s+si}{\PYGZpc{} i}\PYG{l+s+s1}{ncrease in C 2025\PYGZhy{}27 \PYGZhy{}\PYGZhy{} exog whole period \PYGZhy{}\PYGZhy{}keep\PYGZus{}growth=TRUE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulates the model }
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN PAKNEIMPGNFSKN PAKNECONPRVTXN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{Title}\PYG{o}{=}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{2.5}\PYG{l+s+s2}{\PYGZpc{}}\PYG{l+s+s2}{ boost o cons 2025\PYGZhy{}27 \PYGZhy{}\PYGZhy{}keep growth=true}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{LoadingWBModel_44_0}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{alternative} \PYG{o}{=} \PYG{n}{alternative\PYGZus{}base}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}2023 2023\PYGZgt{} PAKGGREVGNFSCN\PYGZus{}X + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{baseline}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKNYGDPMKTPCN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.01} \PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gt}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{n+ne}{NameError}\PYG{g+gWhitespace}{                                 }Traceback (most recent call last)
\PYG{n+nn}{Input In [18],} in \PYG{n+ni}{\PYGZlt{}cell line: 1\PYGZgt{}}\PYG{n+nt}{()}
\PYG{n+ne}{\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZhy{}\PYGZgt{} }\PYG{l+m+mi}{1} \PYG{n}{alternative} \PYG{o}{=} \PYG{n}{alternative\PYGZus{}base}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}2023 2023\PYGZgt{} PAKGGREVGNFSCN\PYGZus{}X + }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{baseline}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKNYGDPMKTPCN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mf}{0.01} \PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n+ne}{NameError}: name \PYGZsq{}alternative\PYGZus{}base\PYGZsq{} is not defined
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The variable before and after the shock can be
displayed

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Value of GDP in 2023: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{baseline}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKNYGDPMKTPCN}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s1}{,.0f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Base value in 2023: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{alternative\PYGZus{}base}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKGGREVGNFSCN\PYGZus{}X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s1}{,.0f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{. Alternative value: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{alternative}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKGGREVGNFSCN\PYGZus{}X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{l+s+si}{:}\PYG{l+s+s1}{,.0f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}
    \PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Difference: }\PYG{l+s+si}{\PYGZob{}}\PYG{o}{\PYGZhy{}}\PYG{p}{(}\PYG{n}{alternative\PYGZus{}base}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKGGREVGNFSCN\PYGZus{}X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{\PYGZhy{}}\PYG{n}{alternative}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{PAKGGREVGNFSCN\PYGZus{}X}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}\PYG{l+s+si}{:}\PYG{l+s+s1}{,.0f}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{.}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Simulate the model}
\label{\detokenize{content/06_WBModels/LoadingWBModel:simulate-the-model}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} notebook 
\PYG{n}{result} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{alternative}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2035}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Taxes on Goods and Services up by 1 pct of GDP in 2023}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulates the model }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Access results}
\label{\detokenize{content/06_WBModels/LoadingWBModel:access-results}}
\sphinxAtStartPar
Now we have two dataframes with results \sphinxcode{\sphinxupquote{baseline}} and \sphinxcode{\sphinxupquote{result}}. These dataframes can be manipulated and visualized
with the tools provided by the \sphinxstylestrong{pandas} library and other like \sphinxstylestrong{Matplotlib} and \sphinxstylestrong{Plotly}. However to make things easy the first and
latest simulation result is also in the mpak object:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{mpak.basedf}: Dataframe with the values for baseline

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{mpak.lastdf}: Dataframe with the values for alternative

\end{itemize}

\sphinxAtStartPar
The result can easily be visualized in Jupyter notebooks by using the \sphinxcode{\sphinxupquote{{[}.{]}}} operator this will display the values of the variables in square brackets and useful
transformations of the values including the impact. In addition the exotenous variables which has changed are displayed.

\sphinxAtStartPar
\sphinxstylestrong{Click on the tabs to display the different output}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN PAKNYGDPMKTPKN PAKGGEXPTOTLCN PAKGGREVTOTLCN PAKNECONGOVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Or use keep\_plot to make more bespoken charts which can be saved  in many formats}
\label{\detokenize{content/06_WBModels/LoadingWBModel:or-use-keep-plot-to-make-more-bespoken-charts-which-can-be-saved-in-many-formats}}
\sphinxAtStartPar
This method can display a number of different transformations of the series for more \sphinxhref{./create\_save\_scenarios.ipynb\#.keep\_plot()--Function-to-visualize-the-keept-solutions}{here}
Here only a few:


\subsection{Differences of growth rates}
\label{\detokenize{content/06_WBModels/LoadingWBModel:differences-of-growth-rates}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{keep\PYGZus{}plot}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN PAKGGEXPTOTLCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{diff}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{showtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{growth}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{savefig}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testgraph/tax\PYGZus{}impact\PYGZus{}growth\PYGZus{}.svg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{legend}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Differences in percent of baseline values}
\label{\detokenize{content/06_WBModels/LoadingWBModel:differences-in-percent-of-baseline-values}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{keep\PYGZus{}plot}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN PAKGGEXPTOTLCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{diffpct}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{showtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{level}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{savefig}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{testgraph/tax\PYGZus{}impact\PYGZus{}difpct\PYGZus{}.svg}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{legend}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Some variations on keep\_plot(}
\label{\detokenize{content/06_WBModels/LoadingWBModel:some-variations-on-keep-plot}}
\sphinxAtStartPar
The \sphinxstylestrong{variables} we want to be displayed is listed as first argument. Variable names can include
wildcards (using * for any string and ? for any character)

\sphinxAtStartPar
\sphinxstylestrong{Transformation of data displayed:}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
showtype=
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Use this operator
\\
\hline
\sphinxAtStartPar
‘level’ (default)
&
\sphinxAtStartPar
No transformation
\\
\hline
\sphinxAtStartPar
‘growth’
&
\sphinxAtStartPar
The growth rate  in percent
\\
\hline
\sphinxAtStartPar
‘change’
&
\sphinxAtStartPar
The yearly change (\(\Delta\))
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxstylestrong{legend placement}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
legend=
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Use this operator
\\
\hline
\sphinxAtStartPar
False (default)
&
\sphinxAtStartPar
The legends will be placed at the end of the corresponding line
\\
\hline
\sphinxAtStartPar
True
&
\sphinxAtStartPar
The legends are places in a legend box
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
Often it is useful to compare the scenario results with the baseline result. This is done with the diff argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
diff=
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Use this operator
\\
\hline
\sphinxAtStartPar
False (default)
&
\sphinxAtStartPar
All entries in the keep\_solution dictionary is displayed
\\
\hline
\sphinxAtStartPar
True
&
\sphinxAtStartPar
The difference to the first entry is shown.
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
It can also be useful to compare the scenario results with the baseline result \sphinxstylestrong{measured in percent}. This is done with the diffpct argument.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
diffpct=
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Use this operator
\\
\hline
\sphinxAtStartPar
False (default)
&
\sphinxAtStartPar
All entries in the keep\_solution dictionary is displayed
\\
\hline
\sphinxAtStartPar
True
&
\sphinxAtStartPar
The difference in percent to the first entry is shown
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{savefig='{[}path/{]}<prefix>.<extension>'}}
Will create a number of files with the charts.
The files will be saved location with name \sphinxcode{\sphinxupquote{<path>/<prefix><variable name>.<extension>}} The extension determines the
format of the saved file. pdf, svg and png are the most common extensions.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
!dir testgraph\PYGZbs{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} fixed\PYGZus{}alternative = mpak.fix(alternative,\PYGZsq{}PAKGGEXPCAPTCN PAKGGEXPGNFSCN PAKGGEXPOTHRCN PAKGGEXPTRNSCN\PYGZsq{},2023,2035)}
\PYG{n}{fixed\PYGZus{}alternative} \PYG{o}{=} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{fix}\PYG{p}{(}\PYG{n}{alternative}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGEXPCAPTCN }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+m+mi}{2023}\PYG{p}{,}\PYG{l+m+mi}{2035}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result\PYGZus{}fixed\PYGZus{}expenditure} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{fixed\PYGZus{}alternative}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2035}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Taxes on Goods and Services up, expenditure fixed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{silent}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{n}{first\PYGZus{}test}\PYG{o}{=}\PYG{l+m+mi}{60}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulates the model }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{fix\PYGZus{}dummy\PYGZus{}fixed}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN PAKNYGDPMKTPKN PAKGGEXPTOTLCN PAKGGREVTOTLCN PAKNECONGOVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{keep\PYGZus{}solutions}\PYG{o}{.}\PYG{n}{keys}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{keepswitch}\PYG{p}{(}\PYG{n}{scenarios}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Taxes on Goods and Services up by 1 pct of GDP in 2023|Taxes on Goods and Services up, expenditure fixed}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{keep\PYGZus{}plot}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN PAKNYGDPMKTPKN PAKGGEXPTOTLCN PAKGGREVTOTLCN PAKNECONGOVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{diff}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{showtype}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{level}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{legend}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}






\renewcommand{\indexname}{Index}
\printindex
\end{document}