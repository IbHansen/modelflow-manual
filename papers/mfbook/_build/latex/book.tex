%% Generated by Sphinx.
\def\sphinxdocclass{jupyterBook}
\documentclass[letterpaper,10pt,english]{jupyterBook}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax
\ifdefined\pdfimageresolution
    \pdfimageresolution= \numexpr \dimexpr1in\relax/\sphinxpxdimen\relax
\fi
%% let collapsible pdf bookmarks panel have high depth per default
\PassOptionsToPackage{bookmarksdepth=5}{hyperref}
%% turn off hyperref patch of \index as sphinx.xdy xindy module takes care of
%% suitable \hyperpage mark-up, working around hyperref-xindy incompatibility
\PassOptionsToPackage{hyperindex=false}{hyperref}
%% memoir class requires extra handling
\makeatletter\@ifclassloaded{memoir}
{\ifdefined\memhyperindexfalse\memhyperindexfalse\fi}{}\makeatother

\PassOptionsToPackage{warn}{textcomp}

\catcode`^^^^00a0\active\protected\def^^^^00a0{\leavevmode\nobreak\ }
\usepackage{cmap}
\usepackage{fontspec}
\defaultfontfeatures[\rmfamily,\sffamily,\ttfamily]{}
\usepackage{amsmath,amssymb,amstext}
\usepackage{polyglossia}
\setmainlanguage{english}



\setmainfont{FreeSerif}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Italic,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldItalic
]
\setsansfont{FreeSans}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]
\setmonofont{FreeMono}[
  Extension      = .otf,
  UprightFont    = *,
  ItalicFont     = *Oblique,
  BoldFont       = *Bold,
  BoldItalicFont = *BoldOblique,
]



\usepackage[Bjarne]{fncychap}
\usepackage[,numfigreset=1,mathnumfig]{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\contentsname}{Introduction}}

\usepackage{sphinxmessages}



        % Start of preamble defined in sphinx-jupyterbook-latex %
         \usepackage[Latin,Greek]{ucharclasses}
        \usepackage{unicode-math}
        % fixing title of the toc
        \addto\captionsenglish{\renewcommand{\contentsname}{Contents}}
        \hypersetup{
            pdfencoding=auto,
            psdextra
        }
        % End of preamble defined in sphinx-jupyterbook-latex %
        

\title{MFMod models in Python with ModelFlow}
\date{Apr 02, 2023}
\release{}
\author{Andrew Burns and Ib Hansen}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{introduction::doc}}


\sphinxAtStartPar
Andrew Burns and Ib hansen

\sphinxstepscope


\part{Introduction}

\sphinxstepscope


\chapter{Introduction}
\label{\detokenize{content/01_Introduction/Introduction:introduction}}\label{\detokenize{content/01_Introduction/Introduction::doc}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
This Jupyter Book is work in progress.
\end{sphinxadmonition}

\sphinxAtStartPar
This paper describes the implementation of the World Bank’s MacroFiscalModel (MFMod) {[}\hyperlink{cite.content/litterature:id15}{BCJ+19}{]} in the open source solution program ModelFlow (\sphinxhref{https://ibhansen.github.io/doc/index}{Hansen, 2023}).


\section{Background}
\label{\detokenize{content/01_Introduction/Introduction:background}}
\sphinxAtStartPar
The impetus for this paper and the work that it summarizes was to make available to a wider constituency the work that the Bank has done over the past several decades to disseminate Macro\sphinxhyphen{}structural models%
\begin{footnote}[1]\sphinxAtStartFootnote
Economic modelling has a long tradition at the World Bank.  The Bank has had a long\sphinxhyphen{}standing involvement in CGE modeling is the World Bank {[}\hyperlink{cite.content/litterature:id19}{DJ13}{]}, indeed the popular mathematics package GAMS, which is widely used to solve CGE and Linear Programming models, \sphinxhref{https://www.gams.com/about/company/}{started out} as a project begun at the World Bank in the 1970s.
%
\end{footnote} – notably those that form part of its MFMod (MacroFiscalModel) framework.

\sphinxAtStartPar
MFMod is the World Bank’s work\sphinxhyphen{}horse macro\sphinxhyphen{}structural economic modelling framework. It exists as a linked system of 184 country specific models that can be solved either independently or as a larger system. The MFMod system replaced the Bank’s RMSIM\sphinxhyphen{}X model \{cite\}p:\sphinxcode{\sphinxupquote{addison\_world\_2019}} \sphinxstylestrong{not in the bib file}  and evolved from earlier macro\sphinxhyphen{}structural models developed by the Bank during the 2000s to strengthen the basis for the forecasts produced by the World Bank.

\sphinxAtStartPar
Some examples of these models were released on the World Bank’s isimulate platform early in 2010 along with several CGE models dating from this period.

\sphinxAtStartPar
Beginning in 2015, the core model that was developed for the isimulate platform was developed and extended substantially into the main MFMod (MacroFiscalModel) model that is used today for the World Bank’s twice annual forecasting exercise \sphinxhref{https://www.worldbank.org/en/publication/macro-poverty-outlook}{The Macro Poverty Outlook}.  This model continues to evolve and be used as the workhorse forecasting and policy simulation model of the World Bank.


\section{Early steps to bring the MFMod system to the broader economics community}
\label{\detokenize{content/01_Introduction/Introduction:early-steps-to-bring-the-mfmod-system-to-the-broader-economics-community}}
\sphinxAtStartPar
Bank staff were quick to recognize that the models built for its own needs could be of use to the broader economics community. An initial project \sphinxcode{\sphinxupquote{isimulate}} in 2007 made several versions of this earlier model available for simulation on the \sphinxhref{https://isimulate.worldbank.org}{isimulate platform}, and these models continue to be available there.  The isimulate platform housed (and continues to house) public access to earlier versions of the MFMod system, and allows simulation of these and other models – but does not give researchers access to the code or the ability to construct complex simulations.

\sphinxAtStartPar
In another effort to make models widely available a large number (more than 60 as of June 2023) customized stand\sphinxhyphen{}alone models (collectively known as called MFModSA \sphinxhyphen{} MacroFiscalModel StandAlones)  have been developed from the main model. Typically developed for a country\sphinxhyphen{}client (Ministry of Finance, Economy or Planning or Central Bank), these Stand Alones extend the standard model by incorporating additional details not in the standard model that are of specific import to different economies and the country\sphinxhyphen{}clients for whom they were built, including: a more detailed breakdown of the sectoral make up of an economy, more detailed fiscal and monetary accounts, and other economically important features of the economy that may exist only inside the aggregates of the standard model.

\sphinxAtStartPar
Training and dissemination around these customized versions of MFMod have been ongoing since 2013. In addition to making customized models available to client governments, Bank teams have run technical assistance program designed to train government officials in the use of these models and their maintenance, modification and revision.


\subsection{Climate change and the MFMod system}
\label{\detokenize{content/01_Introduction/Introduction:climate-change-and-the-mfmod-system}}
\sphinxAtStartPar
Most recently, the Bank has extended the standard MFMod framework to incorporate the main features of climate change ({[}\hyperlink{cite.content/litterature:id14}{BJS21a}{]})– both in terms of the impact of the economy on climate (principally through green\sphinxhyphen{}house gas emissions, like \(CO_2, N_{2}O, CH_4, ...\)) and the impact of the changing climate on the economy (higher temperatures, changes in rainfall quantity and variability, increased incidence of extreme weather) and their impacts on the economy (agricultural output, labor productivity, physical damages due to extreme weather events, sea\sphinxhyphen{}level rises etc.).

\sphinxAtStartPar
These climate enhanced versions of MFMod serve as one of the two main modelling systems (along with the Bank’s MANAGE CGE system) in the World Bank’s \sphinxhref{https://www.worldbank.org/en/publication/country-climate-development-reports}{Country Climate Development Reports}


\section{Moving the framework to an open\sphinxhyphen{}source footing}
\label{\detokenize{content/01_Introduction/Introduction:moving-the-framework-to-an-open-source-footing}}
\sphinxAtStartPar
Models in the MFMod family are normally built using the proprietary \sphinxhref{https://www.eviews.com}{EViews} econometric and modelling package. While offering many advantages for model development and maintenance, its cost may be a barrier to clients in developing countries.  As a result, the World Bank joined with Ib Hansen, a Danish economist formerly with the European Central Bank and the Danish Central Bank, who over the years has developed \sphinxcode{\sphinxupquote{modelflow}} a generalized solution engine written in Python for economic models. Together with World Bank, Hansen has worked to extend \sphinxcode{\sphinxupquote{modelflow}} so that MFMod models can be ported and run in the framework.

\sphinxAtStartPar
This paper reports on the results of these efforts. In particular, it provides step by step instructions on how to install the \sphinxcode{\sphinxupquote{modelflow}} framework, import a World Bank macrostructural model,  perform simulations with that model and report results using the many analytical and reporting tools that have been built into \sphinxcode{\sphinxupquote{modelflow}}.  It is not a manual for \sphinxcode{\sphinxupquote{modelflow}}, such a manual can be found \sphinxhref{https://ibhansen.github.io/doc/index}{here} nor is it documentation for the MFMod system, such documentation can be found here \hyperlink{cite.content/litterature:id15}{Burns \sphinxstyleemphasis{et al.}} and here {[}\hyperlink{cite.content/litterature:id18}{BJS21b}{]}, {[}\hyperlink{cite.content/litterature:id14}{BJS21a}{]}). Nor is it documentation for the specific models described and worked with below.


\bigskip\hrule\bigskip


\sphinxstepscope


\part{Macrostructural Models}

\sphinxstepscope


\chapter{Macrostructural models}
\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels:macrostructural-models}}\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels::doc}}
\sphinxAtStartPar
The economics profession uses a wide range of models for different purposes.  Macro\sphinxhyphen{}structural models (also known as semi\sphinxhyphen{}structural or Macro\sphinxhyphen{}econometric models) are a class of models that seek to summarize the most important interconnections and determinants of an economy. Computable General Equilibrium (CGE), and Dynamic Stochastic General Equilibrium (DSGE) models are other classes of models that also seek, using somewhat different methodologies, to capture the main economic channels by which the actions of agents (firms, households, governments) interact and help determine the structure, level and rate of growth of economic activity in an economy. Olivier Blanchard, former Chief Economist at the International Monetary Fund, in a series of articles published between 2016 and 2018 that were summarized in {[}\hyperlink{cite.content/litterature:id17}{Bla18}{]}. In these articles he lays out his views on the relative strengths and weaknesses of each of these systems, concluding that each has a role to play in helping economists analyze the macro\sphinxhyphen{}economy.

\sphinxAtStartPar
Typically organizations, including the World Bank, use all of these tools, privileging one or the other for specific purposes. Macrostructural models like the MFMod framework are widely used by Central Banks, Ministries of Finance; and professional forecasters both for the purposes of generating forecasts and policy analysis.


\section{A system of equations}
\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels:a-system-of-equations}}
\sphinxAtStartPar
Macro\sphinxhyphen{}structural models are a system of equations comprised of two kinds of equations and three kinds of variables.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Identities}} are variables that are determined by a well defined accounting rule that always holds. The famous GDP Identity Y=C+I+G+(X\sphinxhyphen{}M) is one such identity, that indicates that GDP at market prices is definitionally equal to Consumption plus Investment plus Government spending plus Exports less Imports.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Behavioural}} variables are determined by equations that typically attempt to summarize an economic (vs accounting) relationship. Thus, the equation that says real C = f(Disposable Income,the price level, and animal spirits) is a behavioural equation – where the relationship is drawn from economic theory. Because these equations do not fully explain the variation in the dependent variable and the sensitivities of variables to the changes in other variables are uncertain, these equations and their parameters are  typically estimated econometrically and are subject to error.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Exogenous}} variables are not determined by the model. Typically there are set either by assumption or from data external to the model.  For an individual country model, would often be set as an exogenous variable because the level of activity of the economy itself is unlikely to affect the world price of oil.

\end{itemize}

\sphinxAtStartPar
In a fully general form it can be written as:
\begin{align*}
y_t^1  &=  f^1(y_{t+u}^1...,y_{t+u}^n...,y_t^2...,y_{t}^n...y_{t-r}^1...,y_{t-r}^n,x_t^1...x_{t}^k,...x_{t-s}^1...,x_{t-s}^k) \\
y_t^2  &=  f^2(y_{t+u}^1...,y_{t+u}^n...,y_t^1...,y_{t}^n...y_{t-r}^1...,y_{t-r}^n,x_t^1...x_{t}^k,...x_{t-s}^1...,x_{t-s}^k) \\
\vdots \\
y_t^n  &=  f^n(y_{t+u}^1...,y_{t+u}^n...,y_t^1...,y_{t}^{n-1}...y_{t-r}^1...,y_{t-r}^n,x_t^1...x_{t}^r,x..._{t-s}^1...,x_{t-s}^k)
\end{align*}
\sphinxAtStartPar
where \( y_t^1 \) is one of n endogenous variables and \(x_t^1\) is an exogenous variable and there are as many equations as there are unknown (endogenous variables).

\sphinxAtStartPar
Rewritten for our GDP identity and substituting the variable mnemonics Y,C,I,G,X,M we could write a simple model as a system of 6 equations in 6 unknowns:
\begin{align*}
Y_t  &=  C_t+I_t+G+t+ (X_t-M_t) \\
C_t &= c_t(C_{t-1},C_{t-2},I_t,G_t,X_t,M_t,P_t)\\
I_t &= c_t(I_{t-1},I_{t-2},C_t,G_t,X_t,M_t,P_t)\\
G_t &= c_t(G_{t-1},G_{t-2},C_t,I_t,X_t,M_t,P_t)\\
X_t &= c_t(X_{t-1},X_{t-2},C_t,I_t,G_t,M_t,P_t,P^f_t)\\
M_t &= c_t(M_{t-1},M_{t-2},C_t,I_t,G_t,X_t,P_t,P^f_t)
\end{align*}
\sphinxAtStartPar
and where \(P_t, P^f_t\) domestic and foreign prices respectively are exogenous in this simple model.


\section{Behavioural equations}
\label{\detokenize{content/02_MacrostructuralModels/MacroStructuralModels:behavioural-equations}}
\sphinxAtStartPar
Behavioural equations in a macrostructural equation are typically estimated. In MFMod they are often expressed in Error Correction form. In this approach the behaviour of the dependent variable (say Consumption) is assumed to be the joint product of a long\sphinxhyphen{}term economic relationship – usually drawn from economic theory, and various short\sphinxhyphen{}run influences which can be more ad hoc in nature. The ECM formulation has the advantage of tieing down the long run behavior of the economy to economic theory, while allowing its short\sphinxhyphen{}run dynamics (where short\sphinxhyphen{}run can in some cases be 5 or more years) to reflect the way the economy actually operates (not how textbooks say it should behave).

\sphinxAtStartPar
For the consumption equation, utility maximization subject to a budget constraint might lead us to define a long run relationship like this economic theory might lead us to something like this:
\begin{equation*}
\begin{split} C_t = \alpha + \beta_1{{rK_t + WB_{t} + GTR_{t}(1-\tau^{Direct})}\over {PC_t}}-\beta_3(r_t-\dot{p}_t) +\eta_t\end{split}
\end{equation*}
\sphinxAtStartPar
Where in the long run consumption (\(C_t\)) for a given interest rate is a stable share of real disposable income (\({{rK_t + WB_{t} + GTR_{t}}\over {PC_t}})\), implying a constant savings rate. And where real disposable income is given by interest earned on capital (\(rK_t\)) plus earnings from labour (\(WB_{t}\)) + Government transfers to households (\(GTR_{t}\)) multiplied by 1 less the direct  rate (\(\tau^{Direct}\)).  The final term reflects the influence of real interest rates on final consumption, such that as real interest rates rise consumption as a share of disposable income declines (the savings rate rises).

\sphinxAtStartPar
Replacing the expression following \(\beta\) with \(Y^{disp}_t\), the above simplifies and can be rewritten as:
\begin{equation*}
\begin{split} C_t= (\alpha + \beta_1{Y^{disp}_t}-\beta_3(r_t-\dot{p}_t))\end{split}
\end{equation*}
\sphinxAtStartPar
and dividing both sides by \(Y^{disp}_t\) gives:
\begin{equation*}
\begin{split}\frac{C_t}{Y^{disp}_t} = \beta_1 -\beta_3\frac{r_t-\dot{p}_t}{Y^{disp}_t}\end{split}
\end{equation*}
\sphinxAtStartPar
or in logarithms
\begin{equation*}
\begin{split}{c_{t-1}}-{y^{disp}_{t-1}} - ln(\beta_1) +\beta_3 ln(r_{t-1}-\dot{p}_{t-1} -{y^{disp}_{t-1}})=0\end{split}
\end{equation*}
\sphinxAtStartPar
we can then write our ECM equation as
\begin{equation*}
\begin{split} \Delta c_t = -\lambda(\eta_{t-1})+ SR_t \end{split}
\end{equation*}
\sphinxAtStartPar
Substituting the LR expression for the error term in t\sphinxhyphen{}1 we get
\begin{equation*}
\begin{split} \Delta c_t = -\lambda({c_{t-1}}-{y^{disp}_{t-1}} - ln(\beta_1) +\beta_3 ln(r_{t-1}-\dot{p}_{t-1} -{y^{disp}_{t-1}}))+ \beta_{SR1}{y^{disp}_{t}} - \beta_{SR2}ln(r_{t}-\dot{p}_{t} -{y^{disp}_{t}})  \end{split}
\end{equation*}
\sphinxAtStartPar
where \(\beta_{SR1}\) is the short run elasticity of consumption to disposable income; \(\beta_{SR2}\) is the short run real interest rate elasticity of consumption and \(\lambda\) is the speed of adjustment (the rate at which past errors are corrected in each period).

\sphinxAtStartPar
\hyperlink{cite.content/litterature:id15}{Burns \sphinxstyleemphasis{et al.}} provides more complete derivations of the functional forms for most of the behavioural equations in MFmod.

\sphinxstepscope


\chapter{Modelflow and the MFMod models of the World Bank}
\label{\detokenize{content/02_MacrostructuralModels/MFModAndModelFlow:modelflow-and-the-mfmod-models-of-the-world-bank}}\label{\detokenize{content/02_MacrostructuralModels/MFModAndModelFlow::doc}}
\sphinxAtStartPar
At the World Bank models built using the MFMod framework are developed in \sphinxhref{https://eviews.com}{EViews}. When disseminated to clients, the models are operated in a World Bank customized EViews environment. But as a systems of equations and associated data the models can be solved, and operated under any system capable of solving a system of simultaneous equations – as long as the equations and data can be transferred from EViews to the secondary system. \sphinxcode{\sphinxupquote{Modelflow}} is such a system and offers a wide range of features that permit not only solving the model, but also provide a rich and powerful suite of tools for analyzing the model and reporting results.


\section{A brief history of ModelFlow}
\label{\detokenize{content/02_MacrostructuralModels/MFModAndModelFlow:a-brief-history-of-modelflow}}
\sphinxAtStartPar
Modelflow is a python library that was developed by Ib Hansen over several years while working at the Danish Central Bank and the European Central Bank. The framework has been used both to port the U.S. Federal Reserve’s macro\sphinxhyphen{}structural  model to python, but also been used to bring several stress\sphinxhyphen{}testing models developed by European Central Banks and the European Central Bank into a python environment.

\sphinxAtStartPar
Beginning in 2019, Hansen has worked with the World Bank to develop additional features that facilitate working with models built using the Bank’s MFMod Framework, with the objective of creating an open source platform through which the Bank’s models can be made available to the public.

\sphinxAtStartPar
This paper, and the models that accompany it, are the product of this collaboration.

\sphinxstepscope


\part{Installation of modelflow}

\sphinxstepscope


\chapter{Installation of Modelflow}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-modelflow}}\label{\detokenize{content/03_Installation/InstallingPython::doc}}
\sphinxAtStartPar
Modelflow is a python package that defines the \sphinxcode{\sphinxupquote{model}} class, its methods and a number of other functions that extend and combine pre\sphinxhyphen{}existing python functions to allow the easy solution of complex systems of equations including macro\sphinxhyphen{}structural models like MFMod.  To work with \sphinxcode{\sphinxupquote{modelflow}}, a user needs to first install python (preferably the Anaconda variant), several supporting packages, and of course the \sphinxcode{\sphinxupquote{modelflow}} package itself.  While \sphinxcode{\sphinxupquote{modelflow}} can be run directly from the python command\sphinxhyphen{}line or IDEs (Interactive Development Environments) like \sphinxcode{\sphinxupquote{Spyder}} or Microsoft’s \sphinxcode{\sphinxupquote{Visual Code}}, it is suggested that users also install the Jupyter notebook system. Jupyter Notebook facilitates an interactive approach to building python programs, annotating them and ultimately doing simulations using MFMod under \sphinxcode{\sphinxupquote{modelflow}}. This entire manual and the examples in it were all written and executed in the Jupyter Notebook environment.


\section{Installation of Python}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-python}}
\sphinxAtStartPar
Python is an extremely powerful and versatile and extensible open\sphinxhyphen{}source language. It is widely used for artificial intelligence application, interactive web sites, and scientific processing. As of 14 November 2022, the Python Package Index (PyPI), the official repository for third\sphinxhyphen{}party Python software, contained over 415,000 packages that extend its functionality %
\begin{footnote}[1]\sphinxAtStartFootnote
\sphinxhref{https://en.wikipedia.org/wiki/Python\_(programming\_language)}{Wikipedia article on python}
%
\end{footnote}. Modelflow is one of these packages.

\sphinxAtStartPar
Python comes in many flavors and \sphinxcode{\sphinxupquote{modelflow}} will work with any of them.  However, it is strongly suggested that you use the Anaconda version of Python.  The remainder of this section points to instructions on how to install the Anaconda version of python (under Windows, MacOS and under Linux). Modelflow works equally well under all three.

\sphinxAtStartPar
This is followed by section that describes the steps necessary to create an anaconda environment with all the necessary packages to run \sphinxcode{\sphinxupquote{modelflow}}.


\subsection{Installation of Anaconda under Windows}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-anaconda-under-windows}}
\sphinxAtStartPar
The definitive source for installing Anaconda under windows can be found \sphinxhref{https://docs.anaconda.com/anaconda/install/windows/}{here}.

\sphinxAtStartPar
\sphinxstylestrong{It is strongly advised that Anaconda be installed for a single user (Just Me)}  This is much easier to maintain over time.  Installing “For all users on this computer” will substabitally increase the complexity of maintaining python on your computer.


\subsection{Installation of Python under macOS}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-python-under-macos}}
\sphinxAtStartPar
The definitive source for installing Anaconda under macOS can be found \sphinxhref{https://docs.anaconda.com/anaconda/install/mac-os/}{here}.


\subsection{Installation of Python under Linux}
\label{\detokenize{content/03_Installation/InstallingPython:installation-of-python-under-linux}}
\sphinxAtStartPar
The definitive source for installing Anaconda under Linux can be found \sphinxhref{https://docs.anaconda.com/anaconda/install/linux/}{here}.

\sphinxAtStartPar
Once Anaconda is fully installed, you can then go to the following instruction on how to install \sphinxcode{\sphinxupquote{modelflow}} and the packages on which it depends.


\bigskip\hrule\bigskip


\sphinxstepscope


\chapter{Installation of Modelflow}
\label{\detokenize{content/03_Installation/InstallingModelFlow:installation-of-modelflow}}\label{\detokenize{content/03_Installation/InstallingModelFlow::doc}}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The following instructions concern the installation of \sphinxcode{\sphinxupquote{modelflow}} within an Anaconda installation of python.  Different flavors of Python may require slight changes to this recipe, but are not covered here.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} is built and tested using the anaconda python environment.  It is strongly recommended to use Anaconda with ````modelflow```.

\sphinxAtStartPar
If you have not already installed Anaconda following the instructions in the preceding chapter, please do so \sphinxstylestrong{Now}.
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} is a python package that defines the modelflow class \sphinxcode{\sphinxupquote{model}} among others.  \sphinxcode{\sphinxupquote{Modelflow1}} has many dependencies. Installing the class the first time can take some time depending on your internet connection and computer speed.  It is essential that you follow all of the steps outlined below to ensure that your version of \sphinxcode{\sphinxupquote{modelflow}} operates as expected.


\section{Installation of \sphinxstyleliteralintitle{\sphinxupquote{modelflow}} under Anaconda}
\label{\detokenize{content/03_Installation/InstallingModelFlow:installation-of-modelflow-under-anaconda}}\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Open the anaconda command prompt

\item {} 
\sphinxAtStartPar
Execute the following commands by copying and pasting them – either line by line or as a single mult\sphinxhyphen{}line step

\item {} 
\sphinxAtStartPar
Press enter

\end{enumerate}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{conda} \PYG{n}{create} \PYG{o}{\PYGZhy{}}\PYG{n}{n} \PYG{n}{ModelFlow} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{ibh} \PYG{o}{\PYGZhy{}}\PYG{n}{c}  \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{n}{modelflow\PYGZus{}pinned\PYGZus{}developement\PYGZus{}test} \PYG{o}{\PYGZhy{}}\PYG{n}{y}
\PYG{n}{conda} \PYG{n}{activate} \PYG{n}{ModelFlow}
\PYG{n}{pip} \PYG{n}{install} \PYG{n}{dash\PYGZus{}interactive\PYGZus{}graphviz}
\PYG{n}{conda} \PYG{n}{install} \PYG{n}{pyeviews} \PYG{o}{\PYGZhy{}}\PYG{n}{c} \PYG{n}{conda}\PYG{o}{\PYGZhy{}}\PYG{n}{forge} \PYG{o}{\PYGZhy{}}\PYG{n}{y}
\PYG{n}{jupyter} \PYG{n}{contrib} \PYG{n}{nbextension} \PYG{n}{install} \PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{n}{user}
\PYG{n}{jupyter} \PYG{n}{nbextension} \PYG{n}{enable} \PYG{n}{hide\PYGZus{}input\PYGZus{}all}\PYG{o}{/}\PYG{n}{main}
\PYG{n}{jupyter} \PYG{n}{nbextension} \PYG{n}{enable} \PYG{n}{splitcell}\PYG{o}{/}\PYG{n}{splitcellcd}
\PYG{n}{jupyter} \PYG{n}{nbextension} \PYG{n}{enable} \PYG{n}{toc2}\PYG{o}{/}\PYG{n}{main}

\end{sphinxVerbatim}

\sphinxAtStartPar
Depending on the speed of your computer and of your internet connection installation could take as little as 10 minutes or more than 1/2 an hour.

\sphinxAtStartPar
At the end of the process you will have a new conda environment ModelFlow, and this will have been activated.

\sphinxAtStartPar
Once modelflow is installed you are ready to work with it.  The following sections give a brief introduction to Jupyter notebook, which is a flexible tool that allows us to execute python code, interact with the modelflow class and World Bank Models and annotate what we have done for future replication.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
NB: The next time you want to work with modelflow, you will need to activate the \sphinxcode{\sphinxupquote{modelflow}} environment by
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{)}%
\item {} 
\sphinxAtStartPar
Opening the Anaconda command prompt window

\item {} 
\sphinxAtStartPar
Activate the ModelFlow environment we just created by executing the folling command

\end{enumerate}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{conda activate modelflow}}
\end{sphinxadmonition}

\sphinxstepscope


\chapter{Testing your installation of modelflow}
\label{\detokenize{content/03_Installation/TestingModelFlow:testing-your-installation-of-modelflow}}\label{\detokenize{content/03_Installation/TestingModelFlow::doc}}
\sphinxAtStartPar
To test that the installation of modelflow has worked properly, we will build a model using the modelflow framework and then simulate it.  A simple model that illustrates many of the functions of modelflow is the Solow growth model.

\sphinxAtStartPar
The code below first sets up the python environment by importing the modelflow  and pandas classes.  The initial two lines of code and the final two lines just set up the environment for optimal display and are not required.

\sphinxAtStartPar
To test the installation on your system you can copy this code into a Jupyter notebook and execute it.


\section{Specifying the model}
\label{\detokenize{content/03_Installation/TestingModelFlow:specifying-the-model}}
\sphinxAtStartPar
Having loaded the model class from the modelflow library, we can start constructing the model.

\sphinxAtStartPar
The first step is to define the equations of the model, using \sphinxcode{\sphinxupquote{modelflow}}’s Business Logic Language.

\begin{sphinxShadowBox}
\sphinxstylesidebartitle{\sphinxstylestrong{Business Logic Language}}

\sphinxAtStartPar
More on how to specify models \DUrole{xref,myst}{here}
\end{sphinxShadowBox}

\sphinxAtStartPar
The below code segment defines a string fsolow that contains the equations for the solow model, where:
\begin{itemize}
\item {} 
\sphinxAtStartPar
GDP is defined as a simple Cobb\sphinxhyphen{}Douglas production function as the product of TFP, Capital (raised to the share of capital in total income) and Labour (raised to the share of labor in total income)

\item {} 
\sphinxAtStartPar
Investment is equal to GDP less consumption

\item {} 
\sphinxAtStartPar
The change in capital is equal to investment this period less the depreciation of the capital stock from the previous period

\item {} 
\sphinxAtStartPar
Labor grows at the rate of growth of the variable \sphinxcode{\sphinxupquote{Labor\_growth}}

\item {} 
\sphinxAtStartPar
a pure reporting identity Capital\_intensity the ratio of the Capital Stock to the Labor input

\end{itemize}

\sphinxAtStartPar
We thus have a system of 6 equations with 6 unknowns (GDP, Consumption, Investment, Change in the Capital stock, and change in Labor supply, and the capital\_intensity) and exogenous variables (TFP, alfa,savings\_rate,Depreciation\_rate and Labor\_growth).

\sphinxAtStartPar
The equations for Labor and Capital have been entered as difference equations. The \sphinxcode{\sphinxupquote{modelflow}} object will automatically normalize them, generating an internal representation of \sphinxcode{\sphinxupquote{Labour=Labour(t\sphinxhyphen{}1)*(1+Labor\_growth)}} and \sphinxcode{\sphinxupquote{Capital=Capital(t\sphinxhyphen{}1)*(1\sphinxhyphen{}Depreciation\_rate)+Investment}}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{fsolow} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}}
\PYG{l+s+s1}{GDP          = TFP  * Capital**alfa * Labor **(1\PYGZhy{}alfa) }
\PYG{l+s+s1}{Consumption     = (1\PYGZhy{}saving\PYGZus{}rate)  * GDP }
\PYG{l+s+s1}{Investment      = GDP \PYGZhy{} Consumption   }
\PYG{l+s+s1}{diff(Capital)   = Investment\PYGZhy{}Depreciation\PYGZus{}rate * Capital(\PYGZhy{}1)}
\PYG{l+s+s1}{diff(Labor)     = Labor\PYGZus{}growth * Labor(\PYGZhy{}1)  }
\PYG{l+s+s1}{Capital\PYGZus{}intensity = Capital/Labor }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
To create the model we instantiate (create) a variable \sphinxcode{\sphinxupquote{msolow}} (which will ultimately contain both the equations and data for the model) using the \sphinxcode{\sphinxupquote{.from\_eq()}} method of the \sphinxcode{\sphinxupquote{modelflow}} class – submitting to it the equations in string form, and giving it the name “Solow model”.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{from\PYGZus{}eq}\PYG{p}{(}\PYG{n}{fsolow}\PYG{p}{,}\PYG{n}{modelname}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Solow model}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
The internal representation of the normalized equations can be displayed in normalized business language with the \sphinxcode{\sphinxupquote{modelflow}} method \sphinxcode{\sphinxupquote{.print\_model}}:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{o}{.}\PYG{n}{print\PYGZus{}model}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
FRML \PYGZlt{}\PYGZgt{} GDP          = TFP  * CAPITAL**ALFA * LABOR **(1\PYGZhy{}ALFA)  \PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} CONSUMPTION     = (1\PYGZhy{}SAVING\PYGZus{}RATE)  * GDP  \PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} INVESTMENT      = GDP \PYGZhy{} CONSUMPTION    \PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} CAPITAL=CAPITAL(\PYGZhy{}1)+(INVESTMENT\PYGZhy{}DEPRECIATION\PYGZus{}RATE * CAPITAL(\PYGZhy{}1))\PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} LABOR=LABOR(\PYGZhy{}1)+(LABOR\PYGZus{}GROWTH * LABOR(\PYGZhy{}1))\PYGZdl{}
FRML \PYGZlt{}\PYGZgt{} CAPITAL\PYGZus{}INTENSITY = CAPITAL/LABOR  \PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Create some data}
\label{\detokenize{content/03_Installation/TestingModelFlow:create-some-data}}
\sphinxAtStartPar
For the moment \sphinxcode{\sphinxupquote{msolow}} has a mathematical representation of a system of equations but no data.

\sphinxAtStartPar
To add data we  create a pandas dataframe with initial values for our exogenous variables. Technically capital and labor are endogenous in the Solow model, but because they are specified as change equations their initial values are exogenous and need to be initialized.

\sphinxAtStartPar
The code below  instantiates (creates) a panda dataframe \sphinxcode{\sphinxupquote{df}} and fills it with the variables for our model, initializing these with a series of values over 300 datapoints.  The final command displays the first ten rows of the dataframe.

\begin{sphinxadmonition}{note}{Note:}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Pandas data frames is a foundational class of python.  There are thousands of web sites dedicated to understanding pandas.  Some notable ones include:
\end{sphinxVerbatim}
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{N} \PYG{o}{=} \PYG{l+m+mi}{300}  
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LABOR}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,}
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CAPITAL}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{100}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{ALFA}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{TFP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{DEPRECIATION\PYGZus{}RATE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{LABOR\PYGZus{}GROWTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mf}{0.01}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{,} 
                   \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{SAVING\PYGZus{}RATE}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mf}{0.05}\PYG{p}{]}\PYG{o}{*}\PYG{n}{N}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2000}\PYG{p}{,}\PYG{l+m+mi}{2300}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}this prints out the first 5 rows of the dataframe}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      LABOR  CAPITAL  ALFA  TFP  DEPRECIATION\PYGZus{}RATE  LABOR\PYGZus{}GROWTH  SAVING\PYGZus{}RATE
2000    100      100   0.5    1               0.05          0.01         0.05
2001    100      100   0.5    1               0.05          0.01         0.05
2002    100      100   0.5    1               0.05          0.01         0.05
2003    100      100   0.5    1               0.05          0.01         0.05
2004    100      100   0.5    1               0.05          0.01         0.05
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Putting it together}
\label{\detokenize{content/03_Installation/TestingModelFlow:putting-it-together}}
\sphinxAtStartPar
Having defined an initial data set for all the exogenous variables, we can combine these with the equations and solve the model.

\sphinxAtStartPar
The command below solves the model \sphinxcode{\sphinxupquote{msolow}} on the data contained in the dataframe \sphinxcode{\sphinxupquote{df}} and stores the output in a new dataframe called \sphinxcode{\sphinxupquote{result}}.

\sphinxAtStartPar
The last line displays the values of the simulated model, which now includes results for the endogenous variables, and different values for the Labor and Capital variables reflecting their endogeneity for periods 2 through 300.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{result} \PYG{o}{=} \PYG{n}{msolow}\PYG{p}{(}\PYG{n}{df}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{c+c1}{\PYGZsh{} The model is simulated for all years possible }

\PYG{n}{result}\PYG{o}{.}\PYG{n}{head}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           LABOR     CAPITAL  ALFA  TFP  DEPRECIATION\PYGZus{}RATE  LABOR\PYGZus{}GROWTH  \PYGZbs{}
2000  100.000000  100.000000   0.5  1.0               0.05          0.01   
2001  101.000000  100.025580   0.5  1.0               0.05          0.01   
2002  102.010000  100.076226   0.5  1.0               0.05          0.01   
2003  103.030100  100.151443   0.5  1.0               0.05          0.01   
2004  104.060401  100.250762   0.5  1.0               0.05          0.01   
2005  105.101005  100.373733   0.5  1.0               0.05          0.01   
2006  106.152015  100.519926   0.5  1.0               0.05          0.01   
2007  107.213535  100.688931   0.5  1.0               0.05          0.01   
2008  108.285671  100.880357   0.5  1.0               0.05          0.01   
2009  109.368527  101.093830   0.5  1.0               0.05          0.01   

      SAVING\PYGZus{}RATE  CONSUMPTION         GDP  INVESTMENT  CAPITAL\PYGZus{}INTENSITY  
2000         0.05     0.000000    0.000000    0.000000           0.000000  
2001         0.05    95.486029  100.511609    5.025580           0.990352  
2002         0.05    95.986562  101.038487    5.051924           0.981043  
2003         0.05    96.501546  101.580575    5.079029           0.972060  
2004         0.05    97.030930  102.137821    5.106891           0.963390  
2005         0.05    97.574667  102.710176    5.135509           0.955022  
2006         0.05    98.132713  103.297593    5.164880           0.946943  
2007         0.05    98.705029  103.900030    5.195002           0.939144  
2008         0.05    99.291576  104.517449    5.225872           0.931613  
2009         0.05    99.892323  105.149813    5.257491           0.924341  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Create a scenario and run again}
\label{\detokenize{content/03_Installation/TestingModelFlow:create-a-scenario-and-run-again}}
\begin{sphinxShadowBox}
\sphinxstylesidebartitle{\sphinxstylestrong{dataframe.upd}}

\sphinxAtStartPar
When importing modelclass all pandas dataframes are enriched with a a handy way to create a new pandas dataframe as a copy of an existing one but with one or more series updated.

\sphinxAtStartPar
In this case df.upd will create a a new dataframe \sphinxcode{\sphinxupquote{dfscenaario}} with updated LABOR\_GROWTH

\sphinxAtStartPar
For more detail on the \sphinxcode{\sphinxupquote{.upd}} method look here \DUrole{xref,myst}{here}
\end{sphinxShadowBox}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dfscenario} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}2023 2200\PYGZgt{} LABOR\PYGZus{}GROWTH = LABOR\PYGZus{}GROWTH + 0.002}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} create a new dataframe, increase LABOR\PYGZus{}GROWTH by 0.002}
\PYG{n}{scenario}   \PYG{o}{=} \PYG{n}{msolow}\PYG{p}{(}\PYG{n}{dfscenario}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Higher labor growth }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} simulate the model }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Inspect results}
\label{\detokenize{content/03_Installation/TestingModelFlow:inspect-results}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{Modelflow}} includes a range of methods to view data and results, either as graphs or as tables.  Some of these are part of standard python, others are additional features that \sphinxcode{\sphinxupquote{modelflow}} makes available.

\sphinxAtStartPar
Scenario results can be inspected either by referring to the scenario name given in the (optional) \sphinxcode{\sphinxupquote{keep}} statement when the model was solved, by referring to the \sphinxcode{\sphinxupquote{basedf}} and the \sphinxcode{\sphinxupquote{lastdf}}.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{basedf}} is a dataframe that is automatically generated when the model is solved and contains a copy of the initial conditions of the model prior to the shock.

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{lastdf}}is a dataframe that is automatically generated when the model is solved and contains a copy of the results from the simulation. Several built in display functions use these functions to display results.

\end{itemize}

\sphinxAtStartPar
Finally one could also look at the dataframe to which the results of the simulation were assigned \sphinxcode{\sphinxupquote{scenario}} in the example above.

\sphinxAtStartPar
Below is a small sub\sphinxhyphen{}set of the visualization options available.


\subsection{Graphical representations of results}
\label{\detokenize{content/03_Installation/TestingModelFlow:graphical-representations-of-results}}

\subsubsection{The .dif.plot() method}
\label{\detokenize{content/03_Installation/TestingModelFlow:the-dif-plot-method}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif.plot}} method will plot the change in the level of requested variables.  Requested variables can be selected either directly by name or using wildcards.

\sphinxAtStartPar
In this example, a wild card specification is used, requesting the display of all variables that begin with the text ‘labor’.  Note that the selector is not case sensitive.

\sphinxAtStartPar
In this case we are displaying changes into the labor and labor growth variables due to the shock when we increased the growth rate of labor by .0002

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{labor*}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{28ae05d62fafe5fd35db4868226962fccd6269bec73310fece8437ae7f551422}.png}

\noindent\sphinxincludegraphics{{28ae05d62fafe5fd35db4868226962fccd6269bec73310fece8437ae7f551422}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In this example, instead of using a wild card selector we requested a variable explicitly by name.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP LABOR\PYGZus{}GROWTH}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pct}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{49f43ba057063db290c43f05c27a589984c46ab42fe9078b7976044d7baec37f}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{Using the kept solutions}
\label{\detokenize{content/03_Installation/TestingModelFlow:using-the-kept-solutions}}
\sphinxAtStartPar
Because the keyword \sphinxcode{\sphinxupquote{keep}} was used when running the simulations, we can refer to the scenarios by their names – or produce graphs from multiple scenarios – not just the first and last.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{o}{.}\PYG{n}{keep\PYGZus{}plot}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}GDP\PYGZsq{}: \PYGZlt{}Figure size 1000x600 with 1 Axes\PYGZgt{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Textual and tabular display of results}
\label{\detokenize{content/03_Installation/TestingModelFlow:textual-and-tabular-display-of-results}}
\sphinxAtStartPar
Standard pandas syntax can be used to display data in the results dataframes.

\sphinxAtStartPar
Here we use the standard pandas \sphinxcode{\sphinxupquote{.loc}} method to display every 10th data point for consumption from the results dataframe, beginning from observation 50 through 100.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{:}\PYG{l+m+mi}{100}\PYG{p}{:}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Series([], Name: CONSUMPTION, dtype: float64)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{The \sphinxstyleliteralintitle{\sphinxupquote{.dif.df}} method}
\label{\detokenize{content/03_Installation/TestingModelFlow:the-dif-df-method}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif.df}} method prints out the changes in variables, i.e. eh difference between the level of specified  variables in the \sphinxcode{\sphinxupquote{lastdf}} dataframe vs the \sphinxcode{\sphinxupquote{basedf}} dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
             GDP  CONSUMPTION
2001    0.000000     0.000000
2002    0.000000     0.000000
2003    0.000000     0.000000
2004    0.000000     0.000000
2005    0.000000     0.000000
...          ...          ...
2295  665.334581   632.067852
2296  672.097592   638.492713
2297  678.925939   644.979642
2298  685.820324   651.529308
2299  692.781453   658.142380

[299 rows x 2 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{The \sphinxstyleliteralintitle{\sphinxupquote{.difpct.df}} method}
\label{\detokenize{content/03_Installation/TestingModelFlow:the-difpct-df-method}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.dif.pct.df}} method express the changes between the last simulation and base simulation results as a percent differences in the level (\({\Delta X_t \over X^{basedf}_{t-1}} \) ).  In the example below the mul100 method multiplies the result by 100.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
           GDP  CONSUMPTION
2001       NaN          NaN
2002  0.000000     0.000000
2003  0.000000     0.000000
2004  0.000000     0.000000
2005  0.000000     0.000000
...        ...          ...
2295  0.005047     0.005047
2296  0.004892     0.004892
2297  0.004742     0.004742
2298  0.004596     0.004596
2299  0.004456     0.004456

[299 rows x 2 columns]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Interactive display of impacts}
\label{\detokenize{content/03_Installation/TestingModelFlow:interactive-display-of-impacts}}
\sphinxAtStartPar
When working within Jupyter notebook the {[} {]}  command will produce (without the .df termination) will generate a widget with the results expressed as level differences, percent differences, differences in the growth rate – both graphically and in table form.

\sphinxAtStartPar
Please consult \DUrole{xref,myst}{here} for a fuller presentation of the display routines built into \sphinxcode{\sphinxupquote{modelflfow}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{msolow}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP CONSUMPTION}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tab(children=(Tab(children=(HTML(value=\PYGZsq{}\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}utf\PYGZhy{}8\PYGZdq{} standalone=\PYGZdq{}no\PYGZdq{}?\PYGZgt{}\PYGZbs{}n\PYGZlt{}!DOCTYPE svg …
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Some Jupyter, Python and pandas essentials}

\sphinxstepscope


\chapter{Introduction to  Jupyter Notebook}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:introduction-to-jupyter-notebook}}\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook::doc}}
\sphinxAtStartPar
Jupyter Notebook is a web application for creating, annotating, simulating and working with computational documents.  Originally developed for python, the latest versions of EViews also support Jupyter Notebooks. Jupyter Notebook offers a simple, streamlined, document\sphinxhyphen{}centric experience and can be a great environment for documenting the work you are doing, and trying alternative methods of achieving desirable results.  Many of the methods in \sphinxcode{\sphinxupquote{modelflow}} have been developed to work well with Jupyter Notebook. Indeed this documentation was written as a series of Jupyter Notebooks bound together with Jupyter Book.

\sphinxAtStartPar
Jupyter Notebook is not the only way to work with modelflow or Python.  As users become more advanced they are likely to migrate to a more program\sphinxhyphen{}centric IDE (Interactive Development Environment) like Spyder or Microsoft Visual Code.

\sphinxAtStartPar
However, to start Jupyter Notebooks are a great way to learn, follow work done by others and tweak them to fit your own needs.

\sphinxAtStartPar
There are many fine tutorials on Jupyter Notebook on the web, and \sphinxhref{https://docs.jupyter.org/en/latest/}{The official Jupyter site} is a good starting point. The following aims to provide enough information to get a user started.


\section{The idea of the notebook}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:the-idea-of-the-notebook}}
\sphinxAtStartPar
The idea behind jupyter notebook was to create an interactive version of the notebooks that scientists use(d) to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
record what they have done

\item {} 
\sphinxAtStartPar
perhaps explain why

\item {} 
\sphinxAtStartPar
document how data was generated, and

\item {} 
\sphinxAtStartPar
record the results of their experiments

\end{itemize}

\sphinxAtStartPar
The motivation for these notebooks and Jupyter notebook is to encourage practices that will ensure that if followed exactly by others, that they will be able to generate the same results.


\section{Jupter Notebook cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:jupter-notebook-cells}}
\sphinxAtStartPar
A Jupyter Notebook  does all of that (and perhaps a bit more).  It is divided into ‘cells’.

\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Jupyter Notebook cells can contain:}}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{computer code} (typically python code, but as noted other kernels – like Eviews – can be used with jupyter).

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{markdown text}: plain text that can include special characters that make some text appear as bold, or indicate the text is headers, or instruct JN to render the text as a mathematical formula.  All of the text in this document was entered using Jupyter Notebook’s markdown language

\item {} 
\sphinxAtStartPar
Results (in the form of tables or graphs) from the execution of computer code specified in a code cell

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Every cell has two modes:}
\begin{enumerate}
\sphinxsetlistlabels{\arabic}{enumi}{enumii}{}{.}%
\item {} 
\sphinxAtStartPar
Edit mode – indicated by a green vertical bar. In edit mode the user can change the code, or the markdown.

\item {} 
\sphinxAtStartPar
Select/Copy mode – indicated by a blue vertical bar.  This will be teh state of the cell when its content has been executed.  For markdown cells this means that the text and special characters have been rendered into formatted text.  For code cells, this means the code has been executed and its output (if any) displayed in an output cell.

\end{enumerate}

\sphinxAtStartPar
The notebook has associated with it a “Kernel”, which is an instance of the computing environment in which code will be executed. For JN taht work with modelflow this will be a Python Kernel.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Jupyter Notebooks were designed to facilitate \sphinxstyleemphasis{replicability}: the idea that a scientific analysis should contain \sphinxhyphen{} in addition to the final output (text, graphs, tables) \sphinxhyphen{} all the computational steps needed to get from raw input data to the results.
\end{sphinxadmonition}


\section{Execution of cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:execution-of-cells}}
\sphinxAtStartPar
Every cell in a JN can be executed, either by using the Run button on the Jupyter Notebook menu, or by using one of \sphinxstylestrong{two keyboard shortcuts}:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{ctrl + Enter}: Executes the code in the cell or formats the markdown of a cell.  The current cell retains the focus – cursor stays on cell executed.

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{shift + enter}: Executes the code in the cell or formats the markdown of a cell. Focus (cursor) jumps to the next cell

\end{itemize}

\sphinxAtStartPar
For other useful shortcuts see “Help” => “Keyboard Shortcuts” or simply press keyboard icon in the toolbar.


\subsection{Execution of code cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:execution-of-code-cells}}
\sphinxAtStartPar
Below is a code with some standard python that declares a variable “x”, assigns it the value 10, declares a second variable “y” and assigns it the value 45.  The final line of y alone, instructs python to display the value of the variable y.  The results of the operation appear in Jupyter Notebook as an output cell Out{[}\#{]}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{n}{y}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
45
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{the semi\sphinxhyphen{}colon “;” supresses output in Jupyter Notebook}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:the-semi-colon-supresses-output-in-jupyter-notebook}}
\sphinxAtStartPar
In the example below, a semi\sphinxhyphen{}colon “;” has been appended to the final line.  This suppresses the display of the value contained by y;  As a result there is no output cell.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n}{y} \PYG{o}{=} \PYG{l+m+mi}{45}
\PYG{n}{y}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Another way to display results is to use the print function.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{x} \PYG{o}{=} \PYG{l+m+mi}{10}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
10
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Variables in a Jupyter Notebook session are persistent, as a result in the subsequent cell, we can declare a variable ‘z’ equal to 2*y and it will have the value 90.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{z}\PYG{o}{=}\PYG{n}{y}\PYG{o}{*}\PYG{l+m+mi}{2}
\PYG{n}{z}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
90
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Auto\sphinxhyphen{}complete and context\sphinxhyphen{}sensitive help}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:auto-complete-and-context-sensitive-help}}
\sphinxAtStartPar
When editing a code cell, you can use these short\sphinxhyphen{}cuts to autocomplete and or call up documentation for a command.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{tab}: autocomplete and  method selection

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{double tab}: documention (double tab for full doc)

\end{itemize}


\section{The markdown scripting language in Jupyter Notebook}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:the-markdown-scripting-language-in-jupyter-notebook}}
\sphinxAtStartPar
Text cells in a notebook can be made more interesting by using markdown.

\sphinxAtStartPar
Cells designated as markdown cells when executed are rendered in a rich text format (html).

\sphinxAtStartPar
Markdown is a lightweight markup language for creating formatted text using a plain\sphinxhyphen{}text editor.  Used in a markdown cell of Jupyter Notebook it can be used to produce nicely formatted text that mixes text, mathematical formulae, code and outputs from executed python code.

\sphinxAtStartPar
Rather than the relatively complex commands of html <h1></h1>, markdown uses a simplified set of commands to control how text elements should be rendered.


\subsection{Common markdown commands}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:common-markdown-commands}}
\sphinxAtStartPar
Some of the most common of these include:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
symbol
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Effect
\\
\hline
\sphinxAtStartPar
\#
&
\sphinxAtStartPar
Header
\\
\hline
\sphinxAtStartPar
\#\#
&
\sphinxAtStartPar
second level
\\
\hline
\sphinxAtStartPar
\#\#\#
&
\sphinxAtStartPar
third level etc.
\\
\hline
\sphinxAtStartPar
**Bold text**
&
\sphinxAtStartPar
\sphinxstylestrong{Bold text}
\\
\hline
\sphinxAtStartPar
*Italics text*
&
\sphinxAtStartPar
\sphinxstyleemphasis{Italics text}
\\
\hline
\sphinxAtStartPar
* text
&
\sphinxAtStartPar
Bulleted text or dot notes
\\
\hline
\sphinxAtStartPar
1. text
&
\sphinxAtStartPar
1. Numbered bullets
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\subsection{Tables in markdown}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:tables-in-markdown}}
\sphinxAtStartPar
Tables like the one above can be constructed using | as separators.

\sphinxAtStartPar
Below is the markdown code that generated the above table:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{|} \PYG{n}{symbol}           \PYG{o}{|} \PYG{n}{Effect}          \PYG{o}{|}
\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{\PYGZhy{}}\PYG{o}{|}
\PYG{o}{|} \PYGZbs{}\PYG{c+c1}{\PYGZsh{}               | Header        |}
\PYG{o}{|} \PYGZbs{}\PYG{c+c1}{\PYGZsh{}\PYGZbs{}\PYGZsh{}             | second level |}
\PYG{o}{|} \PYGZbs{}\PYG{o}{*}\PYGZbs{}\PYG{o}{*}\PYG{n}{Bold} \PYG{n}{text}\PYGZbs{}\PYG{o}{*}\PYGZbs{}\PYG{o}{*} \PYG{o}{|} \PYG{o}{*}\PYG{o}{*}\PYG{n}{Bold} \PYG{n}{text}\PYG{o}{*}\PYG{o}{*}   \PYG{o}{|}
\PYG{o}{|} \PYGZbs{}\PYG{o}{*}\PYG{n}{Italics} \PYG{n}{text}\PYGZbs{}\PYG{o}{*} \PYG{o}{|} \PYG{o}{*}\PYG{n}{Italics} \PYG{n}{text}\PYG{o}{*}   \PYG{o}{|}
\PYG{o}{|} 
\PYG{o}{|} \PYG{l+m+mi}{1}\PYGZbs{}\PYG{o}{.} \PYG{n}{text}  \PYG{o}{|} \PYG{l+m+mf}{1.} \PYG{n}{Numbered} \PYG{n}{bullets}   \PYG{o}{|}

\end{sphinxVerbatim}


\subsection{Displaying code}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:displaying-code}}
\sphinxAtStartPar
To display a (unexecutable)  block of code within a markdown cell, encapsulate it (sourround it) with three ` at the beginning and end.  The below code entered in a markdown cell,

\sphinxAtStartPar
``` text to be rendered as code ```.

\sphinxAtStartPar
will be rendered as: \sphinxcode{\sphinxupquote{text to be rendered as code}}.


\subsection{Rendering mathematics in markdown}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:rendering-mathematics-in-markdown}}
\sphinxAtStartPar
Jupyter Notebook’s inmplementation of Markdown supports LaTeX mathematical notation.

\sphinxAtStartPar
Inline enclose the LaTeX code in \sphinxcode{\sphinxupquote{\$}}:

\sphinxAtStartPar
An Equation: \sphinxcode{\sphinxupquote{\$y\_t = \textbackslash{}beta\_0 + \textbackslash{}beta\_1 x\_t + u\_t\textbackslash{}\$}} will renders as: \(y_t = \beta_0 + \beta_1 x_t + u_t\)

\sphinxAtStartPar
if enclosed in \sphinxcode{\sphinxupquote{\$\$}} \sphinxcode{\sphinxupquote{\$\$}} it will be centered on its own line.
\begin{equation*}
\begin{split}y_t = \beta_0 + \beta_1 x_t + u_t\end{split}
\end{equation*}
\sphinxAtStartPar
If you want the math to stand alone (not be in\sphinxhyphen{}line, then use two \sphinxcode{\sphinxupquote{\$}} signs)

\sphinxAtStartPar
The below block renders as below, with the \sphinxcode{\sphinxupquote{\&}} symbol telling LaTeX to align the different lines (separates by \sphinxcode{\sphinxupquote{\textbackslash{}\textbackslash{}}}) on the character immediately after the \sphinxcode{\sphinxupquote{\&}}. Here it is used to align the texts on the space preceding the equals sign in each line.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZbs{}\PYG{n}{begin}\PYG{p}{\PYGZob{}}\PYG{n}{align}\PYG{o}{*}\PYG{p}{\PYGZcb{}}
\PYG{n}{Y\PYGZus{}t}  \PYG{o}{\PYGZam{}}\PYG{o}{=}  \PYG{n}{C\PYGZus{}t}\PYG{o}{+}\PYG{n}{I\PYGZus{}t}\PYG{o}{+}\PYG{n}{G}\PYG{o}{+}\PYG{n}{t}\PYG{o}{+} \PYG{p}{(}\PYG{n}{X\PYGZus{}t}\PYG{o}{\PYGZhy{}}\PYG{n}{M\PYGZus{}t}\PYG{p}{)} \PYGZbs{}\PYGZbs{}
\PYG{n}{C\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{C\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{I\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{I\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{I\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{G\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{G\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{G\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{X\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{X\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{X\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{M\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{,}\PYG{n}{P}\PYG{o}{\PYGZca{}}\PYG{n}{f\PYGZus{}t}\PYG{p}{)}\PYGZbs{}\PYGZbs{}
\PYG{n}{M\PYGZus{}t} \PYG{o}{\PYGZam{}}\PYG{o}{=} \PYG{n}{c\PYGZus{}t}\PYG{p}{(}\PYG{n}{M\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{M\PYGZus{}}\PYG{p}{\PYGZob{}}\PYG{n}{t}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{2}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{C\PYGZus{}t}\PYG{p}{,}\PYG{n}{I\PYGZus{}t}\PYG{p}{,}\PYG{n}{G\PYGZus{}t}\PYG{p}{,}\PYG{n}{X\PYGZus{}t}\PYG{p}{,}\PYG{n}{P\PYGZus{}t}\PYG{p}{,}\PYG{n}{P}\PYG{o}{\PYGZca{}}\PYG{n}{f\PYGZus{}t}\PYG{p}{)}
\PYGZbs{}\PYG{n}{end}\PYG{p}{\PYGZob{}}\PYG{n}{align}\PYG{o}{*}\PYG{p}{\PYGZcb{}}
\end{sphinxVerbatim}
\begin{align*}
Y_t  &=  C_t+I_t+G+t+ (X_t-M_t) \\
C_t &= c_t(C_{t-1},C_{t-2},I_t,G_t,X_t,M_t,P_t)\\
I_t &= c_t(I_{t-1},I_{t-2},C_t,G_t,X_t,M_t,P_t)\\
G_t &= c_t(G_{t-1},G_{t-2},C_t,I_t,X_t,M_t,P_t)\\
X_t &= c_t(X_{t-1},X_{t-2},C_t,I_t,G_t,M_t,P_t,P^f_t)\\
M_t &= c_t(M_{t-1},M_{t-2},C_t,I_t,G_t,X_t,P_t,P^f_t)
\end{align*}

\subsection{links to more info on markdown}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:links-to-more-info-on-markdown}}
\sphinxAtStartPar
There are several very good markdown cheatsheets on the internet, one of these is \sphinxhref{https://www.markdownguide.org/cheat-sheet/}{here}


\section{How to add, delete and move cells}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:how-to-add-delete-and-move-cells}}
\sphinxAtStartPar
Jupyter Notebook cells can be added, deleted and moved.

\sphinxAtStartPar
\sphinxstylestrong{Using the Toolbar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{+ button}: add a cell below the current cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{scissors}: cut  current cell (can be undone from “Edit” tab)

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{clipboard}: paste a previously cut cell to the current location

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{up\sphinxhyphen{} and down arrows}: move cells

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{hold shift + click cells in left margin}: select multiple cells (vertical bar must be blue)

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Using keyboard short cuts}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + a}: add a cell above the current cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + b}: add a cell below the current cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + d+d}: delete the current cell

\end{itemize}


\section{Change the type of a cell}
\label{\detokenize{content/04_PythonEssentials/Intro_Jupyter_notebook:change-the-type-of-a-cell}}
\sphinxAtStartPar
You can also change the type of a cell. New cells are by default “code” cells.

\sphinxAtStartPar
\sphinxstylestrong{Using the Toolbar}
\begin{itemize}
\item {} 
\sphinxAtStartPar
Select the desired type from the drop down.  options include
\begin{itemize}
\item {} 
\sphinxAtStartPar
Markdown

\item {} 
\sphinxAtStartPar
Code

\item {} 
\sphinxAtStartPar
Raw NBConvert

\item {} 
\sphinxAtStartPar
Heading

\end{itemize}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{Using keyboard short cuts}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + m}: make the current cell a markdown cell

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{esc + y}: make the current cell a code  cell

\end{itemize}

\sphinxstepscope


\chapter{Some Python basics}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:some-python-basics}}\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc::doc}}
\sphinxAtStartPar
Before using \sphinxcode{\sphinxupquote{modelflow}} with the World Bank’s MFMod models, users  will have to understand at least some basic elements of \sphinxcode{\sphinxupquote{python}} syntax and usage.  Notably they will need to understand about packages, libraries and classes, how to access them.


\section{Python  packages, libraries and classes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:python-packages-libraries-and-classes}}
\sphinxAtStartPar
Some features of \sphinxcode{\sphinxupquote{python}} are built\sphinxhyphen{}in out\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}box.  Others build up on these basic features.

\sphinxAtStartPar
A \sphinxstylestrong{python class} is a code template that defines a python object. Classes can have member variables (data) associated with them and methods (behaviours or functions)associated with them. In python a class is created by the keyword class. An object of type class is created (instantiated) using the classes “constructor”.

\sphinxAtStartPar
A \sphinxstylestrong{module} is a Python object consisting of Python code. A module can define functions, classes and variables. A module can also include runnable code.

\sphinxAtStartPar
A \sphinxstylestrong{python package} is a collection of modules that are related to each other. When a module from an external package is required by a program, that package (or module in the package) must  be \sphinxstylestrong{imported} into the current session for its modules can be put to use.

\sphinxAtStartPar
A \sphinxstylestrong{python library} is a collection of related modules or packages.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In modelflow the model is a class and we can create an instance of a model (an object filled with the characteristics of the class) by executing the code \sphinxcode{\sphinxupquote{mymodel = model(myformulas)}} see below for a working example.
\end{sphinxadmonition}


\section{Importing packages, libraries, modules and classes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:importing-packages-libraries-modules-and-classes}}
\sphinxAtStartPar
Some libraries, packages, modules are part of the core python package and will be available (importable) from the get go.  Others are not and need to be installed on your system before importing them into your sessions.

\sphinxAtStartPar
If you followed the modelflow installation instructions you have already downloaded and installed on your computer all the packages necessary for running World Bank models under modelflow.  But to work with them in a given Jupyter Notebook session or in a program context, you will also need to \sphinxcode{\sphinxupquote{import}} them into your session before you call them.

\sphinxAtStartPar
Typically a python program will start with the importation of the libraries, classes and modules that will be used.  Because a Jupyter Notebook is essentially a heavily annotated program, it also requires that packages used be imported.

\sphinxAtStartPar
Below, some insight into the structure and content of packages and different ways to import them into a program or Typically a python program will start with the importation of the libraries, classes and modules that will be used.  Because a Jupyter Notebook.

\sphinxAtStartPar
As described above packages, libraries and modules are containers that can include other elements.  Take for example the package Math.

\sphinxAtStartPar
To import the Math Package we execute the command \sphinxcode{\sphinxupquote{ import math}}.  Having done that we can can call the functions and data that are defined in it.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} the \PYGZdq{}\PYGZsh{}\PYGZdq{}\PYGZdq{} in a code cell indicates a comment, test after the \PYGZsh{} will not be executed}
\PYG{k+kn}{import} \PYG{n+nn}{math}

\PYG{c+c1}{\PYGZsh{} Now that we have imported math we can access some of the elements identified in the package, }
\PYG{c+c1}{\PYGZsh{} For example math contains a definition for pi, we can access that by executing the pi method }
\PYG{c+c1}{\PYGZsh{} of the library math}
\PYG{n}{math}\PYG{o}{.}\PYG{n}{pi}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.141592653589793
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Import specific elements or classes from a module or library}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:import-specific-elements-or-classes-from-a-module-or-library}}
\sphinxAtStartPar
The python package \sphinxcode{\sphinxupquote{math}} contains several functions and classes.

\sphinxAtStartPar
If I want I can import them directly. Then when I call them I will not have to precede them with the name of their libary. to do this I use the \sphinxstylestrong{from} syntax.  \sphinxcode{\sphinxupquote{from math import pi,cos,sin}} will import the pi constant and the two functions cos and sin and allow me to call them directly.

\sphinxAtStartPar
Compared these calls with the one in the preceding section – there the call to the method pi has to be preceded by its namespace designator math.  i.e. \sphinxcode{\sphinxupquote{math.pi}}. Below we import pi directly and can just call it with pi.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{math} \PYG{k+kn}{import} \PYG{n}{pi}\PYG{p}{,}\PYG{n}{cos}\PYG{p}{,}\PYG{n}{sin}

\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{pi}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.141592653589793
\PYGZhy{}0.9899924966004454
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{import a class but give it an alias}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:import-a-class-but-give-it-an-alias}}
\sphinxAtStartPar
A class and instead of using its full name as above or it can be given an alias, that is hopefully shorter but still obvious enough that the user knows what class is being referred to.

\sphinxAtStartPar
For example  \sphinxcode{\sphinxupquote{import math as m}} allows a call to pi using the more succint syntax \sphinxcode{\sphinxupquote{m.py}}.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{math} \PYG{k}{as} \PYG{n+nn}{m}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{m}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
3.141592653589793
\PYGZhy{}0.9899924966004454
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Standard aliases}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:standard-aliases}}
\sphinxAtStartPar
Some packages are so frequently used that by convention they have been “assigned” specific aliases.

\sphinxAtStartPar
For example:

\sphinxAtStartPar
\sphinxstylestrong{Common aliases}
|Alias|aliased package | example | functionalty|
|:==|:==|:==|
|pd|pandas| import pandas as pd |Pandas are used for storing and retriveing data|
|np|numpy| import numpy as np | Numpy gives access to some advanced mathematical features|

\sphinxAtStartPar
You don’t have to use those conventions but it will make your code easier to read by others who are familiar with it.


\section{Introduction to Pandas dataframes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:introduction-to-pandas-dataframes}}
\sphinxAtStartPar
Modelflow is built on top of the Pandas library. Pandas is the Swiss knife of data science and can perform an impressing array of date oriented tasks.

\sphinxAtStartPar
This tutorial is a very short introduction to how pandas dataframes are used with Modelflow. For a more complete discussion see any of the many tutorials on the internet, notably:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/}{Pandas homepage}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/pandas-docs/stable/getting\_started/tutorials.html}{Pandas community tutorials}

\end{itemize}


\section{Import the pandas library}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:import-the-pandas-library}}
\sphinxAtStartPar
As with any python program, in order to use a package or library it must first be imported into the session. As noted above, by  convention pandas is imported as pd

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
Pandas like any libarary contains many classes and methods.  Here we are going to focus on a \sphinxstylestrong{Series} and \sphinxstylestrong{DataFrames}, each of which are very useful for time\sphinxhyphen{}series data.

\sphinxAtStartPar
Unlike other statistical packages neither \sphinxcode{\sphinxupquote{series}} nor \sphinxcode{\sphinxupquote{dataframes}} are inherently or exclusively time\sphinxhyphen{}series in nature.  In \sphinxcode{\sphinxupquote{modelflow}} and macroeconomists use them in this way, but the classes themselves are not dated in anyway out\sphinxhyphen{}of\sphinxhyphen{}the\sphinxhyphen{}box.


\section{Pandas series}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:pandas-series}}
\sphinxAtStartPar
A pandas series is an object that holds a two dimensional array comprised of values and index.

\sphinxAtStartPar
The constructor for a pandas.Series is \sphinxcode{\sphinxupquote{pandas.Series()}}.  The content inside the parentheses will determine the nature of the series.  As an object\sphinxhyphen{}oriented language Python supports \sphinxcode{\sphinxupquote{overrides}} (which is to say a method can have more than one way in which it can be called). Specifically there can be different constructors defined for a class, depending on how the data that is to be used to initialize it is organized.


\subsection{Series declared from a list}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:series-declared-from-a-list}}
\sphinxAtStartPar
The simplest way to create a Series is to pass an array of values as a Python list to the Series constructor.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A list in python is a comma delimited collection of items.  It could be text, numbers or even more complex objects.  When declared (and returned) list are enclosed in square brackets.

\sphinxAtStartPar
mylist={[}2,7,8,9{]}
mylist2={[}“Some text”,”Some more Text”,2,3{]}

\sphinxAtStartPar
Note the list is entirely agnostic about the type of data it contains.
\end{sphinxadmonition}

\sphinxAtStartPar
In the examples below Simplest, Simple and simple3 are series – although series3 which is derived from a list mixing text and numeric values would be hard to interpret as an economic series.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{values}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}
\PYG{n}{weird}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Some text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Some more Text}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{]}

\PYG{c+c1}{\PYGZsh{} Here the constructor is passed a numeric list}
\PYG{n}{Simplest}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Simplest}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0     2
1     3
2     4
3     5
4   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} In this case the constructor is passed a string variable that contains a list}
\PYG{n}{simple2}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{values}\PYG{p}{)}
\PYG{n}{simple2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0     2
1     3
2     4
3     5
4   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Here the constructor is passed a string containing a list that is a mix of }
\PYG{c+c1}{\PYGZsh{} alphanumerics and numerical values}
\PYG{n}{simple3}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{weird}\PYG{p}{)}
\PYG{n}{simple3}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
0         Some text
1    Some more Text
2                 2
3                 3
dtype: object
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Constructed in this way each of these Series are automatically assigned a zero\sphinxhyphen{}based index.


\subsection{Series declared using a specific index}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:series-declared-using-a-specific-index}}
\sphinxAtStartPar
In this example the series Simple and Simple2 are  recreated, but this time an index is specified. Here the index is declared as a list.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} In this example the constructor is given both the values }
\PYG{c+c1}{\PYGZsh{} and specific values for the index}
\PYG{n}{Simplest}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{]}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1966}\PYG{p}{,}\PYG{l+m+mi}{1967}\PYG{p}{,}\PYG{l+m+mi}{1996}\PYG{p}{,}\PYG{l+m+mi}{1999}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Simplest}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1966     2
1967     3
1996     4
1999     5
2000   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{simple2}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{values}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{1966}\PYG{p}{,}\PYG{l+m+mi}{1967}\PYG{p}{,}\PYG{l+m+mi}{1996}\PYG{p}{,}\PYG{l+m+mi}{1999}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{simple2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1966     2
1967     3
1996     4
1999     5
2000   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now the Series look more like time series data!


\subsection{Create Series from a dictionary}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:create-series-from-a-dictionary}}
\sphinxAtStartPar
In python a dictionary is a data structure that is more generally known in computer science as an associative array. A dictionary consists of a collection of key\sphinxhyphen{}value pairs, where each key\sphinxhyphen{}value pair \sphinxstyleemphasis{maps} or \sphinxstyleemphasis{links} the key to its associated value.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
A dictionary is enclosed in curly brackets \{\}, versus a list which is enclosed in square brackets{[}{]}.
\end{sphinxadmonition}

\sphinxAtStartPar
Thus mydict=\{“1966”:2,”1967”:3,”1968”:4,”1969”:5,”2000”:\sphinxhyphen{}15\} creates an object called mydict.   \sphinxcode{\sphinxupquote{mydict}}maps (or links) the key “1966” to the value 2.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In this example the Key was a string but we could just as easily made it a numerical value:
\end{sphinxadmonition}

\sphinxAtStartPar
mydict2=\{1966:2,1967:3,1968:4,1969:5,2000:\sphinxhyphen{}15\} creates an object called mydict2 that links (maps) the key “1966” to the value 2.

\sphinxAtStartPar
The series constructor also accepts a dictionary, and maps the key to the index of the Series.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mydict2}\PYG{o}{=}\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{1966}\PYG{p}{:}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{1967}\PYG{p}{:}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{1968}\PYG{p}{:}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{1969}\PYG{p}{:}\PYG{l+m+mi}{5}\PYG{p}{,}\PYG{l+m+mi}{2000}\PYG{p}{:}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{15}\PYG{p}{\PYGZcb{}}
\PYG{n}{simple2}\PYG{o}{=}\PYG{n}{pd}\PYG{o}{.}\PYG{n}{Series}\PYG{p}{(}\PYG{n}{mydict2}\PYG{p}{)}
\PYG{n}{simple2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
1966     2
1967     3
1968     4
1969     5
2000   \PYGZhy{}15
dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Properties and methods of dataframes in modelflow}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:properties-and-methods-of-dataframes-in-modelflow}}
\sphinxAtStartPar
Any class can have both properties (data) and methods (functions that operate on the data of the particular instance of the class). With object\sphinxhyphen{}oriented programming languages like python, classes can be built as supersets of existing classes. The Modelflow class \sphinxcode{\sphinxupquote{model}} inherits or encapsulates all of the features of the pandas dataframe and extends it in many important ways.  Some of the methods below are standard pandas methods, others have been added to it by \sphinxcode{\sphinxupquote{modelflow}} features

\sphinxAtStartPar
Much more detail on standard pandas dataframes can be found on the \sphinxhref{https://pandas.pydata.org/docs/reference/frame.html}{official pandas website}.


\subsection{dataframes}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:dataframes}}
\sphinxAtStartPar
The dataframe is the primary structure of pandas and is a two\sphinxhyphen{}dimensional data structure with named rows and columns.  Each columns can have different data types (numeric, string, etc).

\sphinxAtStartPar
By convention, a dataframe if often called df or some other modifier followed by df, to assist in reading the code.


\subsection{Creating or instantiating a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:creating-or-instantiating-a-dataframe}}
\sphinxAtStartPar
Like any object we an create a dataframe by calling the dataframe constructor of the pandas class.  Each class has many constructors, so there are very many ways to create a dataframe.

\sphinxAtStartPar
The code example below creates a dataframe of three columns A,B,C and  indexed between 2019 and 2021.  Macroeconomists may interpret the index as dates, but for pandas they are just numbers.  The .DataFrame() method is constructor for the dataframe class. It takes several forms (as with series), but always returns an instance of a (instantiates) dataframe – i.e. a variable that is a dataframe.

\sphinxAtStartPar
Below a Dataframe named \sphinxcode{\sphinxupquote{df}} is instantiated from a dictionary and assigned a specific index by passing a list of years as the index.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{,}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2021}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E
2018  1  1  4
2019  1  2  4
2020  1  3  4
2021  1  6  4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the dataframes that are used in macrostructural models like MFMod, each  column is a  time series for an economic variable. So in this dataframe,  A, B and C woudl normally be interpreted as economic time series.

\sphinxAtStartPar
Although less frequent, \sphinxcode{\sphinxupquote{modelflow}} and pandas can also contain timeseries of matrices or vectors.
\end{sphinxadmonition}


\subsection{Adding a column to a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:adding-a-column-to-a-dataframe}}
\sphinxAtStartPar
If we assign a value to a column that does not exist, then pandas will add a column with that name and the values of the calculation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NEW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{13}\PYG{p}{]}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E  NEW
2018  1  1  4   10
2019  1  2  4   12
2020  1  3  4   10
2021  1  6  4   13
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Revising values}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:revising-values}}
\sphinxAtStartPar
If the column exists than the = method will revise the values of the rows with the values assigned in the statement.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The dimensions of the list assigned via the \sphinxcode{\sphinxupquote{=}} method must be the same as the dataframe (i.e. you must provide exactly as many values as there are rows).  Alternatively if you provide just one, then that value will replace all of the values in the specified column.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{NEW}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{]}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{11}\PYG{p}{,}\PYG{l+m+mi}{12}\PYG{p}{,}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{14}\PYG{p}{]}

\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E  NEW
2018  1  1  4   11
2019  1  2  4   12
2020  1  3  4   10
2021  1  6  4   14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} replace all of the rows of column B with the same value}
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{l+m+mi}{17}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW
2018  17  1  4   11
2019  17  2  4   12
2020  17  3  4   10
2021  17  6  4   14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Column names in  Modelflow}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:column-names-in-modelflow}}
\begin{sphinxShadowBox}
\sphinxstylesidebartitle{Modelflow variable names}

\sphinxAtStartPar
Modelflow places more restrictions on columnnames than do pandas per se.
\end{sphinxShadowBox}

\sphinxAtStartPar
While pandas dataframes are very liberal in what names can be given to columns, \sphinxcode{\sphinxupquote{modelflow}} is more restrictive.

\sphinxAtStartPar
Specifically, in modelflow a variable name must:
\begin{itemize}
\item {} 
\sphinxAtStartPar
start with a letter

\item {} 
\sphinxAtStartPar
be upper case

\end{itemize}

\sphinxAtStartPar
Thus while all these are legal column names in pandas, some are illegal in modelflow.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Variable Name
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Legal in modelfow?
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Reason
\\
\hline
\sphinxAtStartPar
IB
&
\sphinxAtStartPar
yes
&
\sphinxAtStartPar
Starts with a letter and is uppercase
\\
\hline
\sphinxAtStartPar
ib
&
\sphinxAtStartPar
no
&
\sphinxAtStartPar
 lowercase letters are not allowed
\\
\hline
\sphinxAtStartPar
42ANSWER
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
 does not start with a letter 
\\
\hline
\sphinxAtStartPar
\_HORSE1
&
\sphinxAtStartPar
No
&
\sphinxAtStartPar
does not start with a letter 
\\
\hline
\sphinxAtStartPar
A\_VERY\_LONG\_NAME\_THAT\_IS\_LEGAL\_3
&
\sphinxAtStartPar
Yes
&
\sphinxAtStartPar
 Starts with a letter and is uppercase 
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}


\section{.index and time dimensions in Modelflow}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:index-and-time-dimensions-in-modelflow}}
\sphinxAtStartPar
As we saw above, series have indices.  Dataframes also have indices, which are the row names of the dataframe.

\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{modelflow}} the index series is typically understood to represent a date.

\sphinxAtStartPar
For yearly models a list of integers like in the above example works fine.

\sphinxAtStartPar
For higher frequency models the index can be one of pandas datatypes.

\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
Not all datetypes work well with the graphics routines of modelflow.  Users are advised to use use the \sphinxcode{\sphinxupquote{pd.period\_range()}} method to generate date indexes.

\sphinxAtStartPar
For example:

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dates} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{period\PYGZus{}range}\PYG{p}{(}\PYG{n}{start}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{1975q1}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{end}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{2125q4}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{freq}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Q}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{df}\PYG{o}{.}\PYG{n}{index}\PYG{o}{=}\PYG{n}{dates}
\end{sphinxVerbatim}
\end{sphinxadmonition}


\subsection{Leads and lags}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:leads-and-lags}}
\sphinxAtStartPar
In modelflow leads and lags can be indicated by following the variable with a parenthesis and either \sphinxhyphen{}1 or \sphinxhyphen{}2 two for one or two period lags (where the number following the negative sign indicates the number of time periods that are lagged). Positive numbers are used for forward leads (no +sign required).

\sphinxAtStartPar
When \sphinxcode{\sphinxupquote{modelflow}} encounters something like \sphinxcode{\sphinxupquote{A(\sphinxhyphen{}1)}}, it will take the value from the row above the current row. No matter if the index is an integer, a year, quarter or a millisecond. The same goes for leads \sphinxcode{\sphinxupquote{A(+1)}}  That will be the value in the next row.

\sphinxAtStartPar
As a result in a quarterly model \sphinxcode{\sphinxupquote{B=A(\sphinxhyphen{}4)}} would assign B the value of A from teh same quarter in the previous year.


\subsection{.columns lists the column names of a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:columns-lists-the-column-names-of-a-dataframe}}
\sphinxAtStartPar
The method \sphinxcode{\sphinxupquote{.columns}} returns the names of the columns in the dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{columns}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Index([\PYGZsq{}B\PYGZsq{}, \PYGZsq{}C\PYGZsq{}, \PYGZsq{}E\PYGZsq{}, \PYGZsq{}NEW\PYGZsq{}], dtype=\PYGZsq{}object\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.size indicates the dimension of a list}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:size-indicates-the-dimension-of-a-list}}
\sphinxAtStartPar
so \sphinxcode{\sphinxupquote{df.columns.size}} returns the number of columns in a dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{columns}\PYG{o}{.}\PYG{n}{size}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The dataframe df has 4 columns.


\subsection{.eval() evaluates calculates an expression on the data of a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:eval-evaluates-calculates-an-expression-on-the-data-of-a-dataframe}}
\sphinxAtStartPar
.eval is a native dataframe method, which allows us to do calculations on a dataframe. With this method expressions can be evaluated and new columns created.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{X = B*C}
\PYG{l+s+s1}{           THE\PYGZus{}ANSWER = 42}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW    X  THE\PYGZus{}ANSWER
2018  17  1  4   11   17          42
2019  17  2  4   12   34          42
2020  17  3  4   10   51          42
2021  17  6  4   14  102          42
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW
2018  17  1  4   11
2019  17  2  4   12
2020  17  3  4   10
2021  17  6  4   14
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the above example the resulting dataframe is displayed but is not stored.

\sphinxAtStartPar
To store it, the results of the calculation must be assigned to a variable.  The pre\sphinxhyphen{}existing dataframe can be overwritten by assigning it the result of the eval statement.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{eval}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{X = B*C}
\PYG{l+s+s1}{           THE\PYGZus{}ANSWER = 42}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C  E  NEW    X  THE\PYGZus{}ANSWER
2018  17  1  4   11   17          42
2019  17  2  4   12   34          42
2020  17  3  4   10   51          42
2021  17  6  4   14  102          42
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
With this operation the new columns, x and THE\_ANSWER have been appended to the dataframe df.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.eval()}} method is a native pandas method.  As such it cannot handle lagged variables (because pandas do not support the idea of a lagged variable.

\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.mfcalc()}} and the \sphinxcode{\sphinxupquote{upd()}} methods discussed below are \sphinxcode{\sphinxupquote{modelflow}} features appended to dataframe that allows such calculations to be performed.
\end{sphinxadmonition}


\subsection{.loc{[}{]} selects a portion (slice) of a dataframe}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-selects-a-portion-slice-of-a-dataframe}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.loc{[}{]}}} method allows you to display and/or revise specific sub\sphinxhyphen{}sections of a column or row in a dataframe.


\subsubsection{.loc{[}row,column{]} A single element}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-row-column-a-single-element}}
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.loc{[}row,column{]}}} operates on a single cell in the dataframe.  Thus the below displays the value of the cell with index=2019 observation from the  column C.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}:,column{]} A single column}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-column-a-single-column}}
\sphinxAtStartPar
The lone colon in a loc statement indicates all the rows or columns.  Here all of the rows.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{:}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
2018    1
2019    2
2020    3
2021    6
Name: C, dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}row,:{]} A single row}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-row-a-single-row}}
\sphinxAtStartPar
Here all of the columns, for the selected row.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{p}{:}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
B             17
C              2
E              4
NEW           12
X             34
THE\PYGZus{}ANSWER    42
Name: 2019, dtype: int64
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}:,{[}names…{]}{]} Several columns}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-names-several-columns}}
\sphinxAtStartPar
Passing a list in either the rows or columns portion of the loc statement will allow multiple rows or columns to be displayed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{,}\PYG{l+m+mi}{2021}\PYG{p}{]}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C
2018  17  1
2021  17  6
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc using the colon to select a range}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-using-the-colon-to-select-a-range}}
\sphinxAtStartPar
with the colon operator we can also select a range of results.

\sphinxAtStartPar
Here from 2018 to 2019.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{:}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B  C
2018  17  1
2019  17  2
2020  17  3
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsubsection{.loc{[}{]} can also be used on the left hand side to assign values to specific cells}
\label{\detokenize{content/04_PythonEssentials/PythonPackagesEtc:loc-can-also-be-used-on-the-left-hand-side-to-assign-values-to-specific-cells}}
\sphinxAtStartPar
This can be very handy when updating scenarios.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2019}\PYG{p}{:}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} \PYG{o}{=} \PYG{l+m+mi}{17}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
       B   C  E  NEW    X  THE\PYGZus{}ANSWER
2018  17   1  4   11   17          42
2019  17  17  4   12   34          42
2020  17  17  4   10   51          42
2021  17   6  4   14  102          42
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{warning}{Warning:}
\sphinxAtStartPar
The dimensions on the right hand side of = and the left hand side should match. That is: either the dimensions should be the same, or the right hand side should be \sphinxcode{\sphinxupquote{broadcasted}} into the left hand slice.

\sphinxAtStartPar
For more on broadcasting \sphinxhref{https://jakevdp.github.io/PythonDataScienceHandbook/02.05-computation-on-arrays-broadcasting.html}{see here}
\end{sphinxadmonition}

\sphinxAtStartPar
\sphinxstylestrong{For more info on the .loc{[}{]} method}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.loc.html}{Description}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=pandas+dataframe+loc\&newwindow=1}{Search}

\end{itemize}

\sphinxAtStartPar
\sphinxstylestrong{For more info on pandas:}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/}{Pandas homepage}

\item {} 
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/pandas-docs/stable/getting\_started/tutorials.html}{Pandas community tutorials}

\end{itemize}

\sphinxstepscope


\chapter{Modelflows extensions to pandas}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:modelflows-extensions-to-pandas}}\label{\detokenize{content/04_PythonEssentials/UpdateCommand::doc}}
\sphinxAtStartPar
Modeflow inherits all the capabilities of pandas and extends some as well.

\sphinxAtStartPar
As we have seen above we can modify data in a dataframe directly with built\sphinxhyphen{}in pandas functionalities like \sphinxcode{\sphinxupquote{.loc{[}{]}}}.


\section{.upd() method of modelflow}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-method-of-modelflow}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.upd()}} method extends these capabilities in important ways.  It gives the user a concise and expressive way to modify data in a dataframe in the way that a user or database\sphinxhyphen{}manager of the World Bank MFMod models might.

\sphinxAtStartPar
Notably it allows us to employ formula’s to do updates, including lags and leads on variables.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.upd()}}  be used to:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Perform different types of  updates

\item {} 
\sphinxAtStartPar
Perform multiple updates each on a new line

\item {} 
\sphinxAtStartPar
Perform changes over specific periods

\item {} 
\sphinxAtStartPar
Use one input which is used for all time frames, or a input for each time

\item {} 
\sphinxAtStartPar
Preserve pre\sphinxhyphen{}shock growth rates for out of sample time\sphinxhyphen{}periods

\item {} 
\sphinxAtStartPar
Display results

\end{itemize}


\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.upd()}} method operators}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-method-operators}}
\sphinxAtStartPar
Below are some of the operators that can be used in the \sphinxcode{\sphinxupquote{.upd()}} method

\sphinxAtStartPar
\sphinxstylestrong{Types of update:}


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Update to perform
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Use this operator
\\
\hline
\sphinxAtStartPar
Set a variable equal to the input
&
\sphinxAtStartPar
=
\\
\hline
\sphinxAtStartPar
Add the input to the input
&
\sphinxAtStartPar
+
\\
\hline
\sphinxAtStartPar
Set the variable to itself multiplied by the input
&
\sphinxAtStartPar
*
\\
\hline
\sphinxAtStartPar
Increase/Decrease the variable by a percent of itself (1+input/100)
&
\sphinxAtStartPar
\%
\\
\hline
\sphinxAtStartPar
Set the growth rate of the variable to the input
&
\sphinxAtStartPar
=growth
\\
\hline
\sphinxAtStartPar
Change the growth rate of the variable to its current growth rate plus the input value in percentage points
&
\sphinxAtStartPar
+growth
\\
\hline
\sphinxAtStartPar
Specify the amount by which the variable should increase from its previous period level (\(\Delta = var_t - var_{t-1}\)
&
\sphinxAtStartPar
=diff
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}

\begin{sphinxadmonition}{danger}{Danger:}
\sphinxAtStartPar
Note: the syntax of an update command requires that there be a space between variable names and the operators.

\sphinxAtStartPar
Thus \sphinxcode{\sphinxupquote{df.upd("A = 7")}} is fine, but \sphinxcode{\sphinxupquote{df.upd("A =7")}} will generate an error.

\sphinxAtStartPar
Similarly  \sphinxcode{\sphinxupquote{df.upd("A * 1.1")}} is fine, but \sphinxcode{\sphinxupquote{df.upd("A=* 1.1")}} will generate an error.
\end{sphinxadmonition}


\section{\sphinxstyleliteralintitle{\sphinxupquote{.upd()}} some examples}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-some-examples}}

\subsection{Setting up the python environment}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:setting-up-the-python-environment}}
\sphinxAtStartPar
In order to use \sphinxcode{\sphinxupquote{.upd()}} we need to first import all of the necessary libraries to out python session.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{o}{\PYGZpc{}}\PYG{k}{load\PYGZus{}ext} autoreload
\PYG{o}{\PYGZpc{}}\PYG{k}{autoreload} 2

\PYG{c+c1}{\PYGZsh{} First we must import pandas as modelflow into ouir workspace}
\PYG{c+c1}{\PYGZsh{} There is no problem importing multiple times, though it is not very efficient.}
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}

\PYG{k+kn}{from} \PYG{n+nn}{modelclass} \PYG{k+kn}{import} \PYG{n}{model} 
\PYG{c+c1}{\PYGZsh{} functions that improve rendering of modelflow outputs under Jupyter Notebook}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{widescreen}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{model}\PYG{o}{.}\PYG{n}{scroll\PYGZus{}off}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now create a dataframe using standard pandas syntax.  In this instance with years as the index and a dictionary defining the variables and their data.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create a dataframe using standard pandas}

\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{l+m+mi}{6}\PYG{p}{]}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:}\PYG{p}{[}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{,}\PYG{l+m+mi}{4}\PYG{p}{]}\PYG{p}{\PYGZcb{}}\PYG{p}{,}\PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2018}\PYG{p}{,}\PYG{l+m+mi}{2019}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2021}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{df} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      B  C  E
2018  1  1  4
2019  1  2  4
2020  1  3  4
2021  1  6  4
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
If we want to be a bit more creative we could use a loop to create the dataframe for dates that we pass as an argument.  For example, below we create a dataframe df with two Series (A and B), which we initialize with the values 100 for all data points.

\sphinxAtStartPar
In this case we we define the index dynamically as the result of a loop \sphinxcode{\sphinxupquote{index={[}2020+v for v in range(number\_of\_rows){]}}}.

\sphinxAtStartPar
This bit of code runs a loop that runs for number\_of\_rows times setting v equal to 2020+0, 2020+1,…,202+5. The resulting list whose values are assigned to index is {[}2020,2021,2022,2023,2024,2025{]}.

\sphinxAtStartPar
The big advanatge of this method is that if the user wanted to have data created for the period 1990 to 2030, they would only have to change number\_of\_rows from 6 to 41 and 2020 in the loop to 1990.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}define the number of years for which the data is to be created.}
\PYG{n}{number\PYGZus{}of\PYGZus{}rows} \PYG{o}{=} \PYG{l+m+mi}{6} 

\PYG{c+c1}{\PYGZsh{} call the dataframe constructor}
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}
       \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{o}{+}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}rows}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} create row index}
       \PYG{c+c1}{\PYGZsh{} equivalent to index=[2020,2021,2022,2023,2024,2025] }
       \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}                                 \PYG{c+c1}{\PYGZsh{} create column name }
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B
2020  100  100
2021  100  100
2022  100  100
2023  100  100
2024  100  100
2025  100  100
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Use .upd to create a new variable (= operator)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:use-upd-to-create-a-new-variable-operator}}
\sphinxAtStartPar
We know from above that with pandas we can add a column (series) to a dataframe simply by assigning a adding to a dataframe.  For example:

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{df{[}'NEW2'{]}={[}17,12,14,15{]}}}

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.upd()}} provides this functionality as well.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df2}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c = 142}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} 
\PYG{n}{df2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B      C
2020  100  100  142.0
2021  100  100  142.0
2022  100  100  142.0
2023  100  100  142.0
2024  100  100  142.0
2025  100  100  142.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
note that the new variable name is in lower case here.  We know that lowercase letters are not legal \sphinxcode{\sphinxupquote{modelflow}} variable names.  But because the .upd() method knows this also, it automatically translates these into upper case so that the statement works.
\end{sphinxadmonition}


\subsection{multiple updates and specific time periods}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:multiple-updates-and-specific-time-periods}}
\sphinxAtStartPar
The modelflow method \sphinxcode{\sphinxupquote{.upd()}} takes a string as an argument.  That string can contain a single update command or can contain multiple commands.

\sphinxAtStartPar
The below illustrates this, modifying two existing variables A, B over different time periods and creating a new variable.

\begin{sphinxadmonition}{danger}{Danger:}
\sphinxAtStartPar
Note that the third line inherits the time period of the previous line.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s2}{\PYGZlt{}2021 2024\PYGZgt{} A = 42 44 45 46    \PYGZsh{} 4 years}
\PYG{l+s+s2}{\PYGZlt{}2020     \PYGZgt{} B = 200            \PYGZsh{} 1 year }
\PYG{l+s+s2}{c = 500                        \PYGZsh{} Same period as previous}
\PYG{l+s+s2}{\PYGZlt{}\PYGZhy{}0 \PYGZhy{}1\PYGZgt{} D = 33                   \PYGZsh{} All years }
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B      C     D
2020  100  200  500.0  33.0
2021   42  100    0.0  33.0
2022   44  100    0.0  33.0
2023   45  100    0.0  33.0
2024   46  100    0.0  33.0
2025  100  100    0.0  33.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
**Time scope of .upd()**



The update command takes a variety of mathematical operators ```=, +, *, \PYGZpc{} =GROWTH, +GROWTH, =DIFF``` and applies them to data for the period set in the leading \PYGZlt{}\PYGZgt{}.

If the user wants to modify a series or group of series for only a specific point in time or a period of time, she can indicate the period in the command line.

 \PYGZhy{} If **one date** is specified the operation is applied to a single point in time
 \PYGZhy{} If **two dates**  are specifies the operation is applied over a period of time.

The time will persist until re\PYGZhy{}set with a new time specification. Useful to avoid visual noise if several variables are going to be updated for the same time period. 

 \PYGZhy{} To indicate the start of the dataframe use \PYGZhy{}0
 \PYGZhy{} To indicate the end of the dataframe use \PYGZhy{}1
 
If no time is provided the dataframe start and end period will be used.  
\end{sphinxVerbatim}


\subsubsection{Setting specific datapoints to specific values}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:setting-specific-datapoints-to-specific-values}}
\sphinxAtStartPar
In this example, upd uses the equals operator.  This indicates that the variable a should be set equal to the indicated values following the = operator (42 44 45 46 in this example). The dates enclosed in <> indicate the period over which the change should be applied.

\sphinxAtStartPar
Either:
\begin{itemize}
\item {} 
\sphinxAtStartPar
The number of data points provided must match the number of dates in the period, Or

\item {} 
\sphinxAtStartPar
Only one data point is provided, it is applied to all dates in the period.

\end{itemize}

\sphinxAtStartPar
If only one period is to be modified then it can be followed by just one date.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s2}{\PYGZlt{}2021 2024\PYGZgt{} A = 42 44 45 46    \PYGZsh{} 4 years}
\PYG{l+s+s2}{\PYGZlt{}2020     \PYGZgt{} B = 200            \PYGZsh{} 1 year }
\PYG{l+s+s2}{c = 500}
\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B      C
2020  100  200  500.0
2021   42  100    0.0
2022   44  100    0.0
2023   45  100    0.0
2024   46  100    0.0
2025  100  100    0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Adding  the specified  values to all values in a range (the + operator)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:adding-the-specified-values-to-all-values-in-a-range-the-operator}}
\sphinxAtStartPar
NB: Here upd with the  + operator indicates that we are adding 42.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsh{} Or one number to all years in between start and end }
\PYG{l+s+s1}{\PYGZlt{}2022 2024\PYGZgt{} B  +  42    \PYGZsh{} one value broadcast to 3 years }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B
2020  100  100
2021  100  100
2022  100  142
2023  100  142
2024  100  142
2025  100  100
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Multiplying all values in a range by the specified values (the * operator)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:multiplying-all-values-in-a-range-by-the-specified-values-the-operator}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s1}{\PYGZlt{}2021 2023\PYGZgt{} A *  42 44 55}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
         A    B
2020   100  100
2021  4200  100
2022  4400  100
2023  5500  100
2024   100  100
2025   100  100
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Increasing all  values in a range by a  specified percent amount (the \% operator)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:increasing-all-values-in-a-range-by-a-specified-percent-amount-the-operator}}
\sphinxAtStartPar
In this example:
\begin{itemize}
\item {} 
\sphinxAtStartPar
A is increased by 42 and 44\% over the range 2021 through 2022.

\item {} 
\sphinxAtStartPar
B is increased by 10 percent in all years

\item {} 
\sphinxAtStartPar
C, a new variable, is created and set to 100 for the whole range

\item {} 
\sphinxAtStartPar
C is decreased by 12 percent over the range 2023 through 2025.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2021 2022 \PYGZgt{} A }\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{  42 44   }
\PYG{l+s+s1}{\PYGZlt{}\PYGZhy{}0 \PYGZhy{}1\PYGZgt{} B }\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{ 10            \PYGZsh{} all rows }
\PYG{l+s+s1}{C = 100                   \PYGZsh{} all rows persist }
\PYG{l+s+s1}{\PYGZlt{}2023 2025\PYGZgt{} C }\PYG{l+s+s1}{\PYGZpc{}}\PYG{l+s+s1}{ \PYGZhy{}12       \PYGZsh{} now only for 3 years }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A      B      C
2020  100  110.0  100.0
2021  142  110.0  100.0
2022  144  110.0  100.0
2023  100  110.0   88.0
2024  100  110.0   88.0
2025  100  110.0   88.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Set the percent growth rate to specified values (=GROWTH)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:set-the-percent-growth-rate-to-specified-values-growth}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s1}{\PYGZlt{}2021 2022\PYGZgt{} A =GROWTH  1 5  }
\PYG{l+s+s1}{\PYGZlt{}2020\PYGZgt{} c = 100 }
\PYG{l+s+s1}{\PYGZlt{}2021 2025\PYGZgt{} c =GROWTH 2 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dataframe:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Growth:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Explained b}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Dataframe:
           A    B           C
2020  100.00  100  100.000000
2021  101.00  100  102.000000
2022  106.05  100  104.040000
2023  100.00  100  106.120800
2024  100.00  100  108.243216
2025  100.00  100  110.408080

Growth:
             A    B    C
2020       NaN  NaN  NaN
2021  1.000000  0.0  2.0
2022  5.000000  0.0  2.0
2023 \PYGZhy{}5.704856  0.0  2.0
2024  0.000000  0.0  2.0
2025  0.000000  0.0  2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Add or subtract from the existing percent growth rate (+GROWTH operator)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:add-or-subtract-from-the-existing-percent-growth-rate-growth-operator}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s1}{\PYGZlt{}2021 2025\PYGZgt{} A =GROWTH  1  }
\PYG{l+s+s1}{\PYGZsh{} now we add values  to the growth rate, }
\PYG{l+s+s1}{a +growth   2 3 4 5 6 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dataframe:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Growth:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Dataframe:
               A    B
2020  100.000000  100
2021  103.000000  100
2022  107.120000  100
2023  112.476000  100
2024  119.224560  100
2025  127.570279  100

Growth:
        A    B
2020  NaN  NaN
2021  3.0  0.0
2022  4.0  0.0
2023  5.0  0.0
2024  6.0  0.0
2025  7.0  0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Set \protect\(\Delta = var_t - var_{t-1}\protect\) to specified values (=diff operator)}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:set-delta-var-t-var-t-1-to-specified-values-diff-operator}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s1}{\PYGZlt{} 2021 2022\PYGZgt{} A =diff  2 4   }
\PYG{l+s+s1}{\PYGZsh{} cv number to all years in between start and end }

\PYG{l+s+s1}{\PYGZlt{}2020 \PYGZgt{} same = 100 }
\PYG{l+s+s1}{\PYGZlt{}2021 2025\PYGZgt{} same =diff  2  }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B   SAME
2020  100  100  100.0
2021  102  100  102.0
2022  106  100  104.0
2023  100  100  106.0
2024  100  100  108.0
2025  100  100  110.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Recall  that we have not overwritten df, so the df dataframe is unchanged.}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:recall-that-we-have-not-overwritten-df-so-the-df-dataframe-is-unchanged}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A    B
2020  100  100
2021  100  100
2022  100  100
2023  100  100
2024  100  100
2025  100  100
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Keep growth rates after the update time – the –kg option}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:keep-growth-rates-after-the-update-time-the-kg-option}}
\sphinxAtStartPar
In a long projection it can sometime be useful to be able to update variables for which new information is available, but for the subsequent periods keep the growth rate the same as before the update. In database management this is frequently done when two time\sphinxhyphen{}series with different levels are spliced together.

\sphinxAtStartPar
The \sphinxhyphen{}kg or –keep\_growth option instructs modelview to calculate the growth rate of the existing pre\sphinxhyphen{}change series, and then use it to preserve the pre\sphinxhyphen{}change growth rates of the series for the periods that were \sphinxstylestrong{not} changed.

\sphinxAtStartPar
This allows to update variables for which new information is available, but keep the growth rate the same as before the update in the period after the update time.


\subsubsection{The default keep\_growth behaviour}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:the-default-keep-growth-behaviour}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{upd()}} method has a parameter \sphinxcode{\sphinxupquote{keep\_growth}}, which by default is equal to \sphinxcode{\sphinxupquote{False}}.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{keep\_growth}} determines how data in  the time periods after those where an update is executed are treated.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{keep\_growth}} is \sphinxcode{\sphinxupquote{False}} then data in the sub\sphinxhyphen{}period after a change is left unchanged.

\sphinxAtStartPar
if \sphinxcode{\sphinxupquote{keep\_growth}} is set to “\sphinxcode{\sphinxupquote{True}}” then the system will preserve the pre\sphinxhyphen{}change growth rate of the affected variable in the time period \sphinxstyleemphasis{after the change}.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
At the line level:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{keep\_growth=True}} can be expressed as –kg

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{keep\_growth=False}} can be expressed as –nkg

\end{itemize}
\end{sphinxadmonition}

\sphinxAtStartPar
Let’s see this in a concrete example.  Consider the following \sphinxcode{\sphinxupquote{dataframe}} df with two variables A and B, that each grow by 2\% per period, with A initialized at a level of 100 and B at a level of 110 so that we can see each separately on a graph.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}
       \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{o}{+}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}rows}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} create row index}
       \PYG{c+c1}{\PYGZsh{} equivalent to index=[2020,2021,2022,2023,2024,2025] }
       \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)} 

\PYG{n}{df}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2021 \PYGZhy{}1\PYGZgt{} A =growth 2}
\PYG{l+s+s2}{           \PYGZlt{}2020 \PYGZhy{}1\PYGZgt{}   B = 110}
\PYG{l+s+s2}{          \PYGZlt{}2021 \PYGZhy{}1\PYGZgt{}    B =growth 2}
\PYG{l+s+s2}{          }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{} Store these variables for later use in comparisons}
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A\PYGZus{}ORIG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZus{}ORIG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{=}\PYG{n}{df}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020  100.000000  110.000000  100.000000  110.000000
2021  102.000000  112.200000  102.000000  112.200000
2022  104.040000  114.444000  104.040000  114.444000
2023  106.120800  116.732880  106.120800  116.732880
2024  108.243216  119.067538  108.243216  119.067538
2025  110.408080  121.448888  110.408080  121.448888
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: \PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{c02b4af773579f433eace4f785e543742d5ef841906e6b994877f90732f66fd1}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Now lets modify each by adding 5 to the level in 2022 and 2023.  For B we will do setting the keep\_growth option as False and for ‘B’ keep\_growth positive.  While the keep\_growth is a global variable it can be set at the line level also using the –kg option (\sphinxcode{\sphinxupquote{keep\_growth=True}}) and –nkg option ( (\sphinxcode{\sphinxupquote{keep\_growth=False}}).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}
\PYG{l+s+s2}{            \PYGZlt{}2022 2023\PYGZgt{} A + 5 \PYGZhy{}\PYGZhy{}kg}
\PYG{l+s+s2}{            \PYGZlt{}2022 2023\PYGZgt{} B + 5 \PYGZhy{}\PYGZhy{}nkg}
\PYG{l+s+s2}{            }\PYG{l+s+s2}{\PYGZdq{}\PYGZdq{}\PYGZdq{}}\PYG{p}{)}

\PYG{n}{df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A\PYGZus{}ORIG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B\PYGZus{}ORIG}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
    
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: \PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{b190fe24d2cb993f17006d33ba0fb9966a5860917c21cee0cbc7a3ba4322c9df}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In the first example ‘A’ (the green and blue lines) the level of A is increased by 5 for two periods (2021\sphinxhyphen{}2022) and then the subsequent values are also increased they were calculated to maintain the growth rate of the original series.

\sphinxAtStartPar
For the ‘B’ variable the same level change was input but because of the \sphinxcode{\sphinxupquote{\sphinxhyphen{}\sphinxhyphen{}nkg}} (equivalent to \sphinxcode{\sphinxupquote{keep\_growth=False}} ) the periods after the change were affected retained their old values.

\sphinxAtStartPar
Below we plot the growth rates of the two transformed series.

\sphinxAtStartPar
Here series both series accelerate growth in 2022 By slightly less than 5 percentage points because a) the base of each is more than 100, with the base of B being higher (it was initialized at 110). In 2023 teh growth rate of A returns to 2 percent, while the growth rate of B is actually negative because the level (see earlier graph) has fallen back to its original level.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dfg}\PYG{o}{=}\PYG{n}{df}\PYG{p}{[}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}
\PYG{n}{dfg}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}Axes: \PYGZgt{}
\end{sphinxVerbatim}

\noindent\sphinxincludegraphics{{93fc87a8e8ede996fa596d14d140f87c73411dfd2bd0aa8433f137f2597a0b85}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstylestrong{Python constructs}
\begin{quote}

\sphinxAtStartPar
print(f’Dataframe:\textbackslash{}n\{res\}\textbackslash{}n\textbackslash{}nGrowth:\textbackslash{}n\{res.pct\_change()*100\}\textbackslash{}n’)
\end{quote}

\sphinxAtStartPar
Uses


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Python construct
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Explanation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Links
\\
\hline
\sphinxAtStartPar
‘\textbackslash{}n’
&
\sphinxAtStartPar
A line break
&
\sphinxAtStartPar

\\
\hline
\sphinxAtStartPar
dataframe.pct\_change
&
\sphinxAtStartPar
Percentage change between the current and a prior element.
&
\sphinxAtStartPar
\sphinxhref{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.pct\_change.html}{Description}
\\
\hline
\sphinxAtStartPar
f’\{varname\} = ….’
&
\sphinxAtStartPar
A f\sphinxhyphen{}string, \{expression\} is replaced by the value of expression
&
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=python+f-string\&newwindow=1}{Search}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\section{.upd(,,,keep\_growth) some more examples}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-keep-growth-some-more-examples}}

\subsection{Initialize a new dataframe First make a dataframe with some growth rate}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:initialize-a-new-dataframe-first-make-a-dataframe-with-some-growth-rate}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dftest} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}
       \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{o}{+}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}rows}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} create row index}
       \PYG{c+c1}{\PYGZsh{} equivalent to index=[2020,2021,2022,2023,2024,2025] }
       \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}                                 \PYG{c+c1}{\PYGZsh{} create column name }


\PYG{n}{original} \PYG{o}{=} \PYG{n}{dftest}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}2021 2025\PYGZgt{} a =growth 1 2 3 4 5}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}  
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Levels:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{original}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Growth:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{original}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Levels:
               A
2020  100.000000
2021  101.000000
2022  103.020000
2023  106.110600
2024  110.355024
2025  115.872775

Growth:
        A
2020  NaN
2021  1.0
2022  2.0
2023  3.0
2024  4.0
2025  5.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{now update A in 2021 to 2023 to a new value}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:now-update-a-in-2021-to-2023-to-a-new-value}}
\sphinxAtStartPar
Below we do the same operation, the first time we assign the updated value to the dataframe nkg and the default behaviour of \sphinxcode{\sphinxupquote{keep\_growth}} is \sphinxcode{\sphinxupquote{False}}

\sphinxAtStartPar
In the second example we use the \sphinxcode{\sphinxupquote{\sphinxhyphen{}kg}} line option, telling modelview to maintain the growth rates of the dependent variable in the periods after the update is executed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{nokg} \PYG{o}{=} \PYG{n}{original}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2021 2025\PYGZgt{}  a =growth 1 2 3 4 5 }
\PYG{l+s+s1}{\PYGZlt{}2021 2023\PYGZgt{}  a = 120  }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}\PYG{n}{lprint}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}

\PYG{n}{kg} \PYG{o}{=} \PYG{n}{original}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2021 2025\PYGZgt{}  a =growth 1 2 3 4 5 }
\PYG{l+s+s1}{\PYGZlt{}2021 2023\PYGZgt{}  a = 120  \PYGZhy{}\PYGZhy{}kg}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}\PYG{n}{lprint}\PYG{o}{=}\PYG{l+m+mi}{0}\PYG{p}{)}


\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{growth No kg:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{nokg}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{growth kg:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{kg}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Level No kg:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{nokg}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Level kg:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{kg}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
growth No kg:
             A
2020       NaN
2021  20.00000
2022   0.00000
2023   0.00000
2024  \PYGZhy{}8.03748
2025   5.00000
growth kg:
         A
2020   NaN
2021  20.0
2022   0.0
2023   0.0
2024   4.0
2025   5.0


Level No kg:
               A
2020  100.000000
2021  120.000000
2022  120.000000
2023  120.000000
2024  110.355024
2025  115.872775
Level kg:
           A
2020  100.00
2021  120.00
2022  120.00
2023  120.00
2024  124.80
2025  131.04
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the first where KG (keep\_growth) \sphinxstylestrong{was not set}, because the level was set constant for three periods at 120 the rate of growth was 0 for the final two years of the set period.  But following this update, the level of A in 2023 is 120. With \sphinxcode{\sphinxupquote{keep\_Growth=False}} (its default value)m the level of A in 2024 remains at its unchanged  unchanged (lower) level of 100.35. As a result, the growth rate in 2024 is negative.

\sphinxAtStartPar
In the \sphinxstylestrong{–kg} example, the pre\sphinxhyphen{}exsting growth rate (of 4\%) is applied to the new value of 120 and so the level in 2024 is (120*1.04)=124.8
\end{sphinxadmonition}


\subsubsection{.upd() with the option keep\_growth set globally}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-with-the-option-keep-growth-set-globally}}
\sphinxAtStartPar
Above we used the line level option –keep\_growth or –kg to keep the growth rate for a given operation.

\sphinxAtStartPar
This works because by default the option Keep\_growth is set to false, so in effect we are temporarily setting it to true for the specific lines above.

\sphinxAtStartPar
We can also change the keep\_growth variable for all the lines by setting the option in the command line.

\sphinxAtStartPar
In the below example we set the global option \sphinxcode{\sphinxupquote{keep\_growth=True}}.

\sphinxAtStartPar
Now as default, all lines will keep the growth rate
\begin{itemize}
\item {} 
\sphinxAtStartPar
c,d are updated in 2022 and 2023 and keep the growth rates afterwards

\item {} 
\sphinxAtStartPar
e the –no\_keep\_growth in this line prevents the updating 2024\sphinxhyphen{}2025

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{} Create a data frame}
\PYG{n}{dftest} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}\PYG{l+m+mi}{100}\PYG{p}{,}
       \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{o}{+}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{n}{number\PYGZus{}of\PYGZus{}rows}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,} \PYG{c+c1}{\PYGZsh{} create row index}
       \PYG{c+c1}{\PYGZsh{} equivalent to index=[2020,2021,2022,2023,2024,2025] }
       \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{B}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{C}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{D}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{E}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{)}                                 \PYG{c+c1}{\PYGZsh{} create column name }
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020  100.000000  110.000000  100.000000  110.000000
2021  102.000000  112.200000  102.000000  112.200000
2022  109.040000  119.444000  104.040000  114.444000
2023  111.120800  121.732880  106.120800  116.732880
2024  113.343216  119.067538  108.243216  119.067538
2025  115.610080  121.448888  110.408080  121.448888
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dfres} \PYG{o}{=} \PYG{n}{dftest}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2022 2023\PYGZgt{} c = 200 }
\PYG{l+s+s1}{\PYGZlt{}2022 2023\PYGZgt{} d = 300  }
\PYG{l+s+s1}{\PYGZlt{}2022 2023\PYGZgt{} e = 400  \PYGZhy{}\PYGZhy{}no\PYGZus{}keep\PYGZus{}growth }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}\PYG{n}{keep\PYGZus{}growth}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} \PYGZlt{}===  Here we have set the keep\PYGZus{}growth to True for the entirety of the command, }
                       \PYG{c+c1}{\PYGZsh{} except for e where it is overridden by the \PYGZhy{}\PYGZhy{}no\PYGZus{}keep\PYGZus{}growth flag}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Dataframe:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{dfres}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Growth:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{dfres}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Dataframe:
        A    B      C      D    E
2020  100  100  100.0  100.0  100
2021  100  100  100.0  100.0  100
2022  100  100  200.0  300.0  400
2023  100  100  200.0  300.0  400
2024  100  100  200.0  300.0  100
2025  100  100  200.0  300.0  100

Growth:
        A    B      C      D      E
2020  NaN  NaN    NaN    NaN    NaN
2021  0.0  0.0    0.0    0.0    0.0
2022  0.0  0.0  100.0  200.0  300.0
2023  0.0  0.0    0.0    0.0    0.0
2024  0.0  0.0    0.0    0.0  \PYGZhy{}75.0
2025  0.0  0.0    0.0    0.0    0.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Some more advanced example}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:some-more-advanced-example}}
\sphinxAtStartPar
These examples continue to use update, but with some examples of how to embed Python loops into commands.


\subsubsection{First create a string with update lines}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:first-create-a-string-with-update-lines}}
\sphinxAtStartPar
In this example we create a string dynamically is comprised of a variety of update statements.  The loop repeats the two lines above replacing the \{varname\} expression with c d e and f as the loop is executed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{lines} \PYG{o}{=} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{join}\PYG{p}{(}                               
 \PYG{p}{[}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{l+s+s1}{\PYGZlt{}2020     \PYGZgt{} }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{varname}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ = 100 }
\PYG{l+s+s1}{      \PYGZlt{}2021 2025\PYGZgt{} }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{varname}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ =growth 1 2 3 4 5}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
     \PYG{k}{for} \PYG{n}{varname} \PYG{o+ow}{in} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{c d e f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{o}{.}\PYG{n}{split}\PYG{p}{(}\PYG{p}{)}\PYG{p}{]}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}2020     \PYGZgt{} c = 100 
      \PYGZlt{}2021 2025\PYGZgt{} c =growth 1 2 3 4 5
\PYGZlt{}2020     \PYGZgt{} d = 100 
      \PYGZlt{}2021 2025\PYGZgt{} d =growth 1 2 3 4 5
\PYGZlt{}2020     \PYGZgt{} e = 100 
      \PYGZlt{}2021 2025\PYGZgt{} e =growth 1 2 3 4 5
\PYGZlt{}2020     \PYGZgt{} f = 100 
      \PYGZlt{}2021 2025\PYGZgt{} f =growth 1 2 3 4 5
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
\sphinxstyleemphasis{\sphinxstylestrong{Python constructs}}

\sphinxAtStartPar
The creation of update lines involves a number of useful python constructs. A short
description:


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Python construct
&\sphinxstyletheadfamily 
\sphinxAtStartPar
explanation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Google
\\
\hline
\sphinxAtStartPar
‘a b’.split()
&
\sphinxAtStartPar
splits a string by \sphinxcode{\sphinxupquote{blanks}}into a list
&
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=python+split\&newwindow=1}{Search}
\\
\hline
\sphinxAtStartPar
‘\textbackslash{}n’.join()
&
\sphinxAtStartPar
Creates a string from a list of string separated by \textbackslash{}n (linebreak)
&
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=python+string+join\&newwindow=1}{Search}
\\
\hline
\sphinxAtStartPar
f’\{varname\} = ….’
&
\sphinxAtStartPar
A f\sphinxhyphen{}string, \{varname\} is replaced by the value of varname
&
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=python+f-string\&newwindow=1}{Search}
\\
\hline
\sphinxAtStartPar
{[}varname for varname in a\_list{]}
&
\sphinxAtStartPar
List comprehension which creates an implicit loop
&
\sphinxAtStartPar
\sphinxhref{https://www.google.com/search?q=python+list+comprehension\&newwindow=1}{Search}
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\end{sphinxadmonition}


\subsubsection{Use the update lines to update a dataframe}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:use-the-update-lines-to-update-a-dataframe}}
\sphinxAtStartPar
Here we pass the variable lines to the \sphinxcode{\sphinxupquote{upd}} method.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{dfnew} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{n}{lines}\PYG{p}{)}
\PYG{n}{dfnew}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG           C           D  \PYGZbs{}
2020  100.000000  110.000000  100.000000  110.000000  100.000000  100.000000   
2021  102.000000  112.200000  102.000000  112.200000  101.000000  101.000000   
2022  109.040000  119.444000  104.040000  114.444000  103.020000  103.020000   
2023  111.120800  121.732880  106.120800  116.732880  106.110600  106.110600   
2024  113.343216  119.067538  108.243216  119.067538  110.355024  110.355024   
2025  115.610080  121.448888  110.408080  121.448888  115.872775  115.872775   

               E           F  
2020  100.000000  100.000000  
2021  101.000000  101.000000  
2022  103.020000  103.020000  
2023  106.110600  106.110600  
2024  110.355024  110.355024  
2025  115.872775  115.872775  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{–kg can replace –keep\_growth and –nkg can replace –non\_keep\_growth}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:kg-can-replace-keep-growth-and-nkg-can-replace-non-keep-growth}}
\sphinxAtStartPar
Just to make typing more easy


\section{Update several variable in one line}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:update-several-variable-in-one-line}}
\sphinxAtStartPar
Sometime there is a need to update several variable with the same value over the same time frame. To ease this case .update can accept several variables in one line

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2022 2024\PYGZgt{} h i j k =      40 }
\PYG{l+s+s1}{\PYGZlt{}2020\PYGZgt{}      p q r s =       1000}
\PYG{l+s+s1}{\PYGZlt{}2021 \PYGZhy{}1\PYGZgt{}   p q r s =growth 2     \PYGZsh{} \PYGZhy{}1 indicates the last year }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG     H     I     J     K  \PYGZbs{}
2020  100.000000  110.000000  100.000000  110.000000   0.0   0.0   0.0   0.0   
2021  102.000000  112.200000  102.000000  112.200000   0.0   0.0   0.0   0.0   
2022  109.040000  119.444000  104.040000  114.444000  40.0  40.0  40.0  40.0   
2023  111.120800  121.732880  106.120800  116.732880  40.0  40.0  40.0  40.0   
2024  113.343216  119.067538  108.243216  119.067538  40.0  40.0  40.0  40.0   
2025  115.610080  121.448888  110.408080  121.448888   0.0   0.0   0.0   0.0   

                P            Q            R            S  
2020  1000.000000  1000.000000  1000.000000  1000.000000  
2021  1020.000000  1020.000000  1020.000000  1020.000000  
2022  1040.400000  1040.400000  1040.400000  1040.400000  
2023  1061.208000  1061.208000  1061.208000  1061.208000  
2024  1082.432160  1082.432160  1082.432160  1082.432160  
2025  1104.080803  1104.080803  1104.080803  1104.080803  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{.upd(,,scale=<number, default=1>) Scale the updates}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-scale-number-default-1-scale-the-updates}}
\sphinxAtStartPar
When running a scenario it can be useful to be able to create a number of scenarios based on one update but with different scale.

\sphinxAtStartPar
This can be particularly useful when we want to do sensitivity analyses of model results, depending on how heavily a shocked variable is hit

\sphinxAtStartPar
When using the scale option, scale=0  the baseline while scale=0.5 is a scenario half
the severity.

\sphinxAtStartPar
In the example below the values of the dataframes are printed. We use the scale option (setting to to 0, 0.5 and 1) to run three scenarios using the same code but where the update in each case is multiplied by either 0, 0.5 or 1.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
Here we are just printing the outputs, a more interesting example would involve the solving a  model using different levels of a given shock.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{input dataframe: }\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{df}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{severity} \PYG{o+ow}{in} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{:} 
    \PYG{c+c1}{\PYGZsh{} First make a dataframe with some growth rate }
    \PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{    \PYGZlt{}2021 2025\PYGZgt{}}
\PYG{l+s+s1}{    a =growth 1 2 3 4 5 }
\PYG{l+s+s1}{    b + 10}
\PYG{l+s+s1}{    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}\PYG{n}{scale}\PYG{o}{=}\PYG{n}{severity}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{severity}\PYG{l+s+si}{=\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Dataframe:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{Growth:}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+si}{\PYGZob{}}\PYG{n}{res}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
    \PYG{c+c1}{\PYGZsh{}  }
    \PYG{c+c1}{\PYGZsh{} Here the updated dataframe is only printed. }
    \PYG{c+c1}{\PYGZsh{} A more realistic use case is to simulate a model like this: }
    \PYG{c+c1}{\PYGZsh{} dummy\PYGZus{} = mpak(res,keep=\PYGZsq{}Severity \PYGZob{}serverity\PYGZcb{}\PYGZsq{})    \PYGZsh{} more realistic }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
input dataframe: 
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020  100.000000  110.000000  100.000000  110.000000
2021  102.000000  112.200000  102.000000  112.200000
2022  109.040000  119.444000  104.040000  114.444000
2023  111.120800  121.732880  106.120800  116.732880
2024  113.343216  119.067538  108.243216  119.067538
2025  115.610080  121.448888  110.408080  121.448888


severity=0
Dataframe:
          A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020  100.0  110.000000  100.000000  110.000000
2021  100.0  112.200000  102.000000  112.200000
2022  100.0  119.444000  104.040000  114.444000
2023  100.0  121.732880  106.120800  116.732880
2024  100.0  119.067538  108.243216  119.067538
2025  100.0  121.448888  110.408080  121.448888

Growth:
        A         B  A\PYGZus{}ORIG  B\PYGZus{}ORIG
2020  NaN       NaN     NaN     NaN
2021  0.0  2.000000     2.0     2.0
2022  0.0  6.456328     2.0     2.0
2023  0.0  1.916279     2.0     2.0
2024  0.0 \PYGZhy{}2.189501     2.0     2.0
2025  0.0  2.000000     2.0     2.0


severity=0.5
Dataframe:
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020  100.000000  110.000000  100.000000  110.000000
2021  100.500000  117.200000  102.000000  112.200000
2022  101.505000  124.444000  104.040000  114.444000
2023  103.027575  126.732880  106.120800  116.732880
2024  105.088126  124.067538  108.243216  119.067538
2025  107.715330  126.448888  110.408080  121.448888

Growth:
        A         B  A\PYGZus{}ORIG  B\PYGZus{}ORIG
2020  NaN       NaN     NaN     NaN
2021  0.5  6.545455     2.0     2.0
2022  1.0  6.180887     2.0     2.0
2023  1.5  1.839285     2.0     2.0
2024  2.0 \PYGZhy{}2.103118     2.0     2.0
2025  2.5  1.919399     2.0     2.0


severity=1
Dataframe:
               A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020  100.000000  110.000000  100.000000  110.000000
2021  101.000000  122.200000  102.000000  112.200000
2022  103.020000  129.444000  104.040000  114.444000
2023  106.110600  131.732880  106.120800  116.732880
2024  110.355024  129.067538  108.243216  119.067538
2025  115.872775  131.448888  110.408080  121.448888

Growth:
        A          B  A\PYGZus{}ORIG  B\PYGZus{}ORIG
2020  NaN        NaN     NaN     NaN
2021  1.0  11.090909     2.0     2.0
2022  2.0   5.927987     2.0     2.0
2023  3.0   1.768240     2.0     2.0
2024  4.0  \PYGZhy{}2.023293     2.0     2.0
2025  5.0   1.845042     2.0     2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{.upd(,,lprint=True ) prints values the before and after update}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-lprint-true-prints-values-the-before-and-after-update}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{lPrint}} option of the method \sphinxcode{\sphinxupquote{upd()}} is by defualt \sphinxcode{\sphinxupquote{= False}}.  By setting it true an update command will output the results of the calculation comapriong the values of the dataframe (over the impacted period) before, after and the difference between the two.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZsh{} Same number of values as years}
\PYG{l+s+s1}{\PYGZlt{}2021 2022\PYGZgt{} A *  42 44}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}\PYG{n}{lprint}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Update * [42.0, 44.0] 2021 2022
A                    Before                After                 Diff
2021               102.0000            4284.0000            4182.0000
2022               109.0400            4797.7600            4688.7200
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
                A           B      A\PYGZus{}ORIG      B\PYGZus{}ORIG
2020   100.000000  110.000000  100.000000  110.000000
2021  4284.000000  112.200000  102.000000  112.200000
2022  4797.760000  119.444000  104.040000  114.444000
2023   111.120800  121.732880  106.120800  116.732880
2024   113.343216  119.067538  108.243216  119.067538
2025   115.610080  121.448888  110.408080  121.448888
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{.upd(,,create=True ) Requires the variable to exist}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:upd-create-true-requires-the-variable-to-exist}}
\sphinxAtStartPar
Until now .upd has created variables if they did not exist in the input dataframe.

\sphinxAtStartPar
To catch misspellings the parameter \sphinxcode{\sphinxupquote{create}} can be set to False.
New variables will not be created, and an exception will be raised.

\sphinxAtStartPar
Here Pythons exception handling is used, so the notebook will continue to run the cells below.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{try}\PYG{p}{:}
    \PYG{n}{xx} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{    \PYGZsh{} Same number of values as years}
\PYG{l+s+s1}{    \PYGZlt{}2021 2022\PYGZgt{} Aa *  42 44}
\PYG{l+s+s1}{    }\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{,}\PYG{n}{create}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{xx}\PYG{p}{)}
\PYG{k}{except} \PYG{n+ne}{Exception} \PYG{k}{as} \PYG{n}{inst}\PYG{p}{:}
    \PYG{n}{xx} \PYG{o}{=} \PYG{k+kc}{None}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{n}{inst}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Variable to update not found:AA, timespan = [2021 2022] 
Set create=True if you want the variable created: 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{The call}
\label{\detokenize{content/04_PythonEssentials/UpdateCommand:the-call}}
\sphinxAtStartPar
def upd(indf, updates, lprint=False,scale = 1.0,create=True,keep\_growth=False,start=’’,end=’’)

\begin{sphinxVerbatim}[commandchars=\\\{\}]
Args:
        indf (DataFrame): input dataframe.
        basis (string): lines with variable updates look below.
        lprint (bool, optional): if True each update is printed  Defaults to False.
        scale (float, optional): A multiplier used on all update input . Defaults to 1.0.
        create (bool, optional): Creates a variables if not in the dataframe . Defaults to True.
        keep\PYGZus{}growth(bool, optional): Keep the growth rate after the update time frame. Defaults to False.

    Returns:
        df (TYPE): the updated dataframe .
        
    A line in updates looks like this:     
           
    \PYGZdq{}\PYGZlt{}\PYGZdq{}[[start] end]\PYGZdq{}\PYGZgt{}\PYGZdq{} \PYGZlt{}var....\PYGZgt{} \PYGZlt{}=|+|*|\PYGZpc{}|=growth|+growth|=diff\PYGZgt{} \PYGZlt{}value\PYGZgt{}...  [\PYGZhy{}\PYGZhy{}keep\PYGZus{}growth\PYGZus{}rate|\PYGZhy{}\PYGZhy{}no\PYGZus{}keep\PYGZus{}growth\PYGZus{}rate]
\end{sphinxVerbatim}

\sphinxstepscope


\chapter{\sphinxstyleliteralintitle{\sphinxupquote{.mfcalc()}} an extension of standard Pandas}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-an-extension-of-standard-pandas}}\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames::doc}}

\section{.mfcalc usage}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-usage}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{.mfcalc()}} method extends dataframe and the method \sphinxcode{\sphinxupquote{.upd()}}.  It can be particularly useful when creating scenarios.

\sphinxAtStartPar
But it can also be used to perform quick and dirty  calculations or even to see how modelflow would normalize an equation.


\section{workspace initialization}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:workspace-initialization}}
\sphinxAtStartPar
Setting up our python session to use pandas and modelflow by importing their packages.  \sphinxcode{\sphinxupquote{modelmf}} is an extension of dataframes that is part of the modelflow installation package (and also used by modelflow itself).

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{pandas} \PYG{k}{as} \PYG{n+nn}{pd}  \PYG{c+c1}{\PYGZsh{} Python data science library}
\PYG{k+kn}{import} \PYG{n+nn}{modelmf}       \PYG{c+c1}{\PYGZsh{} Add useful features to pandas dataframes }
                     \PYG{c+c1}{\PYGZsh{} using utlities initially developed for modelflow}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Create a  simple dataframe}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:create-a-simple-dataframe}}
\sphinxAtStartPar
Create a Pandas dataframe with one column with the name A and 6 rows.

\sphinxAtStartPar
Set set the index to 2020 through 2026 and set the values of all the cells to 100.
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{pd.DataFrame}} creates a dataframe  \sphinxhref{https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html\#pandas.DataFrame}{Description}

\item {} 
\sphinxAtStartPar
The expression \sphinxcode{\sphinxupquote{{[}v for v in range(2020,2026){]}}} dynamically creates a  python list, and fills it with  integers beginning with 2020 and ending 2025

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df} \PYG{o}{=} \PYG{n}{pd}\PYG{o}{.}\PYG{n}{DataFrame}\PYG{p}{(}                                 \PYG{c+c1}{\PYGZsh{} call the dataframe constructure }
    \PYG{l+m+mf}{100.000}\PYG{p}{,}                                           \PYG{c+c1}{\PYGZsh{} the values }
    \PYG{n}{index}\PYG{o}{=}\PYG{p}{[}\PYG{n}{v} \PYG{k}{for} \PYG{n}{v} \PYG{o+ow}{in} \PYG{n+nb}{range}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2026}\PYG{p}{)}\PYG{p}{]}\PYG{p}{,}           \PYG{c+c1}{\PYGZsh{}index}
    \PYG{n}{columns}\PYG{o}{=}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{A}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}                                  \PYG{c+c1}{\PYGZsh{} the column name }
                 \PYG{p}{)}
\PYG{n}{df}   \PYG{c+c1}{\PYGZsh{} the result of the last statement is displayed in the output cell }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A
2020  100.0
2021  100.0
2022  100.0
2023  100.0
2024  100.0
2025  100.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{\sphinxstyleliteralintitle{\sphinxupquote{.mfcalc()}} in action}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-in-action}}

\subsection{\sphinxstyleliteralintitle{\sphinxupquote{.mfcalc()}} example to calculate a new series}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-example-to-calculate-a-new-series}}
\sphinxAtStartPar
Use  mfcalc to calculate a new column (series) as a function of the existing A column series

\sphinxAtStartPar
The below call creates a new column x.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x = x(\PYGZhy{}1) + a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  100.0  100.0
2022  100.0  200.0
2023  100.0  300.0
2024  100.0  400.0
2025  100.0  500.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{NOTE:}

\sphinxAtStartPar
By default \sphinxcode{\sphinxupquote{.mfcalc}} will initialize a new variable with zeroes.
Moreover, if a formula passed to \sphinxcode{\sphinxupquote{.mfcalc}} contains a lag a value will be calculated for the first row only if there is data in the series for the preceding row.

\sphinxAtStartPar
Combining these two behaviours generates the result where the command \sphinxcode{\sphinxupquote{df.mfcalc('x = x(\sphinxhyphen{}1) + a')}} results in a zero in 2020 for X (because there was no X variable defined for 2019 (indeed no such row exists), but then the subsequent rows add the contempraenous value of A to the preceding value of x.

\begin{sphinxadmonition}{note}{Note:}
\sphinxAtStartPar
In the above example a  dataframe with the result is created and displayed, but the df dataframe did not change.  To have it change we would have had to assign it the result of the initial operation, as below.
\end{sphinxadmonition}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A
2020  100.0
2021  100.0
2022  100.0
2023  100.0
2024  100.0
2025  100.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df2}\PYG{o}{=}\PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{x = x(\PYGZhy{}1) + a}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Assign the result to df2}
\PYG{n}{df2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  100.0  100.0
2022  100.0  200.0
2023  100.0  300.0
2024  100.0  400.0
2025  100.0  500.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Recalculate A so  it grows by 2 percent}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:recalculate-a-so-it-grows-by-2-percent}}
\sphinxAtStartPar
mfcalcs knows that it can not start to calculate in 2020 as there is no lagged variable. So it will start calculating in 2021 and leave the pre\sphinxhyphen{}existing value unchanged.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{a =  1.02 *  a(\PYGZhy{}1)}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
               A
2020  100.000000
2021  102.000000
2022  104.040000
2023  106.120800
2024  108.243216
2025  110.408080
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res}\PYG{o}{.}\PYG{n}{pct\PYGZus{}change}\PYG{p}{(}\PYG{p}{)}\PYG{o}{*}\PYG{l+m+mi}{100} \PYG{c+c1}{\PYGZsh{} to display the percent changes}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A
2020  NaN
2021  2.0
2022  2.0
2023  2.0
2024  2.0
2025  2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{mfcalc(), the showeq option}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-the-showeq-option}}
\sphinxAtStartPar
The \sphinxcode{\sphinxupquote{showeq}} option is by default \sphinxcode{\sphinxupquote{= False}}.

\sphinxAtStartPar
By setting equal to \sphinxcode{\sphinxupquote{True}}, mfcalc can be used to express the normalization of an entered equation.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{dlog( a) =  0.02}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{showeq}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
FRML \PYGZlt{}\PYGZgt{} A=EXP(LOG(A(\PYGZhy{}1))+0.02)\PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{modelflow}} the expression \sphinxcode{\sphinxupquote{dlog(a)}} refers to the difference in the natural logarithm \(dlog(x_t) \equiv ln(x_t)-ln(x_{t-1})\) and is equal to the growth rate for the variable.

\sphinxAtStartPar
\sphinxcode{\sphinxupquote{.mfcalc()}} normalizes the equation such that the systems solves for a as follows:
\begin{equation*}
\begin{split}dlog(a)  = 0.02\end{split}
\end{equation*}\begin{equation*}
\begin{split}log(a)-log(a_{t-1}) = .02\end{split}
\end{equation*}\begin{equation*}
\begin{split}log(a)=log(a_{t-1})+.02\end{split}
\end{equation*}\begin{equation*}
\begin{split}a = e^{log(a_{t-1})+0.02}\end{split}
\end{equation*}\begin{equation*}
\begin{split}a =a_{t-1}*e^{0.02}\end{split}
\end{equation*}
\sphinxAtStartPar
which expressed in the business logic language of \sphinxcode{\sphinxupquote{modelflow}} is:

\sphinxAtStartPar
A=EXP(LOG(A(\sphinxhyphen{}1))+0.02)


\subsection{Using .diff (\protect\(\Delta\protect\)) with mfcalc}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:using-diff-delta-with-mfcalc}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{diff(a) =  2}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} Set delta to 2 }
\PYG{n}{res}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{p}{)}                      \PYG{c+c1}{\PYGZsh{} Display the delta }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
        A
2020  NaN
2021  2.0
2022  2.0
2023  2.0
2024  2.0
2025  2.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{mfcalc with several equations and arguments}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:mfcalc-with-several-equations-and-arguments}}
\sphinxAtStartPar
In addition to a single equation multiple commands can be executed with one command.

\sphinxAtStartPar
However, \sphinxstylestrong{be careful} because the equation commands are executed simultaneously, which, combined with the treatments of lags, means that results may differ from what would be expected if you ran the two commands sequentially.

\sphinxAtStartPar
For example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{diff(a) =  2}
\PYG{l+s+s1}{x = a + 42 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}

\PYG{n}{res}

\PYG{c+c1}{\PYGZsh{} use res.diff() to see the difference}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  102.0  144.0
2022  104.0  146.0
2023  106.0  148.0
2024  108.0  150.0
2025  110.0  152.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Here the diff(a) is not defined for 2020 because there is no value for a in 2019.

\sphinxAtStartPar
As a result \sphinxcode{\sphinxupquote{modelflow}} generates a result only for the periodf 2021 through 2025 and it is this result that is passed to the second equation, which adds 42 to this number. Thus X in 2020 is not 142 as one might have expected but zero, the value to which the newly created variable defaults.

\sphinxAtStartPar
Compare the results above with the results (below) when the two steps are not undertaken in the same mfcalc command.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res1} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{diff(a) =  2}
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}

\PYG{n}{res2} \PYG{o}{=} \PYG{n}{res1}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{x = a + 42 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}
\PYG{n}{res2}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
* Take care. Lags or leads in the equations, mfcalc run for 2021 to 2022
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0  142.0
2021  102.0  144.0
2022  104.0  146.0
2023  106.0  148.0
2024  108.0  150.0
2025  110.0  152.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\begin{sphinxadmonition}{danger}{Danger:}
\sphinxAtStartPar
In \sphinxcode{\sphinxupquote{.mfcalc()}}, when there are multiple equation commands is single call, they are executed simultaneously. This, combined with \sphinxcode{\sphinxupquote{mfcalc}}’s  treatments of lags, means only the results of the lagged calculation will be passed to other commands equations defined in the \sphinxcode{\sphinxupquote{.mfcalc}} command. As a consequence, results may differ from what would be expected and what you would see if you ran the two commands sequentially.
\end{sphinxadmonition}


\subsection{Setting a time frame with mfcalc.}
\label{\detokenize{content/04_PythonEssentials/ExtendingDataFrames:setting-a-time-frame-with-mfcalc}}
\sphinxAtStartPar
It can useful in some circumstances to limit the time frame for which the calculations are performed. By specifying a start date and end date enclosed in <> in a  line we can restrict the time period over which calculation is performed.

\sphinxAtStartPar
Below, as in the example above we have zeroes for x prior to 2023 when the expressions are executed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{res} \PYG{o}{=} \PYG{n}{df}\PYG{o}{.}\PYG{n}{mfcalc}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}
\PYG{l+s+s1}{\PYGZlt{}2023 2025\PYGZgt{}}
\PYG{l+s+s1}{diff(a) =  2}
\PYG{l+s+s1}{x = a + 42 }
\PYG{l+s+s1}{\PYGZsq{}\PYGZsq{}\PYGZsq{}}\PYG{p}{)}

\PYG{n}{res}\PYG{o}{.}\PYG{n}{diff}\PYG{p}{(}\PYG{p}{)}

\PYG{n}{res}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          A      X
2020  100.0    0.0
2021  100.0    0.0
2022  100.0    0.0
2023  102.0  144.0
2024  104.0  146.0
2025  106.0  148.0
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{Features}

\sphinxstepscope


\chapter{Useful model instance properties and methods}
\label{\detokenize{content/notebooks/modelflow_features:useful-model-instance-properties-and-methods}}\label{\detokenize{content/notebooks/modelflow_features::doc}}
\sphinxAtStartPar
The focus of this chapter is to introduce some properties and methods of the model instance.

\sphinxAtStartPar
First a model and data is loaded, then a scenario is run. Then we have some content to use.

\sphinxAtStartPar
A model instance gives the user access to a number of properties and methods which helps in managing the model and its results.

\sphinxAtStartPar
If \sphinxcode{\sphinxupquote{mmodel}} is a model instance \sphinxcode{\sphinxupquote{mmodel.<property>}} will return a property. Some properties can also be assigned by the user just by:
\begin{quote}

\sphinxAtStartPar
mmodel.property = something
\end{quote}

\sphinxAtStartPar
The model class itself also have a few properties. These are simple accessed by  \sphinxcode{\sphinxupquote{model.<property>}}.

\sphinxAtStartPar
Enjoy


\section{Import the model class}
\label{\detokenize{content/notebooks/modelflow_features:import-the-model-class}}
\sphinxAtStartPar
This class incorporates most of the methods used to manage a model.

\sphinxAtStartPar
Assuming the ModelFlow library has been installed on your machine, the following imports set up your notebook so that you can run the cells in this notebook.

\sphinxAtStartPar
In order to manipulate plots later on matplotlib.pyplot is also imported.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{c+c1}{\PYGZsh{}\PYGZpc{}matplotlib notebook}
\PYG{o}{\PYGZpc{}}\PYG{k}{matplotlib} inline
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{from} \PYG{n+nn}{modelclass} \PYG{k+kn}{import} \PYG{n}{model} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{matplotlib}\PYG{n+nn}{.}\PYG{n+nn}{pyplot} \PYG{k}{as} \PYG{n+nn}{plt} \PYG{c+c1}{\PYGZsh{} To manipulate plots }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Class methods to help in Jupyter Notebook}
\label{\detokenize{content/notebooks/modelflow_features:class-methods-to-help-in-jupyter-notebook}}

\subsection{.widescreen() use Jupyter Notebook in widescreen}
\label{\detokenize{content/notebooks/modelflow_features:widescreen-use-jupyter-notebook-in-widescreen}}
\sphinxAtStartPar
Enables the whole viewing area of the browser.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{widescreen}\PYG{p}{(}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.HTML object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.scroll\_off() Turn off scroll cells in Jupyter Notebook}
\label{\detokenize{content/notebooks/modelflow_features:scroll-off-turn-off-scroll-cells-in-jupyter-notebook}}
\sphinxAtStartPar
Can be useful

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{model}\PYG{o}{.}\PYG{n}{scroll\PYGZus{}off}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{.modelload Load a pre\sphinxhyphen{}cooked model, data and descriptions}
\label{\detokenize{content/notebooks/modelflow_features:modelload-load-a-pre-cooked-model-data-and-descriptions}}
\sphinxAtStartPar
In this notebook, we will be using a pre\sphinxhyphen{}existing  model of Pakistan.

\sphinxAtStartPar
The file ‘pak.pcim’ has been created from a Eviews workspace. It contains all that is needed to run the model:
\begin{itemize}
\item {} 
\sphinxAtStartPar
Model equations

\item {} 
\sphinxAtStartPar
Data

\item {} 
\sphinxAtStartPar
Simulation options

\item {} 
\sphinxAtStartPar
Variable descriptions

\end{itemize}

\sphinxAtStartPar
Using the ‘modelload’ method of the  ‘model’ class, a model instance ‘mpak’ and a ‘result’ DataFrame is created.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{,}\PYG{n}{baseline} \PYG{o}{=} \PYG{n}{model}\PYG{o}{.}\PYG{n}{modelload}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{../models/pak.pcim}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{run}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{silent}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
file read:  C:\PYGZbs{}modelflow manual\PYGZbs{}papers\PYGZbs{}mfbook\PYGZbs{}content\PYGZbs{}models\PYGZbs{}pak.pcim
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
\sphinxstylestrong{mpak} 
The \sphinxstyleemphasis{modelload} method processes the file and initiates the model, that we call ‘mpak’ (m for model and pak for Pakistan) with both equations and the data.

\sphinxAtStartPar
‘mpak’ is an \sphinxstylestrong{instance}  of the  model object with which we will work.

\sphinxAtStartPar
\sphinxstylestrong{baseline}  
‘result’ is a Pandas dataframe containing the data that was loaded.

\sphinxAtStartPar
\sphinxstylestrong{run=1} the model is simulated. The simulation timeframe  and options from the time the file where dumped will be used. The two objects \sphinxstylestrong{mpak.basedf} and \sphinxstylestrong{mpak.lastdf} will contain the simulation result. If run=0 the model will not be simulated.

\sphinxAtStartPar
\sphinxstylestrong{silent=1} if silent is set to 0  information regarding the simulation will be displayed.

\sphinxAtStartPar
\sphinxstylestrong{keep=’Baseline’} This saves the result in a dictionary mpak.keep\_solutions.


\section{Create a scenario}
\label{\detokenize{content/notebooks/modelflow_features:create-a-scenario}}
\sphinxAtStartPar
Many objects relates to comparison of different scenarios. So first a scenario is created by updating some exogenous variables.
In this case the carbon tax rates for gas, oil and coal are all set to 29 from 2023 to 2100. Then the scenario is simulated.
Now the mpak object contains a number of useful properties and methods.

\sphinxAtStartPar
You can find more on this experiment \DUrole{xref,myst}{here}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scenario\PYGZus{}exo}  \PYG{o}{=}  \PYG{n}{baseline}\PYG{o}{.}\PYG{n}{upd}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{\PYGZlt{}2020 2100\PYGZgt{} PAKGGREVCO2CER PAKGGREVCO2GER PAKGGREVCO2OER = 29}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{() Simulate on a dataframe}
\label{\detokenize{content/notebooks/modelflow_features:simulate-on-a-dataframe}}
\sphinxAtStartPar
When calling the model instance like \sphinxcode{\sphinxupquote{mpak(dataframe,start, end)}} the model will be simulated for the time frame \sphinxcode{\sphinxupquote{start to end}} using the dataframe.  
Just above we created a dataframe \sphinxcode{\sphinxupquote{scenario\_exo}} where the tax variables are updated. Now the \sphinxcode{\sphinxupquote{mpak}} can be simulated. We simulate from 2020 to 2100.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scenario} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{(}\PYG{n}{scenario\PYGZus{}exo}\PYG{p}{,}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2100}\PYG{p}{,}\PYG{n}{keep}\PYG{o}{=}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Coal, Oil and Gastax : 29}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{} runs the simulation}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Access results}
\label{\detokenize{content/notebooks/modelflow_features:access-results}}
\sphinxAtStartPar
Now we have two dataframes with results \sphinxcode{\sphinxupquote{baseline}} and \sphinxcode{\sphinxupquote{scenario}}. These dataframes can be manipulated and visualized
with the tools provided by the \sphinxstylestrong{pandas} library and other like \sphinxstylestrong{Matplotlib} and \sphinxstylestrong{Plotly}. However to make things easy the first and
latest simulation result is also in the mpak object:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxstylestrong{mpak.basedf}: Dataframe with the values for baseline

\item {} 
\sphinxAtStartPar
\sphinxstylestrong{mpak.lastdf}: Dataframe with the values for alternative

\end{itemize}

\sphinxAtStartPar
This means that .basedf and .lastdf will contain the same result after the first simulation. 
If new scenarios are simulated the data in .lastdf will then be replaced with the latest results.

\sphinxAtStartPar
These dataframes are used by a number of model instance methods as you will see later.

\sphinxAtStartPar
The user can assign dataframes to both .basedf and .lastdf. This is useful for comparing simulations which are not the first and last.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpak.basedf: Dataframe: with }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ years and }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ variables}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpak.lastdf: Dataframe: with }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ years and }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ variables}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
mpak.basedf: Dataframe: with 121 years and 1290 variables
mpak.lastdf: Dataframe: with 121 years and 1290 variables
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.keep\_solutions, A dictionary of dataframes with results}
\label{\detokenize{content/notebooks/modelflow_features:keep-solutions-a-dictionary-of-dataframes-with-results}}
\sphinxAtStartPar
Create a dictionary of dataframes with .keep\_solutions. Sometimes we want to be able to compare more than two scenarios. Using \sphinxcode{\sphinxupquote{keep='some description'}} the dataframe with results can be saved into a dictionary with the description as key and the dataframe as value.

\sphinxAtStartPar
In our example we have created two scenarios. A baseline and a scenario with the tax set to 29. So mpak.keep\_solutions looks like this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{mpak.keep\PYGZus{}solutions contains:}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{for} \PYG{n}{key}\PYG{p}{,}\PYG{n}{value} \PYG{o+ow}{in} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{keep\PYGZus{}solutions}\PYG{o}{.}\PYG{n}{items}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{key = }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{key}\PYG{l+s+si}{:}\PYG{l+s+s1}{25}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{|Dataframe: }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{value}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ years and }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{value}\PYG{o}{.}\PYG{n}{shape}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{ variables}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
mpak.keep\PYGZus{}solutions contains:
key = Baseline                 |Dataframe: 121 years and 1290 variables
key = Coal, Oil and Gastax : 29|Dataframe: 121 years and 1290 variables
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
Sometime it can be useful to reset the \sphinxcode{\sphinxupquote{.keep\_solutions}}, so that a new set of solutions can be inspected. This is done by replacing it with an empty dictionary. Two methods can be used:
\begin{quote}

\sphinxAtStartPar
mpak.keep\_solutions = \{\}
\end{quote}

\sphinxAtStartPar
or in the simulation call:
\begin{quote}

\sphinxAtStartPar
mpak(,,keep=’’)
\end{quote}


\subsection{More on manipulating keep\_solution:}
\label{\detokenize{content/notebooks/modelflow_features:more-on-manipulating-keep-solution}}
\sphinxAtStartPar
\DUrole{xref,myst}{Here}


\subsection{.oldkwargs, Options in the simulation call is persistent between calls}
\label{\detokenize{content/notebooks/modelflow_features:oldkwargs-options-in-the-simulation-call-is-persistent-between-calls}}
\sphinxAtStartPar
When simulating a model the parameters are persistent. So the user just have to provide the
solution options once. These persistent parameters are located in the property .oldkwargs.

\sphinxAtStartPar
In this case the persistent parameters are:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{oldkwargs}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZob{}\PYGZsq{}silent\PYGZsq{}: 1, \PYGZsq{}alfa\PYGZsq{}: 0.7, \PYGZsq{}ldumpvar\PYGZsq{}: 0, \PYGZsq{}keep\PYGZsq{}: \PYGZsq{}Coal, Oil and Gastax : 29\PYGZsq{}\PYGZcb{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The user may have to reset the parameters, this is done like this:

\sphinxAtStartPar
To reset the options just do:
\begin{quote}

\sphinxAtStartPar
mpak.oldkwargs = \{\}
\end{quote}


\section{.current\_per, The time frame operations are performed on}
\label{\detokenize{content/notebooks/modelflow_features:current-per-the-time-frame-operations-are-performed-on}}
\sphinxAtStartPar
Most operations on a model class instance operates on the current time frame.
It is a subset of the row index of the dataframe which is simulated.

\sphinxAtStartPar
In this case it is:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Int64Index([2020, 2021, 2022, 2023, 2024, 2025, 2026, 2027, 2028, 2029, 2030,
            2031, 2032, 2033, 2034, 2035, 2036, 2037, 2038, 2039, 2040, 2041,
            2042, 2043, 2044, 2045, 2046, 2047, 2048, 2049, 2050, 2051, 2052,
            2053, 2054, 2055, 2056, 2057, 2058, 2059, 2060, 2061, 2062, 2063,
            2064, 2065, 2066, 2067, 2068, 2069, 2070, 2071, 2072, 2073, 2074,
            2075, 2076, 2077, 2078, 2079, 2080, 2081, 2082, 2083, 2084, 2085,
            2086, 2087, 2088, 2089, 2090, 2091, 2092, 2093, 2094, 2095, 2096,
            2097, 2098, 2099, 2100],
           dtype=\PYGZsq{}int64\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
The possible times in the dataframe is contained in the \sphinxcode{\sphinxupquote{<dataframe>.index}} property.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{scenario}\PYG{o}{.}\PYG{n}{index}  \PYG{c+c1}{\PYGZsh{} the index of the dataframe}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Int64Index([1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988, 1989,
            ...
            2091, 2092, 2093, 2094, 2095, 2096, 2097, 2098, 2099, 2100],
           dtype=\PYGZsq{}int64\PYGZsq{}, length=121)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.smpl, Set time frame}
\label{\detokenize{content/notebooks/modelflow_features:smpl-set-time-frame}}
\sphinxAtStartPar
The time frame can be set like this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2025}\PYG{p}{)}
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Int64Index([2020, 2021, 2022, 2023, 2024, 2025], dtype=\PYGZsq{}int64\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.set\_smpl, Set timeframe for a local scope}
\label{\detokenize{content/notebooks/modelflow_features:set-smpl-set-timeframe-for-a-local-scope}}
\sphinxAtStartPar
For many operations it can be useful to apply the operations for a shorter time frame, but retain the global time frame after the operation. 
This can be done  with a \sphinxcode{\sphinxupquote{with}} statement like this.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Global time  before   }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl}\PYG{p}{(}\PYG{l+m+mi}{2022}\PYG{p}{,}\PYG{l+m+mi}{2023}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Local time frame      }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Unchanged global time }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Global time  before   Int64Index([2020, 2021, 2022, 2023, 2024, 2025], dtype=\PYGZsq{}int64\PYGZsq{})
Local time frame      Int64Index([2022, 2023], dtype=\PYGZsq{}int64\PYGZsq{})
Unchanged global time Int64Index([2020, 2021, 2022, 2023, 2024, 2025], dtype=\PYGZsq{}int64\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.set\_smpl\_relative Set relative timeframe for a local scope}
\label{\detokenize{content/notebooks/modelflow_features:set-smpl-relative-set-relative-timeframe-for-a-local-scope}}
\sphinxAtStartPar
When creating a script it can be useful to set the time frame relative to the
current time.

\sphinxAtStartPar
Like this:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Global time  before   }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl\PYGZus{}relative} \PYG{p}{(}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{p}{:}
    \PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Local time frame      }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n+nb}{print}\PYG{p}{(}\PYG{l+s+sa}{f}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Unchanged global time }\PYG{l+s+si}{\PYGZob{}}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{current\PYGZus{}per}\PYG{l+s+si}{\PYGZcb{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Global time  before   Int64Index([2020, 2021, 2022, 2023, 2024, 2025], dtype=\PYGZsq{}int64\PYGZsq{})
Local time frame      Int64Index([2019, 2020, 2021, 2022, 2023, 2024, 2025], dtype=\PYGZsq{}int64\PYGZsq{})
Unchanged global time Int64Index([2020, 2021, 2022, 2023, 2024, 2025], dtype=\PYGZsq{}int64\PYGZsq{})
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Using the index operator {[} {]} to select and visualize variables.}
\label{\detokenize{content/notebooks/modelflow_features:using-the-index-operator-to-select-and-visualize-variables}}\label{\detokenize{content/notebooks/modelflow_features:index-operator}}
\sphinxAtStartPar
The index operator {[} {]} can be used to select variables and then process the values for quick analysis.

\sphinxAtStartPar
To select variables the method accept patterns which defines variable names. Wildcards:
\begin{itemize}
\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}*}} matches everything

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{?}} matches any single character

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}{[}seq{]}}} matches any character in seq

\item {} 
\sphinxAtStartPar
\sphinxcode{\sphinxupquote{\textbackslash{}{[}!seq{]}}} matches any character not in seq

\end{itemize}

\sphinxAtStartPar
For more how wildcards can be used, the specification can be found here (https://docs.python.org/3/library/fnmatch.html)

\sphinxAtStartPar
In the following example we are selecting the results of mpak{[}‘PAKNYGDPMKTPKN’{]}

\sphinxAtStartPar
This call will return a special class (called \sphinxcode{\sphinxupquote{vis}}). It implements a number
of methods and properties which comes in handy for quick analyses.

\sphinxAtStartPar
Several properties and methods can be chained. An example:

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2100}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{colrow}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}
                \PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Difference to baseline in percent}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.8}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
But first some basic information


\subsection{model{[}‘\#ENDO’{]}}
\label{\detokenize{content/notebooks/modelflow_features:model-endo}}
\sphinxAtStartPar
Use ‘\#ENDO’ to access all endogenous variables in your model instance.

\sphinxAtStartPar
For the sake of space, the result is saved in the variable ‘allendo’ and not printed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{allendo} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{\PYGZsh{}ENDO}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}
\PYG{c+c1}{\PYGZsh{} allendo.show}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Access values in .lastdf and .basedf}
\label{\detokenize{content/notebooks/modelflow_features:access-values-in-lastdf-and-basedf}}
\sphinxAtStartPar
To limit the output printed, we set the time frame to 2020 to 2023.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2023}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar
To access the values of ‘PAKNYGDPMKTPKN’ and ‘PAKNECONPRVTKN’ from the latest simulation a small widget is displayed.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tab(children=(Tab(children=(HTML(value=\PYGZsq{}\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}utf\PYGZhy{}8\PYGZdq{} standalone=\PYGZdq{}no\PYGZdq{}?\PYGZgt{}\PYGZbs{}n\PYGZlt{}!DOCTYPE svg …
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxAtStartPar
To access the values of ‘PAKNYGDPMKTPKN’ and ‘PAKNECONPRVTKN’ from the base dataframe, specify .base

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{base}\PYG{o}{.}\PYG{n}{df} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      PAKNYGDPMKTPKN  PAKNECONPRVTKN
2020    2.627394e+07    2.367289e+07
2021    2.651137e+07    2.397282e+07
2022    2.668514e+07    2.416413e+07
2023    2.696308e+07    2.442786e+07
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.df  Pandas dataframe}
\label{\detokenize{content/notebooks/modelflow_features:df-pandas-dataframe}}
\sphinxAtStartPar
Sometime you need to perform additional operations on the values. Therefor the .df will return a dataframe with the selected variables.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
      PAKNYGDPMKTPKN  PAKNECONPRVTKN
2020    2.647002e+07    2.344055e+07
2021    2.676493e+07    2.366076e+07
2022    2.688965e+07    2.376966e+07
2023    2.708904e+07    2.395330e+07
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.show  as a html table with tooltips}
\label{\detokenize{content/notebooks/modelflow_features:show-as-a-html-table-with-tooltips}}
\sphinxAtStartPar
If you want the variable descriptions use this

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{show}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Tab(children=(Tab(children=(HTML(value=\PYGZsq{}\PYGZlt{}?xml version=\PYGZdq{}1.0\PYGZdq{} encoding=\PYGZdq{}utf\PYGZhy{}8\PYGZdq{} standalone=\PYGZdq{}no\PYGZdq{}?\PYGZgt{}\PYGZbs{}n\PYGZlt{}!DOCTYPE svg …
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.names Variable names}
\label{\detokenize{content/notebooks/modelflow_features:names-variable-names}}
\sphinxAtStartPar
If you select variables using wildcards, then you can access the names that correspond to your query.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDP??????}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{names}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
[\PYGZsq{}PAKNYGDPDISCCN\PYGZsq{},
 \PYGZsq{}PAKNYGDPDISCKN\PYGZsq{},
 \PYGZsq{}PAKNYGDPFCSTCN\PYGZsq{},
 \PYGZsq{}PAKNYGDPFCSTKN\PYGZsq{},
 \PYGZsq{}PAKNYGDPFCSTXN\PYGZsq{},
 \PYGZsq{}PAKNYGDPMKTPCD\PYGZsq{},
 \PYGZsq{}PAKNYGDPMKTPCN\PYGZsq{},
 \PYGZsq{}PAKNYGDPMKTPKD\PYGZsq{},
 \PYGZsq{}PAKNYGDPMKTPKN\PYGZsq{},
 \PYGZsq{}PAKNYGDPMKTPXN\PYGZsq{},
 \PYGZsq{}PAKNYGDPPOTLKN\PYGZsq{}]
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.frml The formulas}
\label{\detokenize{content/notebooks/modelflow_features:frml-the-formulas}}
\sphinxAtStartPar
Use .frml to access all the equations for the endogenous variables.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{frml}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
PAKNYGDPMKTPKN : FRML \PYGZlt{}\PYGZgt{} PAKNYGDPMKTPKN = PAKNECONPRVTKN+PAKNECONGOVTKN+PAKNEGDIFTOTKN+PAKNEGDISTKBKN+PAKNEEXPGNFSKN\PYGZhy{}PAKNEIMPGNFSKN+PAKNYGDPDISCKN+PAKADAP*PAKDISPREPKN \PYGZdl{}
PAKNECONPRVTKN : FRML \PYGZlt{}Z,EXO\PYGZgt{} PAKNECONPRVTKN = (PAKNECONPRVTKN(\PYGZhy{}1)*EXP(PAKNECONPRVTKN\PYGZus{}A+ (\PYGZhy{}0.2*(LOG(PAKNECONPRVTKN(\PYGZhy{}1))\PYGZhy{}LOG(1.21203101101442)\PYGZhy{}LOG((((PAKBXFSTREMTCD(\PYGZhy{}1)\PYGZhy{}PAKBMFSTREMTCD(\PYGZhy{}1))*PAKPANUSATLS(\PYGZhy{}1))+PAKGGEXPTRNSCN(\PYGZhy{}1)+PAKNYYWBTOTLCN(\PYGZhy{}1)*(1\PYGZhy{}PAKGGREVDRCTXN(\PYGZhy{}1)/100))/PAKNECONPRVTXN(\PYGZhy{}1)))+0.763938860758873*((LOG((((PAKBXFSTREMTCD\PYGZhy{}PAKBMFSTREMTCD)*PAKPANUSATLS)+PAKGGEXPTRNSCN+PAKNYYWBTOTLCN*(1\PYGZhy{}PAKGGREVDRCTXN/100))/PAKNECONPRVTXN))\PYGZhy{}(LOG((((PAKBXFSTREMTCD(\PYGZhy{}1)\PYGZhy{}PAKBMFSTREMTCD(\PYGZhy{}1))*PAKPANUSATLS(\PYGZhy{}1))+PAKGGEXPTRNSCN(\PYGZhy{}1)+PAKNYYWBTOTLCN(\PYGZhy{}1)*(1\PYGZhy{}PAKGGREVDRCTXN(\PYGZhy{}1)/100))/PAKNECONPRVTXN(\PYGZhy{}1))))\PYGZhy{}0.0634474791568939*DURING\PYGZus{}2009\PYGZhy{}0.3*(PAKFMLBLPOLYXN/100\PYGZhy{}((LOG(PAKNECONPRVTXN))\PYGZhy{}(LOG(PAKNECONPRVTXN(\PYGZhy{}1)))))) )) * (1\PYGZhy{}PAKNECONPRVTKN\PYGZus{}D)+ PAKNECONPRVTKN\PYGZus{}X*PAKNECONPRVTKN\PYGZus{}D \PYGZdl{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.rename() Rename variables to descriptions}
\label{\detokenize{content/notebooks/modelflow_features:rename-rename-variables-to-descriptions}}
\sphinxAtStartPar
Use .rename() to assign variable descriptions as variable names.

\sphinxAtStartPar
Handy when plotting!

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{df}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
          Real GDP  HH. Cons Real
2020  2.647002e+07   2.344055e+07
2021  2.676493e+07   2.366076e+07
2022  2.688965e+07   2.376966e+07
2023  2.708904e+07   2.395330e+07
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Transformations of solution results}
\label{\detokenize{content/notebooks/modelflow_features:transformations-of-solution-results}}
\sphinxAtStartPar
When the variables has been selected through the index operator a number of standard data transformations can be performed.


\begin{savenotes}\sphinxattablestart
\centering
\begin{tabulary}{\linewidth}[t]{|T|T|T|}
\hline
\sphinxstyletheadfamily 
\sphinxAtStartPar
Transfomation
&\sphinxstyletheadfamily 
\sphinxAtStartPar
Meaning
&\sphinxstyletheadfamily 
\sphinxAtStartPar
expression
\\
\hline
\sphinxAtStartPar
pct
&
\sphinxAtStartPar
Growth rates
&
\sphinxAtStartPar
\(\left(\cfrac{this_t}{this_{t-1}}-1\right )\)
\\
\hline
\sphinxAtStartPar
dif
&
\sphinxAtStartPar
Difference in level
&
\sphinxAtStartPar
\(l-b\)
\\
\hline
\sphinxAtStartPar
difpct
&
\sphinxAtStartPar
Differens in growth rate
&
\sphinxAtStartPar
\(\left( \cfrac{l_t}{l_{t-1}}-1 \right) - \left(\cfrac{b_t}{b_{t-1}}-1 \right)\)
\\
\hline
\sphinxAtStartPar
difpctlevel
&
\sphinxAtStartPar
differens in level in pct of baseline
&
\sphinxAtStartPar
\(\left( \cfrac{l_t-b_t}{b_{t}} \right) \)
\\
\hline
\sphinxAtStartPar
mul100
&
\sphinxAtStartPar
multiply by 100
&
\sphinxAtStartPar
\(this_t \times 100\)
\\
\hline
\end{tabulary}
\par
\sphinxattableend\end{savenotes}
\begin{itemize}
\item {} 
\sphinxAtStartPar
\(this\) is the chained value. Default lastdf but if preseeded by .base the values from .basedf will be used

\item {} 
\sphinxAtStartPar
\(b\) is the values from .basedf

\item {} 
\sphinxAtStartPar
\(l\) is the values from .lastdf

\end{itemize}


\subsection{.dif Difference in level}
\label{\detokenize{content/notebooks/modelflow_features:dif-difference-in-level}}
\sphinxAtStartPar
The ‘dif’ command displays the difference in levels of the latest and previous solutions.

\sphinxAtStartPar
\(l-b\)

\sphinxAtStartPar
where l is the variable from the .lastdf and b is the variable from .basedf.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dif}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{2013e08f59cf2fda412b98a62255965110e3146d12ddcc13ecbf1cb343875952}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.pct  Growthrates}
\label{\detokenize{content/notebooks/modelflow_features:pct-growthrates}}
\sphinxAtStartPar
Display growth rates

\sphinxAtStartPar
\(\left(\cfrac{l_t}{l_{t-1}}-1\right )\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pct}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{.difpct property difference in growthrate}
\label{\detokenize{content/notebooks/modelflow_features:difpct-property-difference-in-growthrate}}
\sphinxAtStartPar
The difference in the growth rates  between the last and base dataframe.

\sphinxAtStartPar
\(\left( \cfrac{l_t}{l_{t-1}}-1 \right) - \left(\cfrac{b_t}{b_{t-1}}-1 \right)\)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{.difpctlevel percent difference of  levels}
\label{\detokenize{content/notebooks/modelflow_features:difpctlevel-percent-difference-of-levels}}
\sphinxAtStartPar
\(\left( \cfrac{l_t-b_t}{b_{t}} \right) \)

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{mul100 multiply by 100}
\label{\detokenize{content/notebooks/modelflow_features:mul100-multiply-by-100}}
\sphinxAtStartPar
multiply growth rate by 100.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{c607053d8a5ad717aec35cfeb41a850f1b55560db799786d7ba7225f24c6dd21}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{.plot chart the selected and transformed variables}
\label{\detokenize{content/notebooks/modelflow_features:plot-chart-the-selected-and-transformed-variables}}
\sphinxAtStartPar
After the varaibles has been selected and transformed, they can  be plotted. The .plot() method plots the selected variables separately

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2100}\PYG{p}{)}\PYG{p}{;}

\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDP??????}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
C:\PYGZbs{}Users\PYGZbs{}ibhan\PYGZbs{}miniconda3\PYGZbs{}envs\PYGZbs{}mfbooknew\PYGZbs{}lib\PYGZbs{}site\PYGZhy{}packages\PYGZbs{}pandas\PYGZbs{}plotting\PYGZbs{}\PYGZus{}matplotlib\PYGZbs{}tools.py:227: RuntimeWarning: More than 20 figures have been opened. Figures created through the pyplot interface (`matplotlib.pyplot.figure`) are retained until explicitly closed and may consume too much memory. (To control this warning, see the rcParam `figure.max\PYGZus{}open\PYGZus{}warning`). Consider using `matplotlib.pyplot.close()`.
  fig = plt.figure(**fig\PYGZus{}kw)
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{Options to plot()}
\label{\detokenize{content/notebooks/modelflow_features:options-to-plot}}
\sphinxAtStartPar
Common:
\begin{itemize}
\item {} 
\sphinxAtStartPar
title (optional): title. Defaults to ‘’.

\item {} 
\sphinxAtStartPar
colrow (TYPE, optional): Columns per row . Defaults to 2.

\item {} 
\sphinxAtStartPar
sharey (TYPE, optional): Share y axis between plots. Defaults to False.

\item {} 
\sphinxAtStartPar
top (TYPE, optional): Relative position of the title. Defaults to 0.90.

\end{itemize}

\sphinxAtStartPar
More excotic:
\begin{itemize}
\item {} 
\sphinxAtStartPar
splitchar (TYPE, optional): If the name should be split . Defaults to ‘\_\_’.

\item {} 
\sphinxAtStartPar
savefig (TYPE, optional): Save figure. Defaults to ‘’.

\item {} 
\sphinxAtStartPar
xsize  (TYPE, optional): x size default to 10

\item {} 
\sphinxAtStartPar
ysize  (TYPE, optional): y size per row, defaults to 2

\item {} 
\sphinxAtStartPar
ppos (optional): \# of position to use if split. Defaults to \sphinxhyphen{}1.

\item {} 
\sphinxAtStartPar
kind (TYPE, optional): Matplotlib kind . Defaults to ‘line’.

\end{itemize}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDP??????}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{GDP growth }\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{top} \PYG{o}{=} \PYG{l+m+mf}{0.92}\PYG{p}{)}\PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{Plotting inspiration}
\label{\detokenize{content/notebooks/modelflow_features:plotting-inspiration}}
\sphinxAtStartPar
The following graph shows the components of GDP using the values of the baseline dataframe.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN PAKNEGDIFTOTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYGZbs{}
\PYG{n}{difpctlevel}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYGZbs{}
\PYG{n}{plot}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Components of GDP in pct of baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{colrow}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{top}\PYG{o}{=}\PYG{l+m+mf}{0.90}\PYG{p}{,}\PYG{n}{kind}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bar}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Heatmaps}
\label{\detokenize{content/notebooks/modelflow_features:heatmaps}}
\sphinxAtStartPar
For some model types heatmaps can be helpful, and they come out of the box. This feature was developed for use by bank stress test models.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{heatmap} \PYG{o}{=} \PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{pct}\PYG{o}{.}\PYG{n}{rename}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{mul100}\PYG{o}{.}\PYG{n}{heat}\PYG{p}{(}\PYG{n}{title}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Growth rates}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{annot}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{dec}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{size}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{l+m+mi}{3}\PYG{p}{)}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}
\sphinxAtStartPar



\subsection{Violin and boxplots,}
\label{\detokenize{content/notebooks/modelflow_features:violin-and-boxplots}}
\sphinxAtStartPar
Not obvious for macro models, but useful for stress test  models with many banks.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl}\PYG{p}{(}\PYG{l+m+mi}{2020}\PYG{p}{,}\PYG{l+m+mi}{2030}\PYG{p}{)}\PYG{p}{:} 
    \PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{box}\PYG{p}{(}\PYG{p}{)}  
    \PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{difpct}\PYG{o}{.}\PYG{n}{violin}\PYG{p}{(}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\subsection{Plot baseline vs alternative}
\label{\detokenize{content/notebooks/modelflow_features:plot-baseline-vs-alternative}}
\sphinxAtStartPar
A raw routine, only showing levels.
To make it really useful it should be expanded.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot\PYGZus{}alt}\PYG{p}{(}\PYG{p}{)} \PYG{p}{;}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}

\end{sphinxuseclass}

\section{.draw() Graphical presentation of relationships between variables}
\label{\detokenize{content/notebooks/modelflow_features:draw-graphical-presentation-of-relationships-between-variables}}
\sphinxAtStartPar
.draw() helps you understand the relationship between variables in your model better.

\sphinxAtStartPar
The thickness the arrow reflect the attribution of the the upstream variable to the impact on the downstream variable.


\subsection{.draw(up = level, down = level)}
\label{\detokenize{content/notebooks/modelflow_features:draw-up-level-down-level}}
\sphinxAtStartPar
You can specify how many levels up and down you want in your graphical presentation (Needs more explanation).

\sphinxAtStartPar
In this example all variables that depend directly upon GDP and consumption as well as those that are determined by them, are displayed. This means one step upstream in the model logic and one step downstream.

\sphinxAtStartPar
More on the how to visualize the logic structure \DUrole{xref,myst}{here}

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{n}{up}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} diagram of all direct dependencies }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.SVG object\PYGZgt{}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.SVG object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\subsection{.draw(filter =<minimal impact>)}
\label{\detokenize{content/notebooks/modelflow_features:draw-filter-minimal-impact}}
\sphinxAtStartPar
By specifying filter=  only links where the minimal impact is more than <minimal impact> are show. In this case 20\%

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{draw}\PYG{p}{(}\PYG{n}{up}\PYG{o}{=}\PYG{l+m+mi}{3}\PYG{p}{,}\PYG{n}{down}\PYG{o}{=}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n+nb}{filter}\PYG{o}{=}\PYG{l+m+mi}{20}\PYG{p}{)}  
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYGZlt{}IPython.core.display.SVG object\PYGZgt{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{dekomp() Attrribution of right hand side variables to change in result.}
\label{\detokenize{content/notebooks/modelflow_features:dekomp-attrribution-of-right-hand-side-variables-to-change-in-result}}
\sphinxAtStartPar
For more information on attribution look \DUrole{xref,myst}{here}

\sphinxAtStartPar
The dekomp command decomposes the contributions of the right hand side variables to the observed change in the left hand side variables.

\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{with} \PYG{n}{mpak}\PYG{o}{.}\PYG{n}{set\PYGZus{}smpl}\PYG{p}{(}\PYG{l+m+mi}{2021}\PYG{p}{,}\PYG{l+m+mi}{2025}\PYG{p}{)}\PYG{p}{:}
    \PYG{n}{mpak}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPKN PAKNECONPRVTKN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{.}\PYG{n}{dekomp}\PYG{p}{(}\PYG{p}{)}  \PYG{c+c1}{\PYGZsh{} frml attribution }
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
Formula        : FRML  \PYGZlt{}\PYGZgt{} PAKNYGDPMKTPKN = PAKNECONPRVTKN+PAKNECONGOVTKN+PAKNEGDIFTOTKN+PAKNEGDISTKBKN+PAKNEEXPGNFSKN\PYGZhy{}PAKNEIMPGNFSKN+PAKNYGDPDISCKN+PAKADAP*PAKDISPREPKN \PYGZdl{} 

                       2021        2022        2023        2024        2025
Variable    lag                                                            
Base        0   26511370.41 26685141.87 26963077.57 27393200.36 27963231.53
Alternative 0   26764926.87 26889649.52 27089036.50 27454422.35 27979057.19
Difference  0     253556.46   204507.65   125958.93    61221.99    15825.66
Percent     0          0.96        0.77        0.47        0.22        0.06

 Contributions to differende for  PAKNYGDPMKTPKN
                         2021       2022       2023       2024       2025
Variable       lag                                                       
PAKNECONPRVTKN 0   \PYGZhy{}312052.97 \PYGZhy{}394466.14 \PYGZhy{}474558.93 \PYGZhy{}531755.17 \PYGZhy{}563616.01
PAKNECONGOVTKN 0    303335.99  268694.45  232506.87  209988.19  197439.80
PAKNEGDIFTOTKN 0    188565.48  188222.74  177226.36  163571.78  148739.93
PAKNEGDISTKBKN 0        \PYGZhy{}0.02      \PYGZhy{}0.01      \PYGZhy{}0.02      \PYGZhy{}0.02      \PYGZhy{}0.05
PAKNEEXPGNFSKN 0     \PYGZhy{}2911.23   \PYGZhy{}5414.50   \PYGZhy{}7960.34  \PYGZhy{}10272.64  \PYGZhy{}12204.84
PAKNEIMPGNFSKN 0     76619.12  147471.06  198744.89  229689.74  245466.56
PAKNYGDPDISCKN 0        \PYGZhy{}0.02      \PYGZhy{}0.01      \PYGZhy{}0.02      \PYGZhy{}0.02      \PYGZhy{}0.05
PAKADAP        0        \PYGZhy{}0.02      \PYGZhy{}0.01      \PYGZhy{}0.02      \PYGZhy{}0.02      \PYGZhy{}0.05
PAKDISPREPKN   0        \PYGZhy{}0.02      \PYGZhy{}0.01      \PYGZhy{}0.02      \PYGZhy{}0.02      \PYGZhy{}0.05

 Share of contributions to differende for  PAKNYGDPMKTPKN
                          2021        2022        2023        2024        2025
Variable       lag                                                            
PAKNEIMPGNFSKN 0           30\PYGZpc{}         72\PYGZpc{}        158\PYGZpc{}        375\PYGZpc{}       1551\PYGZpc{}
PAKNECONGOVTKN 0          120\PYGZpc{}        131\PYGZpc{}        185\PYGZpc{}        343\PYGZpc{}       1248\PYGZpc{}
PAKNEGDIFTOTKN 0           74\PYGZpc{}         92\PYGZpc{}        141\PYGZpc{}        267\PYGZpc{}        940\PYGZpc{}
PAKNEGDISTKBKN 0           \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}
PAKNYGDPDISCKN 0           \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}
PAKADAP        0           \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}
PAKDISPREPKN   0           \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}
PAKNEEXPGNFSKN 0           \PYGZhy{}1\PYGZpc{}         \PYGZhy{}3\PYGZpc{}         \PYGZhy{}6\PYGZpc{}        \PYGZhy{}17\PYGZpc{}        \PYGZhy{}77\PYGZpc{}
PAKNECONPRVTKN 0         \PYGZhy{}123\PYGZpc{}       \PYGZhy{}193\PYGZpc{}       \PYGZhy{}377\PYGZpc{}       \PYGZhy{}869\PYGZpc{}      \PYGZhy{}3561\PYGZpc{}
Total          0          100\PYGZpc{}        100\PYGZpc{}        100\PYGZpc{}        100\PYGZpc{}        100\PYGZpc{}
Residual       0           \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}

 Contribution to growth rate PAKNYGDPMKTPKN
                          2021        2022        2023        2024        2025
Variable       lag                                                            
PAKNECONPRVTKN 0         \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNECONGOVTKN 0          0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKNEGDIFTOTKN 0          0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKNEGDISTKBKN 0         \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNEEXPGNFSKN 0         \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNEIMPGNFSKN 0          0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKNYGDPDISCKN 0         \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKADAP        0         \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKDISPREPKN   0         \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}

Formula        : FRML \PYGZlt{}Z,EXO\PYGZgt{} PAKNECONPRVTKN = (PAKNECONPRVTKN(\PYGZhy{}1)*EXP(PAKNECONPRVTKN\PYGZus{}A+ (\PYGZhy{}0.2*(LOG(PAKNECONPRVTKN(\PYGZhy{}1))\PYGZhy{}LOG(1.21203101101442)\PYGZhy{}LOG((((PAKBXFSTREMTCD(\PYGZhy{}1)\PYGZhy{}PAKBMFSTREMTCD(\PYGZhy{}1))*PAKPANUSATLS(\PYGZhy{}1))+PAKGGEXPTRNSCN(\PYGZhy{}1)+PAKNYYWBTOTLCN(\PYGZhy{}1)*(1\PYGZhy{}PAKGGREVDRCTXN(\PYGZhy{}1)/100))/PAKNECONPRVTXN(\PYGZhy{}1)))+0.763938860758873*((LOG((((PAKBXFSTREMTCD\PYGZhy{}PAKBMFSTREMTCD)*PAKPANUSATLS)+PAKGGEXPTRNSCN+PAKNYYWBTOTLCN*(1\PYGZhy{}PAKGGREVDRCTXN/100))/PAKNECONPRVTXN))\PYGZhy{}(LOG((((PAKBXFSTREMTCD(\PYGZhy{}1)\PYGZhy{}PAKBMFSTREMTCD(\PYGZhy{}1))*PAKPANUSATLS(\PYGZhy{}1))+PAKGGEXPTRNSCN(\PYGZhy{}1)+PAKNYYWBTOTLCN(\PYGZhy{}1)*(1\PYGZhy{}PAKGGREVDRCTXN(\PYGZhy{}1)/100))/PAKNECONPRVTXN(\PYGZhy{}1))))\PYGZhy{}0.0634474791568939*DURING\PYGZus{}2009\PYGZhy{}0.3*(PAKFMLBLPOLYXN/100\PYGZhy{}((LOG(PAKNECONPRVTXN))\PYGZhy{}(LOG(PAKNECONPRVTXN(\PYGZhy{}1)))))) )) * (1\PYGZhy{}PAKNECONPRVTKN\PYGZus{}D)+ PAKNECONPRVTKN\PYGZus{}X*PAKNECONPRVTKN\PYGZus{}D  \PYGZdl{} 

                       2021        2022        2023        2024        2025
Variable    lag                                                            
Base        0   23972815.36 24164128.02 24427863.05 24818524.47 25323255.17
Alternative 0   23660762.40 23769661.89 23953304.14 24286769.32 24759639.22
Difference  0    \PYGZhy{}312052.95  \PYGZhy{}394466.13  \PYGZhy{}474558.91  \PYGZhy{}531755.15  \PYGZhy{}563615.95
Percent     0         \PYGZhy{}1.30       \PYGZhy{}1.63       \PYGZhy{}1.94       \PYGZhy{}2.14       \PYGZhy{}2.23

 Contributions to differende for  PAKNECONPRVTKN
                           2021       2022       2023       2024       2025
Variable         lag                                                       
PAKNECONPRVTKN   \PYGZhy{}1  \PYGZhy{}187434.07 \PYGZhy{}250462.33 \PYGZhy{}317486.72 \PYGZhy{}384175.74 \PYGZhy{}432745.55
PAKNECONPRVTKN\PYGZus{}A  0       \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.04
PAKBXFSTREMTCD   \PYGZhy{}1   \PYGZhy{}38694.42  \PYGZhy{}49412.27  \PYGZhy{}52084.76  \PYGZhy{}50817.15  \PYGZhy{}48170.52
PAKBMFSTREMTCD   \PYGZhy{}1      120.58     140.33     135.37     121.42     106.31
PAKPANUSATLS     \PYGZhy{}1     3137.57    3566.27    3817.26    3916.63    3901.04
PAKGGEXPTRNSCN   \PYGZhy{}1    \PYGZhy{}2382.89   \PYGZhy{}4372.94   \PYGZhy{}5966.91   \PYGZhy{}7223.04   \PYGZhy{}8206.86
PAKNYYWBTOTLCN   \PYGZhy{}1   \PYGZhy{}78794.18 \PYGZhy{}120093.04 \PYGZhy{}145773.43 \PYGZhy{}156461.75 \PYGZhy{}167189.37
PAKGGREVDRCTXN   \PYGZhy{}1       \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.04
PAKNECONPRVTXN   \PYGZhy{}1   204247.65  231199.67  249025.22  258789.48  262005.59
PAKBXFSTREMTCD    0    66466.87   69836.78   67727.29   63861.51   59511.44
PAKBMFSTREMTCD    0     \PYGZhy{}189.25    \PYGZhy{}182.00    \PYGZhy{}162.26    \PYGZhy{}141.32    \PYGZhy{}122.29
PAKPANUSATLS      0    \PYGZhy{}4809.78   \PYGZhy{}5132.40   \PYGZhy{}5233.84   \PYGZhy{}5184.63   \PYGZhy{}5043.02
PAKGGEXPTRNSCN    0     5895.35    8018.71    9646.92   10900.77   11850.22
PAKNYYWBTOTLCN    0   160980.65  194563.25  207466.32  220404.39  237003.52
PAKGGREVDRCTXN    0       \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.04
PAKNECONPRVTXN    0  \PYGZhy{}410022.04 \PYGZhy{}440677.37 \PYGZhy{}455322.70 \PYGZhy{}458425.12 \PYGZhy{}453478.88
DURING\PYGZus{}2009       0       \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.04
PAKFMLBLPOLYXN    0   \PYGZhy{}34994.35  \PYGZhy{}36409.85  \PYGZhy{}35203.57  \PYGZhy{}32189.52  \PYGZhy{}28049.75
PAKNECONPRVTKN\PYGZus{}D  0       \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.04
PAKNECONPRVTKN\PYGZus{}X  0       \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.01      \PYGZhy{}0.04

 Share of contributions to differende for  PAKNECONPRVTKN
                            2021        2022        2023        2024        2025
Variable         lag                                                            
PAKNECONPRVTXN    0         131\PYGZpc{}        112\PYGZpc{}         96\PYGZpc{}         86\PYGZpc{}         80\PYGZpc{}
PAKNECONPRVTKN   \PYGZhy{}1          60\PYGZpc{}         63\PYGZpc{}         67\PYGZpc{}         72\PYGZpc{}         77\PYGZpc{}
PAKNYYWBTOTLCN   \PYGZhy{}1          25\PYGZpc{}         30\PYGZpc{}         31\PYGZpc{}         29\PYGZpc{}         30\PYGZpc{}
PAKBXFSTREMTCD   \PYGZhy{}1          12\PYGZpc{}         13\PYGZpc{}         11\PYGZpc{}         10\PYGZpc{}          9\PYGZpc{}
PAKFMLBLPOLYXN    0          11\PYGZpc{}          9\PYGZpc{}          7\PYGZpc{}          6\PYGZpc{}          5\PYGZpc{}
PAKGGEXPTRNSCN   \PYGZhy{}1           1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}
PAKPANUSATLS      0           2\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}
PAKBMFSTREMTCD    0           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
PAKNECONPRVTKN\PYGZus{}A  0           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
PAKGGREVDRCTXN   \PYGZhy{}1           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
                  0           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
DURING\PYGZus{}2009       0           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
PAKNECONPRVTKN\PYGZus{}D  0           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
PAKNECONPRVTKN\PYGZus{}X  0           0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}          0\PYGZpc{}
PAKBMFSTREMTCD   \PYGZhy{}1          \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}         \PYGZhy{}0\PYGZpc{}
PAKPANUSATLS     \PYGZhy{}1          \PYGZhy{}1\PYGZpc{}         \PYGZhy{}1\PYGZpc{}         \PYGZhy{}1\PYGZpc{}         \PYGZhy{}1\PYGZpc{}         \PYGZhy{}1\PYGZpc{}
PAKGGEXPTRNSCN    0          \PYGZhy{}2\PYGZpc{}         \PYGZhy{}2\PYGZpc{}         \PYGZhy{}2\PYGZpc{}         \PYGZhy{}2\PYGZpc{}         \PYGZhy{}2\PYGZpc{}
PAKBXFSTREMTCD    0         \PYGZhy{}21\PYGZpc{}        \PYGZhy{}18\PYGZpc{}        \PYGZhy{}14\PYGZpc{}        \PYGZhy{}12\PYGZpc{}        \PYGZhy{}11\PYGZpc{}
PAKNYYWBTOTLCN    0         \PYGZhy{}52\PYGZpc{}        \PYGZhy{}49\PYGZpc{}        \PYGZhy{}44\PYGZpc{}        \PYGZhy{}41\PYGZpc{}        \PYGZhy{}42\PYGZpc{}
PAKNECONPRVTXN   \PYGZhy{}1         \PYGZhy{}65\PYGZpc{}        \PYGZhy{}59\PYGZpc{}        \PYGZhy{}52\PYGZpc{}        \PYGZhy{}49\PYGZpc{}        \PYGZhy{}46\PYGZpc{}
Total             0         101\PYGZpc{}        101\PYGZpc{}        101\PYGZpc{}        101\PYGZpc{}        101\PYGZpc{}
Residual          0           1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}          1\PYGZpc{}

 Contribution to growth rate PAKNECONPRVTKN
                            2021        2022        2023        2024        2025
Variable         lag                                                            
PAKNECONPRVTKN   \PYGZhy{}1         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKNECONPRVTKN\PYGZus{}A  0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKBXFSTREMTCD   \PYGZhy{}1        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKBMFSTREMTCD   \PYGZhy{}1         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKPANUSATLS     \PYGZhy{}1         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKGGEXPTRNSCN   \PYGZhy{}1        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNYYWBTOTLCN   \PYGZhy{}1        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKGGREVDRCTXN   \PYGZhy{}1        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNECONPRVTXN   \PYGZhy{}1         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKBXFSTREMTCD    0         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKBMFSTREMTCD    0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKPANUSATLS      0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKGGEXPTRNSCN    0         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKNYYWBTOTLCN    0         0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}        0.0\PYGZpc{}
PAKGGREVDRCTXN    0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNECONPRVTXN    0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
DURING\PYGZus{}2009       0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKFMLBLPOLYXN    0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNECONPRVTKN\PYGZus{}D  0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
PAKNECONPRVTKN\PYGZus{}X  0        \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}       \PYGZhy{}0.0\PYGZpc{}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}

\section{Bespoken plots using matplotlib  (or plotly \sphinxhyphen{}later) (should go to a separate plot book}
\label{\detokenize{content/notebooks/modelflow_features:bespoken-plots-using-matplotlib-or-plotly-later-should-go-to-a-separate-plot-book}}
\sphinxAtStartPar
The predefined plots are not necessary created for presentation purpose. To create  bespoken plots the they can be
constructed directly in python scripts. The two main libraries are matplotlib, plotly but any ther python plotting library can be used. Here is an example using matplotlib.


\section{Plot four separate plots of multiple series in grid}
\label{\detokenize{content/notebooks/modelflow_features:plot-four-separate-plots-of-multiple-series-in-grid}}
\begin{sphinxuseclass}{cell}\begin{sphinxVerbatimInput}

\begin{sphinxuseclass}{cell_input}
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{figure}\PYG{p}{,}\PYG{n}{axs}\PYG{o}{=} \PYG{n}{plt}\PYG{o}{.}\PYG{n}{subplots}\PYG{p}{(}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{p}{,}\PYG{n}{figsize}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{11}\PYG{p}{,} \PYG{l+m+mi}{7}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGBALOVRLCN\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGBALOVRLCN\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scenario}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}axs[0,0].legend()}

\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGDBTTOTLCN\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGDBTTOTLCN\PYGZus{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scenario}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGREVTOTLCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGREVTOTLCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scenario}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}

\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGREVGRNTCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{basedf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{plot}\PYG{p}{(}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKGGREVGRNTCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{/}\PYG{n}{mpak}\PYG{o}{.}\PYG{n}{lastdf}\PYG{o}{.}\PYG{n}{loc}\PYG{p}{[}\PYG{l+m+mi}{2020}\PYG{p}{:}\PYG{l+m+mi}{2099}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{PAKNYGDPMKTPCN}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{o}{*}\PYG{l+m+mi}{100}\PYG{p}{,}\PYG{n}{label}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scenario}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{)}
\PYG{c+c1}{\PYGZsh{}axs2[4].plot(mpak.lastdf.loc[2000:2099,\PYGZsq{}PAKGGREVGRNTCN\PYGZsq{}]/mpak.basedf.loc[2000:2099,\PYGZsq{}PAKNYGDPMKTPCN\PYGZsq{}]*100,label=\PYGZsq{}Scenario\PYGZsq{})}

\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{title}\PYG{o}{.}\PYG{n}{set\PYGZus{}text}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fiscal balance (}\PYG{l+s+si}{\PYGZpc{} o}\PYG{l+s+s2}{f GDP)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{title}\PYG{o}{.}\PYG{n}{set\PYGZus{}text}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Gov}\PYG{l+s+s2}{\PYGZsq{}}\PYG{l+s+s2}{t Debt (}\PYG{l+s+si}{\PYGZpc{} o}\PYG{l+s+s2}{f GDP)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{.}\PYG{n}{title}\PYG{o}{.}\PYG{n}{set\PYGZus{}text}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Total revenues (}\PYG{l+s+si}{\PYGZpc{} o}\PYG{l+s+s2}{f GDP)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{axs}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{o}{.}\PYG{n}{title}\PYG{o}{.}\PYG{n}{set\PYGZus{}text}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Grant Revenues (}\PYG{l+s+si}{\PYGZpc{} o}\PYG{l+s+s2}{f GDP)}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}
\PYG{n}{figure}\PYG{o}{.}\PYG{n}{suptitle}\PYG{p}{(}\PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{Fiscal outcomes}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{)}

\PYG{n}{plt}\PYG{o}{.}\PYG{n}{figlegend}\PYG{p}{(}\PYG{p}{[}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Baseline}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{Scenario}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{]}\PYG{p}{,}\PYG{n}{loc}\PYG{o}{=}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{lower left}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{,}\PYG{n}{ncol}\PYG{o}{=}\PYG{l+m+mi}{5}\PYG{p}{)}  
\PYG{n}{figure}\PYG{o}{.}\PYG{n}{tight\PYGZus{}layout}\PYG{p}{(}\PYG{n}{pad}\PYG{o}{=}\PYG{l+m+mf}{2.3}\PYG{p}{)} \PYG{c+c1}{\PYGZsh{}Ensures legend does not overlap dates}
\PYG{n}{figure}
\end{sphinxVerbatim}

\end{sphinxuseclass}\end{sphinxVerbatimInput}
\begin{sphinxVerbatimOutput}

\begin{sphinxuseclass}{cell_output}
\noindent\sphinxincludegraphics{{af263b8b7718467e4adcce4f07a1db6ce46b66ee3c78d4e8505248794bb2d008}.png}

\end{sphinxuseclass}\end{sphinxVerbatimOutput}

\end{sphinxuseclass}
\sphinxstepscope


\part{More}

\sphinxstepscope

\begin{sphinxthebibliography}{BCJ+19}
\bibitem[Bla18]{content/litterature:id17}
\sphinxAtStartPar
Olivier Blanchard. On the future of Macroeconomic models. \sphinxstyleemphasis{Oxford Review of Economic Policy}, 34(1\sphinxhyphen{}2):43–54, 2018. URL: \sphinxurl{https://academic.oup.com/oxrep/article/34/1-2/43/4781808}, \sphinxhref{https://doi.org/https://doi.org/10.1093/oxrep/grx045}{doi:https://doi.org/10.1093/oxrep/grx045}.
\bibitem[BCJ+19]{content/litterature:id15}
\sphinxAtStartPar
Andrew Burns, Benoit Campagne, Charl Jooste, David Stephan, and Thi Thanh Bui. \sphinxstyleemphasis{The World Bank Macro\sphinxhyphen{}Fiscal Model Technical Description}. Number 8965 in Policy Research Working Papers. World Bank, Washington DC., 2019. URL: \sphinxurl{https://openknowledge.worldbank.org/handle/10986/32217}.
\bibitem[BJS21a]{content/litterature:id14}
\sphinxAtStartPar
Andrew Burns, Charl Jooste, and Gregor Schwerhoff. \sphinxstyleemphasis{Climate Modeling for Macroeconomic Policy : A Case Study for Pakistan}. Number 9780 in Policy Research Working Papers. World Bank, Washington, DC, 2021. URL: \sphinxurl{https://openknowledge.worldbank.org/bitstream/handle/10986/36307/Climate-Modeling-for-Macroeconomic-Policy-A-Case-Study-for-Pakistan.pdf?sequence=1\&isAllowed=y}.
\bibitem[BJS21b]{content/litterature:id18}
\sphinxAtStartPar
Andrew Burns, Charl Jooste, and Gregor Schwerhoff. \sphinxstyleemphasis{Macroeconomic Modeling of Managing Hurricane Damage in the Caribbean: The Case of Jamaica}. Volume 9505 of Policy Research Working Paper. World Bank, Washington DC., 2021. URL: \sphinxurl{https://documents1.worldbank.org/curated/en/593351609776234361/pdf/Macroeconomic-Modeling-of-Managing-Hurricane-Damage-in-the-Caribbean-The-Case-of-Jamaica.pdf}.
\bibitem[DJ13]{content/litterature:id19}
\sphinxAtStartPar
Peter B Dixon and DFale W. Jorgenson. \sphinxstyleemphasis{Handbook of Computable General Equilibrium Modelling}. Volume 1A. Elsevier B.V., 2013. ISBN ISSN: 2211\sphinxhyphen{}6885. URL: \sphinxurl{https://www.sciencedirect.com/handbook/handbook-of-computable-general-equilibrium-modeling/}.
\end{sphinxthebibliography}







\renewcommand{\indexname}{Index}
\printindex
\end{document}